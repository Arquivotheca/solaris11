#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License, Version 1.0 only
# (the "License").  You may not use this file except in compliance
# with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#ident	"%Z%%M%	%I%	%E% SMI"

FILES

Makefile	- compiles the header files  and also the interpreter.
		  It also runs forthgen on your *.fdbg files and
		  creates the forthdebug file.  It will also install the
		  forthdebug file in kernel/drv.

*.fdbg		- a file specifying a struct you are interested in and
		  the necessary header files

*.fth		- generated by forthgen from *.fdbg

kdbg.fth	- It has the forth program.

forthdebug	- is the concatenation of kdbg.fth and and all *fth files.
		  This file gets installed in kernel/drv and will be read in
		  by the kernel during boot up (if obpdebug or fortdebug
		  are set).


Ques: How do I create a word for a struct I am interested in?

Ans:
	1) Look in *.fdbg files to make sure that it isn't already in the
	debugger.

	2) If not, then edit one of the existing  *.fdbg files or create a new
	file called somename.fdbg - if you think the existing ones don't satisfy
	your needs.  Just add the names of the structs you are interested in. If
	you want only certain members of the structs to be printed then add the
	member names and the format wanted below the struct name. Look at the
	*.fdbg files to see how this is done.  Remember to check in to SCCS.

	3) Add the somename file where the struct is defined to the Makefile

	4) Now do a "make". Look in the file forthdebug to see if words for
	your structs have been created. If not, go back to step 2.

	5) Install(1) will pick up forthdebug and install in kernel/misc

Ques:	How do I add forth words?

Ans:	In the .fdbg file - of your choice - type in the following

	forth_start

	type words here

	forth_end


	All lines between the forth_start  and forth_end will be
	copied over to the forthdebug file without any modifications.

Ques:	How do I run it?

Ans:	Here is a sample session. Comments are in ()s.


ok kdbg-words
	( enter the debugger )
ok words
	( list debugging words available )
	( not all these are in the gate yet, but the most-requested
	( .threadlist is )
	( the printing words start with '.'  e.g. .thread .tte )
	( I will move the non-printing words to a separate vocabulary )
	( soon )
.machcpu      machcpu-words .intr_vector  intr_vector-words 
.tte          tte-words     .sfmmu        sfmmu-words 
.sf_hment     sf_hment-words              .hmehash_bucket 
hmehash_bucket-words        .hme_blk      hme_blk-words .ctx 
ctx-words     .threadlist   .stacktrace   i7            i6 
i5            i4            i3            i2            i1 
i0            l7            l6            l5            l4 
l3            l2            l1            l0            i7x 
i6x           i5x           i4x           i3x           i2x 
i1x           i0x           l7x           l6x           l5x 
l4x           l3x           l2x           l1x           l0x 
v9bias        .lwp          .thread       ._kthread 
_kthread-words              .memlistlist  .memlist 
memlist-words ._klwp        _klwp-words   .mstate 
mstate-words  .k_siginfo    k_siginfo-words 
.kmem_cache   kmem_cache-words            .kmem_slab 
kmem_slab-words             .hment        hment-words   .hat 
hat-words     .dev_info     dev_info-words              .cred 
cred-words    .cpulist      .cpun         .cpu 
cpu-words     .callout      callout-words .buf 
buf-words     .as           as-words      .rwlock       .label 
.disp         .mutex        ._rwlock_impl _rwlock_impl-words 
._label_t 
_label_t-words              .itimerval    itimerval-words 
.timeval      timeval-words ._disp        _disp-words 
.adaptive_mutex             adaptive_mutex-words        .dev_t 
c-struct      bits-field    array-field   struct-field 
ptr-field     byte-field    short-field   long-field 
ext-field     voc-print     name-print    0plevel       -plevel 
+plevel       plevel        sizeof        index         print 
.str          .o            another?      next-word 

ok .threadlist
	( .threadlist prints threads 1 page at a time )
   thread e0402000  pc: e0094e98  sp: e0401aa8 
call e008b254  genunix:main     from e00069d8  _start+108 
 ( 0 2 3c 2 e0428290 e0411840 ) 
call e00531a0  krtld:exitto     from e0053e84  krtld:kobj_init+128 
 ( e00068d0 e0425400 e04604f0 e0425000 e005829c e0437800 ) 

   thread e0891ec0  free

   thread e0895ec0  free

   thread e0899ec0  free

   thread e089dec0  free

   thread e08a1ec0  free

   thread e08a5ec0  free

   thread e08a9ec0  free

   thread e08adec0  free

   thread e08b1ec0  free

   thread e08b9ec0  pc: e002ec3c  sp: e08b9e00 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( e0423c00 0 e0428290 e0428290 0 e0423c48 ) 
????  from e002ebfc  idle     
 ( 0 0 0 0 0 0 ) 

   thread e08bdec0  pc: e005dd9c  sp: e08bdda0 
call e005dd38  genunix:cv_wait     from e006bdd4  genunix:callout_thread+1c  
 ( e045d890 e045d890 80000000 e045da3c e045da3c e045da3c ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( 0 0 e0428290 e0428290 e045d8a4 e045d890 ) 
????  from e006bdb8  genunix:callout_thread     
 ( 0 0 0 0 0 0 ) 

   thread e08c1ec0  pc: e005dd9c  sp: e08c1da0 
call e005dd38  genunix:cv_wait     from e006bdd4  genunix:callout_thread+1c  
 ( e045d890 e045d890 80000000 e045db68 e045db68 e045db68 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( 0 0 e0428290 e0428290 e045d8a4 e045d890 ) 
????  from e006bdb8  genunix:callout_thread     
 ( 0 0 0 0 0 0 ) 
                        
   thread e08c5ec0  free

   thread e08cbec0  pc: e005dd9c  sp: e08cbd90 
call e005dd38  genunix:cv_wait     from e00b9c24  genunix:background+158 
 ( e046000c e046000c 0 10000 0 0 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( 0 fffffffe 10000 fc408734 0 e046000c ) 
????  from e00b9acc  genunix:background     
 ( 0 0 0 0 0 0 ) 

   thread e08d1ec0  pc: e005dd9c  sp: e08d1d90 
call e005dd38  genunix:cv_wait     from e00b9d8c  genunix:freebs+c8  
 ( e045f040 e045f040 2 e044dca0 2 0 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( e044dca8 e045fd1c e0428290 e045fe04 0 e045f040 ) 
????  from e00b9cc4  genunix:freebs     
 ( 0 0 0 0 0 0 ) 

   thread e08d7ec0  pc: e005dd9c  sp: e08d7d90 
call e005dd38  genunix:cv_wait     from e00bdb08  genunix:qwriter_outer_thread+c4  
 ( e045f078 e045f078 0 e044f4b8 e00080f0 fc14b580 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( e044f4bc 0 e045c2d8 0 e045f078 0 ) 
????  from e00bda44  genunix:qwriter_outer_thread     
 ( 0 0 0 0 0 0 ) 

   thread e08dbec0  pc: e005dd9c  sp: e08dbd40 
call e005dd38  genunix:cv_wait     from fc2620f4  ufs:ufs_thread_run+6c  
 ( fc13ca78 fc13ca78 0 456 0 fc14b5a8 ) 
call fc262088  ufs:ufs_thread_run     from fc262868  ufs:ufs_thread_idle+1c  
 ( fc13ca64 fffd fc13ca78 fc13ca68 fc13ca72 fc13ca70 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( 0 fc13ca64 fc13ca78 e0428290 0 0 ) 
????  from fc26284c  ufs:ufs_thread_idle     
 ( 0 0 7b60c 0 239b8 7b609 ) 

   thread e08dfec0  pc: e005dd9c  sp: e08dfd40 
call e005dd38  genunix:cv_wait     from fc2620f4  ufs:ufs_thread_run+6c  
 ( fc13caf0 fc13caf0 0 1 0 ffffffd8 ) 
call fc262088  ufs:ufs_thread_run     from fc262ccc  ufs:ufs_thread_hlock+20  
 ( fc13cadc fffd fc13caf0 fc13cae0 fc13caea fc13cae8 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( 0 0 fc13cadc fc13caea fc13caf0 0 ) 
????  from fc262cac  ufs:ufs_thread_hlock     
 ( 0 0 0 32540 16a09 0 ) 

   thread e08e3ec0  pc: e005dd9c  sp: e08e3d80 
call e005dd38  genunix:cv_wait     from fc30236c  esp:esp_callback+1e4 
 ( fc14b66c fc14b66c 2 19 fc14b674 0 ) 
jmpl  e00074b0  client_handler+38  from e001ef80  thread_start+4   
 ( 0 fc14b682 0 1 0 0 ) 
????  from fc302188  esp:esp_callback     
 ( fc17f008 0 78278 c3c09 0 78284 ) 

   thread fc44b480  pc: e005e4b0  sp: e0a1b7d0 
call e005e358  genunix:cv_wait_sig_swap     from e00b896c  genunix:strwaitq+280 
 ( 0 fc40b6e4 fc5eb028 0 fc44ee20 fc44b480 ) 
call e00b86ec  genunix:strwaitq     from e00b36d0  genunix:strgetmsg+2a8 
 ( fc40b698 fc408246 0 3 e0a1b9b0 fc408200 ) 
call e00b3428  genunix:strgetmsg     from e00a6508  genunix:msgio+254 
 ( 0 e0a1ba18 0 fc40b6a8 fc40b6e4 0 ) 
call e00a62b4  genunix:msgio     from e00a60d8  genunix:getmsg+88  
 ( e0a1ba90 e0a1bb10 1 e0a1baab e0a1baac fc3209dc ) 
jmpl  0 from e00656c8  genunix:syscall_ap+70  
 ( fc44ee88 e0a1bb10 0 0 e043e9c4 0 ) 
jmpl  ffbf0000 from e0025824  syscall_trap+194 
 ( 3 0 dffffd88 dffffd68 e00a6050 fc44ee20 ) 
XXXXXXX from df7876a4 
 ( 3 dffffd7c dffffd88 dffffd68 84 27b18 ) 

   thread fc44b5c0  pc: e005e4b0  sp: e0a17980 
call e005e358  genunix:cv_wait_sig_swap     from e00903e8  genunix:poll+cb8 
 ( 0 fc14a950 fc5eb698 800 fc44f008 fc44b5c0 ) 
	( at this point I got bored )
	( and printed a single thread )
ok fc44b480 .thread     
t_ts = NULL
t_prioinv = NULL
t_rprof = NULL
t_mstate = 9 
t_waitrq = 0 
t_kpri_req = 0 
t_disp_time = 14976 
t_disp_cpu = e0423c00 
t_oldspl = 0 
t_lockp = e045a310 
t_pctcpu = 10 
t_lbolt = 6ef 
t_cred = fc19ff90 
t_pollstate = NULL
t_sysnum = 85 
t_whatstop = 0 
t_whystop = 0 
t_trace = NULL
t_prev = e08e3ec0 
t_next = fc44b5c0 
t_procp = fc5eb028 
t_lwp = fc44ee20 
t_back = fc44b480       
t_forw = fc44b480 
t_sigqueue = NULL
t_itimerid = 0 
t_realitimer = 
        it_value = 
                tv_usec = 0 i = 110 
        disp_lock = 0 
cpu_prev_onln = e0423c00 
cpu_next_onln = e0423c00 
cpu_prev = e0423c00 
cpu_next = e0423c00     
cpu_fpowner = fc44fd60 
cpu_callo = NULL
cpu_lwp = NULL
cpu_pause_thread = e09fbec0 
cpu_idle_thread = e08b9ec0 
cpu_thread = e08b9ec0 
cpu_flags = 1b 
cpu_seqid = 0 
cpu_id = 0 
	( and here's the phys installed list )
ok :phys_install l@ .memlistlist
prev = NULL
next = fc004168 
size = 2000000 
address = 0 

prev = fc004150 
next = NULL
size = 2000000 
address = 10000000 


NOTE: note the . (period) in front of the name of the struct. You need to add
that to the name so that it does not clash with variables with same names.
