/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 */

/*	Copyright (c) 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*
 * A part of this file comes from public domain source, so
 * clarified as of June 5, 1996 by Arthur David Olson
 * (arthur_david_olson@nih.gov).
 */

/*
 * localtime.c
 *
 * This file contains routines to convert struct tm to time_t and
 * back as well as adjust time values based on their timezone, which
 * is a local offset from GMT (Greenwich Mean Time).
 *
 * Many timezones actually consist of more than one offset from GMT.
 * The GMT offset that is considered the normal offset is referred
 * to as standard time.  The other offset is referred to as alternate
 * time, but is better known as daylight savings time or summer time.
 *
 * The current timezone for an application is derived from the TZ
 * environment variable either as defined in the environment or in
 * /etc/default/init.  As defined by IEEE 1003.1-1990 (POSIX), the
 * TZ variable can either be:
 *    :<characters>
 * or
 *    <std><offset1>[<dst>[<offset2>]][,<start>[/<time>],<end>[/<time>]
 *
 * <characters> is an implementation-defined string that somehow describes
 * a timezone.  The implementation-defined description of a timezone used
 * in Solaris is based on the public domain zoneinfo code available from
 * elsie.nci.nih.gov and a timezone that is specified in this way is
 * referred to as a zoneinfo timezone.  An example of this is ":US/Pacific".
 *
 * The precise definition of the second format can be found in POSIX,
 * but, basically, <std> is the abbreviation for the timezone in standard
 * (not daylight savings time), <offset1> is the standard offset from GMT,
 * <dst> is the abbreviation for the timezone in daylight savings time and
 * <offset2> is the daylight savings time offset from GMT.  The remainder
 * specifies when daylight savings time begins and ends.  A timezone
 * specified in this way is referred to as a POSIX timezone.  An example
 * of this is "PST7PDT".
 *
 * In Solaris, there is an extension to this.  If the timezone is not
 * preceded by a ":" and it does not parse as a POSIX timezone, then it
 * will be treated as a zoneinfo timezone.  Much usage of zoneinfo
 * timezones in Solaris is done without the leading ":".
 *
 * A zoneinfo timezone is a reference to a file that contains a set of
 * rules that describe the timezone.  In Solaris, the file is in
 * /usr/share/lib/zoneinfo.  The file is generated by zic(1M), based
 * on zoneinfo rules "source" files.  This is all described on the zic(1M)
 * man page.
 */

/*
 * Functions that are common to ctime(3C) and cftime(3C)
 */

#pragma weak _tzset = tzset

#include "lint.h"
#include "libc.h"
#include "tsd.h"
#include <stdarg.h>
#include <mtlib.h>
#include <sys/types.h>
#include <ctype.h>
#include <stdio.h>
#include <limits.h>
#include <sys/param.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <tzfile.h>
#include <thread.h>
#include <synch.h>
#include <fcntl.h>
#include <errno.h>
#include <deflt.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/byteorder.h>
#include <paths.h>

/* JAN_01_1902 cast to (int) - negative number of seconds from 1970 */
#define	JAN_01_1902		(int)0x8017E880
#define	LEN_TZDIR		(sizeof (TZDIR) - 1)
#define	TIMEZONE		"/etc/default/init"
#define	TZSTRING		"TZ="
#define	HASHTABLE		31

#define	LEAPS_THRU_END_OF(y)	((y) / 4 - (y) / 100 + (y) / 400)

/* Days since 1/1/70 to 12/31/(1900 + Y - 1) */
#define	DAYS_SINCE_70(Y) (YR((Y)-1L) - YR(70-1))
#define	YR(X) /* Calc # days since 0 A.D. X = curr. yr - 1900 */ \
	((1900L + (X)) * 365L + (1900L + (X)) / 4L - \
	(1900L + (X)) / 100L + ((1900L + (X)) - 1600L) / 400L)

#define	YEARSPERREPEAT	400
#define	AVGSECSPERYEAR	31556952L

#ifndef	FALSE
#define	FALSE	(0)
#endif
#ifndef	TRUE
#define	TRUE	(1)
#endif

enum data_vers { V1, V2 };

#ifdef TIME64_TRANS
typedef	int64_t	timeINT_t;	/* 32bit time_t and enable localtime64 */
#else
typedef	time_t	timeINT_t;	/* 32bit or 64bit time_t */
#endif

#define	TZ_MAX_TIMES_V1	370	/* TZ_MAX_TIMES enough for V1 data */

extern	mutex_t		_time_lock;

extern const int	__lyday_to_month[];
extern const int	__yday_to_month[];
extern const int	__mon_lengths[2][MONS_PER_YEAR];
extern const int	__year_lengths[2];

const char	_tz_gmt[4] = "GMT";	/* "GMT"  */
const char	_tz_spaces[4] = "   ";	/* "   "  */
static const char	_posix_gmt0[5] = "GMT0";	/* "GMT0" */

typedef struct ttinfo {			/* Time type information */
	int32_t		tt_gmtoff;	/* GMT offset in seconds */
	int		tt_abbrind;	/* abbreviation list index */
	char		tt_isdst;	/* used to set tm_isdst */
	char		tt_ttisstd;	/* TRUE if trans is std time */
	char		tt_ttisgmt;	/* TRUE if transition is GMT */
} ttinfo_t;

typedef struct lsinfo {			/* Leap second information */
	timeINT_t	ls_trans;	/* transition time */
	int32_t		ls_corr;	/* correction to apply */
} lsinfo_t;

typedef struct previnfo {		/* Info about *prev* trans */
	ttinfo_t	*std;		/* Most recent std type */
	ttinfo_t	*alt;		/* Most recent alt type */
} prev_t;

typedef enum {
	MON_WEEK_DOW,		/* Mm.n.d - month, week, day of week */
	JULIAN_DAY,		/* Jn - Julian day */
	DAY_OF_YEAR		/* n - day of year */
} posrule_type_t;

typedef struct {
	posrule_type_t	r_type;		/* type of rule */
	int		r_day;		/* day number of rule */
	int		r_week;		/* week number of rule */
	int		r_mon;		/* month number of rule */
	long		r_time;		/* transition time of rule */
} rule_t;

typedef struct {
	rule_t		*rules[2];
	int32_t		offset[2];	/* GMT off */
	int64_t		rtime[2];
} posix_daylight_t;

/*
 * Note: ZONERULES_INVALID used for global curr_zonerules variable, but not
 * for zonerules field of state_t.
 */
typedef enum {
	ZONERULES_INVALID, POSIX, POSIX_USA, ZONEINFO
} zone_rules_t;

/*
 * The following members are allocated from the libc-internal malloc:
 *
 *	zonename
 *	chars
 */
typedef struct state {
	const char	*zonename;		/* Timezone */
	struct state	*next;			/* next state */
	zone_rules_t	zonerules;		/* Type of zone */
	char		daylight;		/* daylight global */
	char		goahead;		/* used in 64bit only */
	char		vers;			/* data version */
	char		max_vers;		/* zoneinfo version */
	long		default_timezone;	/* Def. timezone val */
	long		default_altzone;	/* Def. altzone val */
	const char	*default_tzname0;	/* Def tz..[0] val */
	const char	*default_tzname1;	/* Def tz..[1] val  */
	int		leapcnt;		/* # leap sec trans */
	int		timecnt;		/* # transitions */
	int		ftimecnt;		/* # transitions in file */
	int		typecnt;		/* # zone types */
	int		charcnt;		/* # zone abbv. chars */
	char		*chars;			/* Zone abbv. chars */
	size_t		charsbuf_size;		/* malloc'ed buflen */
	timeINT_t	*ats;			/* Trans.  times */
	prev_t		*prev;			/* Pv. trans info */
	uchar_t		*types;			/* Type indices */
	ttinfo_t	ttis[TZ_MAX_TYPES];	/* Zone types */
	lsinfo_t	lsis[TZ_MAX_LEAPS];	/* Leap sec trans */
	int		last_ats_idx;		/* last ats index */
	rule_t		start_rule;		/* For POSIX w/rules */
	rule_t		end_rule;		/* For POSIX w/rules */
	char		invalid;		/* state is invalid */
	char		pad[3];
	timestruc_t	mtime;			/* mtime of zoneinfo file */
} state_t;

#define	MAX_TIMES(v)	((v) == V1 ? TZ_MAX_TIMES_V1 : TZ_MAX_TIMES)
#define	STATE_SZ(v)	(sizeof (state_t) + \
			(sizeof (timeINT_t) * MAX_TIMES(v)) + \
			(sizeof (prev_t) * MAX_TIMES(v)) + \
			(sizeof (uchar_t) * MAX_TIMES(v)))

typedef struct tznmlist {
	struct tznmlist *link;
	char	name[1];
} tznmlist_t;

static const char	*systemTZ;
static tznmlist_t	*systemTZrec;

static const char	*namecache;

static state_t		*tzcache[HASHTABLE];

#define	TZNMC_SZ	43
static tznmlist_t	*tznmhash[TZNMC_SZ];
static const char	*last_tzname[2];

static state_t		*lclzonep;

static struct tm	tm;		/* For non-reentrant use */
static int		is_in_dst;	/* Set if t is in DST */
static zone_rules_t	curr_zonerules = ZONERULES_INVALID;
static int		cached_year;	/* mktime() perf. enhancement */
static int64_t		cached_secs_since_1970;	/* mktime() perf. */
static int		year_is_cached = FALSE;	/* mktime() perf. */

#define	TZSYNC_FILE	_PATH_SYSVOL "/tzsync"
static uint32_t		zoneinfo_seqno;
static uint32_t		zoneinfo_seqno_init = 1;
static uint32_t		*zoneinfo_seqadr = &zoneinfo_seqno_init;
#define	TZSYNC_READY()	(zoneinfo_seqadr != &zoneinfo_seqno_init)
#define	RELOAD_INFO()	(zoneinfo_seqno != *zoneinfo_seqadr)

#define	_2AM		(2 * SECS_PER_HOUR)
#define	FIRSTWEEK	1
#define	LASTWEEK	5

enum wks {
	_1st_week = 1,
	_2nd_week,
	_3rd_week,
	_4th_week,
	_Last_week
};

enum dwk {
	Sun, Mon, Tue, Wed, Thu, Fri, Sat
};

enum mth {
	Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
};

/*
 * The following table defines standard USA DST transitions
 * as they have been declared throughout history, disregarding
 * the legally sanctioned local variants.
 *
 * Note:  At some point, this table may be supplanted by
 * more popular 'posixrules' logic.
 */
typedef struct {
	int	s_year;
	int	e_year;
	rule_t	start;
	rule_t	end;
} __usa_rules_t;

static const __usa_rules_t	__usa_rules[] = {
	{
		2007, INT_MAX,
		{ MON_WEEK_DOW, Sun, _2nd_week, Mar, _2AM },
		{ MON_WEEK_DOW, Sun, _1st_week, Nov, _2AM },
	},
	{
		1987, 2006,
		{ MON_WEEK_DOW, Sun, _1st_week,  Apr, _2AM },
		{ MON_WEEK_DOW, Sun, _Last_week, Oct, _2AM },
	},
	{
		1976, 1986,
		{ MON_WEEK_DOW, Sun, _Last_week, Apr, _2AM },
		{ MON_WEEK_DOW, Sun, _Last_week, Oct, _2AM },
	},
	{
		1975, 1975,
		{ MON_WEEK_DOW, Sun, _Last_week, Feb, _2AM },
		{ MON_WEEK_DOW, Sun, _Last_week, Oct, _2AM },
	},

	{
		1974, 1974,
		{ MON_WEEK_DOW, Sun, _1st_week,  Jan, _2AM },
		{ MON_WEEK_DOW, Sun, _Last_week, Nov, _2AM },
	},
	/*
	 * The entry below combines two previously separate entries for
	 * 1969-1973 and 1902-1968
	 */
	{
		1902, 1973,
		{ MON_WEEK_DOW, Sun, _Last_week, Apr, _2AM },
		{ MON_WEEK_DOW, Sun, _Last_week, Oct, _2AM },
	}
};
#define	MAX_RULE_TABLE	(sizeof (__usa_rules) / sizeof (__usa_rules_t) - 1)

/*
 * Prototypes for static functions.
 */
static const char *getsystemTZ(void);
static const char *getzname(const char *, int);
static const char *getnum(const char *, int *, int, int);
static const char *getsecs(const char *, long *);
static const char *getoffset(const char *, long *);
static const char *getrule(const char *, rule_t *, int);
static int	load_posixinfo(const char *, state_t *);
static int	check_zoneinfo(state_t *);
static int	load_zoneinfo(const char *, state_t *);
static int	typesequiv(const state_t *sp, int, int);
static void	load_posix_transitions(state_t *, long, long, zone_rules_t);
static void	adjust_posix_default(state_t *, long, long);
static void	*ltzset_u(timeINT_t);
static struct tm *offtime_u(int64_t, long, struct tm *);
static int	posix_check_dst(int64_t, state_t *);
static int	posix_daylight(int64_t *, int, posix_daylight_t *);
static void	set_zone_context(timeINT_t);
static void	invalidate_cache(void);
static void	reload_counter(void);
static void	set_tzname(const char **);
static int32_t	decode32_slow(const char *);
static int64_t	decode64_slow(const char *);

#define	decode32(p)	((((uintptr_t)(p) & 3) == 0) ? \
		(int32_t)BE_32(*(int32_t *)(p)) : decode32_slow(p))
#define	decode64(p)	((((uintptr_t)(p) & 7) == 0) ? \
		(int64_t)BE_64(*(int64_t *)(p)) : decode64_slow(p))

#ifdef	_TZ_DEBUG
static void print_state(state_t *);
#endif

/*
 * definition of difftime
 *
 * This code assumes time_t is type long.  Note the difference of two
 * longs in absolute value is representable as an unsigned long.  So,
 * compute the absolute value of the difference, cast the result to
 * double and attach the sign back on.
 *
 * Note this code assumes 2's complement arithmetic.  The subtraction
 * operation may overflow when using signed operands, but when the
 * result is cast to unsigned long, it yields the desired value
 * (ie, the absolute value of the difference).  The cast to unsigned
 * long is done using pointers to avoid undefined behavior if casting
 * a negative value to unsigned.
 */
double
difftime(time_t time1, time_t time0)
{
	if (time1 < time0) {
		time0 -= time1;
		return (-(double)*(unsigned long *) &time0);
	} else {
		time1 -= time0;
		return ((double)*(unsigned long *) &time1);
	}
}

/*
 * Accepts a time_t, returns a tm struct based on it, with
 * no local timezone adjustment.
 *
 * This routine is the thread-safe variant of gmtime(), and
 * requires that the call provide the address of their own tm
 * struct.
 *
 * Locking is not done here because set_zone_context()
 * is not called, thus timezone, altzone, and tzname[] are not
 * accessed, no memory is allocated, and no common dynamic
 * data is accessed.
 *
 * See ctime(3C)
 */
struct tm *
gmtime_r(const time_t *timep, struct tm *p_tm)
{
	return (offtime_u(*timep, 0L, p_tm));
}

/*
 * Accepts a time_t, returns a tm struct based on it, with
 * no local timezone adjustment.
 *
 * This function is explicitly NOT THREAD-SAFE.  The standards
 * indicate it should provide its results in its own statically
 * allocated tm struct that gets overwritten. The thread-safe
 * variant is gmtime_r().  We make it mostly thread-safe by
 * allocating its buffer in thread-specific data.
 *
 * See ctime(3C)
 */
struct tm *
gmtime(const time_t *timep)
{
	struct tm *p_tm = tsdalloc(_T_STRUCT_TM, sizeof (struct tm), NULL);

	if (p_tm == NULL)	/* memory allocation failure */
		p_tm = &tm;	/* use static buffer and hope for the best */
	return (gmtime_r(timep, p_tm));
}

#ifdef TIME64_TRANS
struct tm *
__gmtime64(const timeINT_t *timep)
{
	struct tm *p_tm = tsdalloc(_T_STRUCT_TM, sizeof (struct tm), NULL);

	if (p_tm == NULL)	/* memory allocation failure */
		p_tm = &tm;	/* use static buffer and hope for the best */
	return (offtime_u(*timep, 0L, p_tm));
}
#endif

/*
 * This is the hashing function, based on the input timezone name.
 */
static int
get_hashid(const char *id)
{
	unsigned char	c;
	unsigned int	h;

	h = *id++;
	while ((c = *id++) != '\0')
		h += c;
	return ((int)(h % HASHTABLE));
}

/*
 * find_zone() gets the hashid for zonename, then uses the hashid
 * to search the hash table for the appropriate timezone entry.  If
 * the entry for zonename is found in the hash table, return a pointer
 * to the entry.
 */
static state_t *
find_zone(const char *zonename)
{
	int	hashid;
	state_t	*cur;

	hashid = get_hashid(zonename);
	cur = tzcache[hashid];
	while (cur) {
		int	res;
		res = strcmp(cur->zonename, zonename);
		if (res == 0) {
			return (cur);
		} else if (res > 0) {
			break;
		}
		cur = cur->next;
	}
	return (NULL);
}

/*
 * Register new state in the cache.
 */
static void
reg_zone(state_t *new)
{
	int	hashid, res;
	state_t	*cur, *prv;

	hashid = get_hashid(new->zonename);
	cur = tzcache[hashid];
	prv = NULL;
	while (cur != NULL) {
		res = strcmp(cur->zonename, new->zonename);
		if (res == 0) {
			/* shouldn't occur */
			return;
		} else if (res > 0) {
			break;
		}
		prv = cur;
		cur = cur->next;
	}
	if (prv != NULL) {
		new->next = prv->next;
		prv->next = new;
	} else {
		new->next = tzcache[hashid];
		tzcache[hashid] = new;
	}
}

/*
 * Remove one state in the cache.
 */
static void
unreg_zone(state_t *old)
{
	int	hashid;
	state_t	*cur, *prv = NULL;

	hashid = get_hashid(old->zonename);
	for (cur = tzcache[hashid]; cur != NULL; cur = cur->next) {
		if (cur == old)
			break;
		prv = cur;
	}
	if (cur == NULL) {
		/* shouldn't occur */
		return;
	}
	if (prv != NULL)
		prv->next = old->next;
	else
		tzcache[hashid] = old->next;

	/* last_tzname[] may point cache being freed */
	last_tzname[0] = NULL;
	last_tzname[1] = NULL;
}

/*
 * Returns tm struct based on input time_t argument, correcting
 * for the local timezone, producing documented side-effects
 * to extern global state, timezone, altzone, daylight and tzname[].
 *
 * localtime_r() is the thread-safe variant of localtime().
 *
 * IMPLEMENTATION NOTE:
 *
 *	Locking slows multithreaded access and is probably ultimately
 *	unnecessary here. The POSIX specification is a bit vague
 *	as to whether the extern variables set by tzset() need to
 *	set as a result of a call to localtime_r()
 *
 *	Currently, the spec only mentions that tzname[] doesn't
 *	need to be set.  As soon as it becomes unequivocal
 *	that the external zone state doesn't need to be asserted
 *	for this call, and it really doesn't make much sense
 *	to set common state from multi-threaded calls made to this
 *	function, locking can be dispensed with here.
 *
 *	local zone state would still need to be aquired for the
 *	time in question in order for calculations elicited here
 *	to be correct, but that state wouldn't need to be shared,
 *	thus no multi-threaded synchronization would be required.
 *
 *	It would be nice if POSIX would approve an ltzset_r()
 *	function, but if not, it wouldn't stop us from making one
 *	privately.
 *
 *	localtime_r() can now return NULL if overflow is detected.
 *	offtime_u() is the function that detects overflow, and sets
 *	errno appropriately.  We unlock before the call to offtime_u(),
 *	so that lmutex_unlock() does not reassign errno.  The function
 *	offtime_u() is MT-safe and does not have to be locked.  Use
 *	my_is_in_dst to reference local copy of is_in_dst outside locks.
 *
 * See ctime(3C)
 */
static struct tm *
localtime_int(timeINT_t t, struct tm *p_tm)
{
	long	offset;
	struct tm *rt;
	void	*unused;
	int	my_is_in_dst;

	lmutex_lock(&_time_lock);
	unused = ltzset_u(t);
	if (lclzonep == NULL) {
		lmutex_unlock(&_time_lock);
		if (unused != NULL)
			free(unused);
		return (offtime_u(t, 0L, p_tm));
	}
	my_is_in_dst = is_in_dst;
	offset = (my_is_in_dst) ? -altzone : -timezone;
	lmutex_unlock(&_time_lock);
	if (unused != NULL)
		free(unused);
	rt = offtime_u(t, offset, p_tm);
	p_tm->tm_isdst = my_is_in_dst;
	return (rt);
}

struct tm *
localtime_r(const time_t *timep, struct tm *p_tm)
{
	return (localtime_int(*timep, p_tm));
}

/*
 * Accepts a time_t, returns a tm struct based on it, correcting
 * for the local timezone.  Produces documented side-effects to
 * extern global timezone state data.
 *
 * This function is explicitly NOT THREAD-SAFE.  The standards
 * indicate it should provide its results in its own statically
 * allocated tm struct that gets overwritten. The thread-safe
 * variant is localtime_r().  We make it mostly thread-safe by
 * allocating its buffer in thread-specific data.
 *
 * localtime() can now return NULL if overflow is detected.
 * offtime_u() is the function that detects overflow, and sets
 * errno appropriately.
 *
 * See ctime(3C)
 */
struct tm *
localtime(const time_t *timep)
{
	struct tm *p_tm = tsdalloc(_T_STRUCT_TM, sizeof (struct tm), NULL);

	if (p_tm == NULL)	/* memory allocation failure */
		p_tm = &tm;	/* use static buffer and hope for the best */
	return (localtime_int(*timep, p_tm));
}

#ifdef TIME64_TRANS
/*
 * 64bit time_t version of localtime: Consolidation private
 */
struct tm *
__localtime64(const timeINT_t *timep)
{
	struct tm *p_tm = tsdalloc(_T_STRUCT_TM, sizeof (struct tm), NULL);

	if (p_tm == NULL)	/* memory allocation failure */
		p_tm = &tm;	/* use static buffer and hope for the best */
	return (localtime_int(*timep, p_tm));
}
#endif

/*
 * This function takes a pointer to a tm struct and returns a
 * normalized time_t, also inducing documented side-effects in
 * extern global zone state variables.  (See mktime(3C)).
 */
time_t
mktime(struct tm *tmptr)
{
	struct tm _tm;
	int64_t t;		/* must hold more than 32-bit time_t */
	int	temp;
	int	mketimerrno;
	int	overflow;
	void	*unused;

	mketimerrno = errno;

	/* mktime leaves errno unchanged if no error is encountered */

	/* Calculate time_t from tm arg.  tm may need to be normalized. */
	t = tmptr->tm_sec + SECSPERMIN * tmptr->tm_min +
	    SECSPERHOUR * tmptr->tm_hour +
	    SECSPERDAY * (tmptr->tm_mday - 1);

	if (tmptr->tm_mon >= 12) {
		tmptr->tm_year += tmptr->tm_mon / 12;
		tmptr->tm_mon %= 12;
	} else if (tmptr->tm_mon < 0) {
		temp = -tmptr->tm_mon;
		tmptr->tm_mon = 0;	/* If tm_mon divides by 12. */
		tmptr->tm_year -= (temp / 12);
		if (temp %= 12) {	/* Remainder... */
			tmptr->tm_year--;
			tmptr->tm_mon = 12 - temp;
		}
	}

	lmutex_lock(&_time_lock);

	/* Avoid numerous calculations embedded in macro if possible */
	if (!year_is_cached || (cached_year != tmptr->tm_year))	 {
		cached_year = tmptr->tm_year;
		year_is_cached = TRUE;
		/* For boundry values of tm_year, typecasting required */
		cached_secs_since_1970 =
		    (int64_t)SECSPERDAY * DAYS_SINCE_70(cached_year);
	}
	t += cached_secs_since_1970;

	if (isleap(tmptr->tm_year + TM_YEAR_BASE))
		t += SECSPERDAY * __lyday_to_month[tmptr->tm_mon];
	else
		t += SECSPERDAY * __yday_to_month[tmptr->tm_mon];

	unused = ltzset_u(t);

	/* Attempt to convert time to GMT based on tm_isdst setting */
	t += (tmptr->tm_isdst > 0) ? altzone : timezone;

#ifdef _ILP32
	overflow = t > LONG_MAX || t < LONG_MIN ||
	    tmptr->tm_year < 1 || tmptr->tm_year > 138;
#else
	overflow = t > LONG_MAX || t < LONG_MIN;
#endif
	set_zone_context(t);
	if (tmptr->tm_isdst < 0) {
		long dst_delta = timezone - altzone;
		switch (curr_zonerules) {
		case ZONEINFO:
			if (is_in_dst) {
				t -= dst_delta;
				set_zone_context(t);
				if (is_in_dst) {
					(void) offtime_u(t, -altzone, &_tm);
					_tm.tm_isdst = 1;
				} else {
					(void) offtime_u(t, -timezone, &_tm);
				}
			} else {
				(void) offtime_u(t, -timezone, &_tm);
			}
			break;
		case POSIX_USA:
		case POSIX:
			if (is_in_dst) {
				t -= dst_delta;
				set_zone_context(t);
				if (is_in_dst) {
					(void) offtime_u(t, -altzone, &_tm);
					_tm.tm_isdst = 1;
				} else {
					(void) offtime_u(t, -timezone, &_tm);
				}
			} else { /* check for ambiguous 'fallback' transition */
				set_zone_context(t - dst_delta);
				if (is_in_dst) {  /* In fallback, force DST */
					t -= dst_delta;
					(void) offtime_u(t, -altzone, &_tm);
					_tm.tm_isdst = 1;
				} else {
					(void) offtime_u(t, -timezone, &_tm);
				}
			}
			break;

		case ZONERULES_INVALID:
			(void) offtime_u(t, 0L, &_tm);
			break;

		}
	} else if (is_in_dst) {
		(void) offtime_u(t, -altzone, &_tm);
		_tm.tm_isdst = 1;
	} else {
		(void) offtime_u(t, -timezone, &_tm);
	}

	if (overflow || t > LONG_MAX || t < LONG_MIN) {
		mketimerrno = EOVERFLOW;
		t = -1;
	} else {
		*tmptr = _tm;
	}

	lmutex_unlock(&_time_lock);
	if (unused != NULL)
		free(unused);

	errno = mketimerrno;
	return ((time_t)t);
}

/*
 * Sets extern global zone state variables based on the current
 * time.  Specifically, tzname[], timezone, altzone, and daylight
 * are updated.  See ctime(3C) manpage.
 */
void
tzset(void)
{
	void	*unused;

	lmutex_lock(&_time_lock);
	unused = ltzset_u(time(NULL));
	lmutex_unlock(&_time_lock);
	if (unused != NULL)
		free(unused);
}

void
_ltzset(time_t tim)
{
	void	*unused;

	lmutex_lock(&_time_lock);
	unused = ltzset_u(tim);
	lmutex_unlock(&_time_lock);
	if (unused != NULL)
		free(unused);
}

/*
 * Perform initial setup of state_t
 */
static int
init_state(state_t *entry, const char *zonename, int vers)
{
	char	*newzonename, *charsbuf;

	entry->zonename = NULL;
	entry->chars = NULL;

	if ((newzonename = libc_strdup(zonename)) == NULL)
		return (-1);
	if ((charsbuf = libc_malloc(TZ_MAX_CHARS)) == NULL) {
		libc_free(newzonename);
		return (-1);
	}

	entry->vers = vers;
	entry->max_vers = V2;

	entry->ats = (timeINT_t *)(entry + 1);
	entry->prev = (prev_t *)(entry->ats + MAX_TIMES(vers));
	entry->types = (uchar_t *)(entry->prev + MAX_TIMES(vers));

	entry->zonerules = ZONERULES_INVALID;
	entry->charsbuf_size = TZ_MAX_CHARS;
	entry->chars = charsbuf;
	entry->default_tzname0 = _tz_gmt;
	entry->default_tzname1 = _tz_spaces;
	entry->zonename = newzonename;
	entry->last_ats_idx = -1;

	entry->invalid = !TZSYNC_READY();

	return (0);
}

static void
fini_state(state_t *entry)
{
	libc_free((char *)entry->zonename);
	libc_free((char *)entry->chars);

	/* last_tzname[] may point cache being freed */
	last_tzname[0] = NULL;
	last_tzname[1] = NULL;
}

/*
 * Loads local zone information if TZ changed since last time zone
 * information was loaded, or if this is the first time thru.
 * We already hold _time_lock; no further locking is required.
 * Return a memory block which can be free'd at safe place.
 */
static void *
ltzset_u(timeINT_t t)
{
	const char	*zonename;
	state_t		*entry, *new_entry, *unused_entry;
	const char	*newtzname[2];
	int		vers;

	if (RELOAD_INFO()) {
		reload_counter();
		invalidate_cache();
	}

	if ((zonename = getsystemTZ()) == NULL || *zonename == '\0')
		zonename = _posix_gmt0;

#ifdef _ILP32
	vers = V1;	/* 32bit cannot handle V2 data */
#else
	vers = V2;	/* always attempt to load V2 */
#endif
#ifdef TIME64_TRANS
	if (namecache != NULL && strcmp(namecache, zonename) == 0 &&
	    (lclzonep->vers >= vers || lclzonep->vers == lclzonep->max_vers))
#else
	if (namecache != NULL && strcmp(namecache, zonename) == 0)
#endif
	{
		set_zone_context(t);
		return (NULL);
	}

	unused_entry = new_entry = NULL;

	entry = find_zone(zonename);

	if (entry != NULL && entry->invalid) {
		if (entry->zonerules == ZONEINFO && check_zoneinfo(entry)) {
			/*
			 * zoneinfo file has been updated.
			 */
			unreg_zone(entry);
			fini_state(entry);
			new_entry = entry;
			entry = NULL;
		} else {
			entry->invalid = 0;
		}
	}

	if (entry == NULL) {
		/*
		 * We need to release _time_lock to call out malloc().
		 * We can release _time_lock as far as global variables
		 * can remain consistent. Here, we haven't touch any
		 * variables, so it's okay to release lock.
		 */
		lmutex_unlock(&_time_lock);
		new_entry = realloc(new_entry, STATE_SZ(vers));
		lmutex_lock(&_time_lock);

		/*
		 * check it again, since zone may have been loaded while
		 * time_lock was unlocked.
		 */
		entry = find_zone(zonename);
	}

#ifdef TIME64_TRANS
	if (entry != NULL &&
	    entry->zonerules == ZONEINFO &&
	    entry->vers < vers && entry->vers < entry->max_vers) {
		/*
		 * We have zoeinfo data, but it's not suitable for date
		 * beyond 2038. So we'll load V2.
		 */
		unreg_zone(entry);
		fini_state(entry);

		lmutex_unlock(&_time_lock);
		if (new_entry != NULL)
			free(new_entry);
		new_entry = realloc(entry, STATE_SZ(vers));
		lmutex_lock(&_time_lock);

		entry = NULL;

		if (new_entry != NULL) {
			/*
			 * If someone has allocated the entry while
			 * lock was released and if it's still lower
			 * version, discard it and use new one.
			 */
			entry = find_zone(zonename);
			if (entry != NULL) {
				if (entry->vers < vers) {
					unreg_zone(entry);
					fini_state(entry);
					unused_entry = entry;
					entry = NULL;
				} else {
					unused_entry = new_entry;
				}
			}
		}
	}
#else
	if (entry != NULL)
		unused_entry = new_entry;
#endif

	/*
	 * We are here because the 1st attemp failed.
	 * new_entry points newly allocated entry. If it was NULL, it
	 * indicates that the memory allocation also failed.
	 */
	if (entry == NULL) {
		/*
		 * 2nd attemp also failed.
		 * No timezone entry found in hash table, so load it,
		 * and create a new timezone entry.
		 */
		daylight = 0;
		entry = new_entry;

		if (entry == NULL || init_state(entry, zonename, vers) < 0) {
			/*
			 * something wrong happened.
			 * Invalidate the current timezone
			 */
			curr_zonerules = ZONERULES_INVALID;
			namecache = NULL;

			timezone = altzone = 0;
			is_in_dst = 0;
			newtzname[0] = (char *)_tz_gmt;
			newtzname[1] = (char *)_tz_spaces;
			set_tzname(newtzname);
			return (entry);
		}

		/*
		 * Builds transition cache and sets up zone state data for zone
		 * specified in TZ, which can be specified as a POSIX zone or an
		 * Olson zoneinfo file reference.
		 *
		 * If local data cannot be parsed or loaded, the local zone
		 * tables are set up for GMT.
		 *
		 * Unless a leading ':' is prepended to TZ, TZ is initially
		 * parsed as a POSIX zone;  failing that, it reverts to
		 * a zoneinfo check.
		 * However, if a ':' is prepended, the zone will *only* be
		 * parsed as zoneinfo.  If any failure occurs parsing or
		 * loading a zoneinfo TZ, GMT data is loaded for the local zone.
		 *
		 * Example:  There is a zoneinfo file in the standard
		 * distribution called 'PST8PDT'.  The only way the user can
		 * specify that file under Solaris is to set TZ to ":PST8PDT".
		 * Otherwise the initial parse of PST8PDT as a POSIX zone will
		 * succeed and be used.
		 */
		if (*zonename == ':') {
			if (load_zoneinfo(zonename + 1, entry) != 0) {
				(void) load_posixinfo(_posix_gmt0, entry);
			}
		} else if (load_posixinfo(zonename, entry) != 0) {
			if (load_zoneinfo(zonename, entry) != 0) {
				(void) load_posixinfo(_posix_gmt0, entry);
			}
		}
		reg_zone(entry);
	}

	curr_zonerules = entry->zonerules;
	namecache = entry->zonename;
	daylight = entry->daylight;
	lclzonep = entry;

	set_zone_context(t);

	/*
	 * We shouldn't release lock beyond this point since lclzonep
	 * can refer to invalid address if cache is invalidated.
	 * We defer the call to free till it can be done safely.
	 */
	return (unused_entry);
}

/*
 * Sets timezone, altzone, tzname[], extern globals, to represent
 * disposition of t with respect to TZ; See ctime(3C). is_in_dst,
 * internal global is also set.  daylight is set at zone load time.
 *
 * Issues:
 *
 *	In this function, any time_t not located in the cache is handled
 *	as a miss.  To build/update transition cache, load_zoneinfo()
 *	must be called prior to this routine.
 *
 *	If POSIX zone, cache miss penalty is slightly degraded
 *	performance.  For zoneinfo, penalty is decreased is_in_dst
 *	accuracy.
 *
 *	POSIX, despite its chicken/egg problem, ie. not knowing DST
 *	until time known, and not knowing time until DST known, at
 *	least uses the same algorithm for 64-bit time as 32-bit.
 *
 *	The fact that zoneinfo files only contain transistions for 32-bit
 *	time space is a well known problem, as yet unresolved.
 *	Without an official standard for coping with out-of-range
 *	zoneinfo times,  assumptions must be made.  For now
 *	the assumption is:   If t exceeds 32-bit boundries and local zone
 *	is zoneinfo type, is_in_dst is set to to 0 for negative values
 *	of t, and set to the same DST state as the highest ordered
 * 	transition in cache for positive values of t.
 */
static void
set_zone_default_context(void)
{
	const char	*newtzname[2];

	/* Retrieve suitable defaults for this zone */
	altzone = lclzonep->default_altzone;
	timezone = lclzonep->default_timezone;
	newtzname[0] = (char *)lclzonep->default_tzname0;
	newtzname[1] = (char *)lclzonep->default_tzname1;
	is_in_dst = 0;

	set_tzname(newtzname);
}

static void
set_zone_context(timeINT_t t)
{
	prev_t		*prevp;
	int    		lo, hi, tidx, lidx;
	ttinfo_t	*ttisp, *std, *alt;
	const char	*newtzname[2];

	/* If state data not loaded or TZ busted, just use GMT */
	if (lclzonep == NULL || curr_zonerules == ZONERULES_INVALID) {
		timezone = altzone = 0;
		daylight = is_in_dst = 0;
		newtzname[0] = (char *)_tz_gmt;
		newtzname[1] = (char *)_tz_spaces;
		set_tzname(newtzname);
		return;
	}

	if (lclzonep->timecnt <= 0 || lclzonep->typecnt < 2) {
		/* Loaded zone incapable of transitioning. */
		set_zone_default_context();
		return;
	}

	/*
	 * At least one alt. zone and one transistion exist. Locate
	 * state for 't' quickly as possible.  Use defaults as necessary.
	 */
	lo = 0;
	hi = lclzonep->timecnt - 1;

	if (t < lclzonep->ats[0] || t >= lclzonep->ats[hi]) {
		/*
		 * Date which is out of definition.
		 * Calculate DST as best as possible
		 */
		if (lclzonep->zonerules == POSIX_USA ||
		    lclzonep->zonerules == POSIX) {
			/* Must invoke calculations to determine DST */
			set_zone_default_context();
			is_in_dst = (daylight) ?
			    posix_check_dst(t, lclzonep) : 0;
			return;
		} else if (t < lclzonep->ats[0]) {   /* zoneinfo... */
			/* t precedes 1st transition.  Use defaults */
			set_zone_default_context();
			return;
		} else	if (lclzonep->goahead) {    /* zoneinfo */
			timeINT_t	newt, seconds;
			int64_t		icycles;

			seconds = t - lclzonep->ats[hi] - 1;
			icycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR + 1;
			seconds = icycles * YEARSPERREPEAT * AVGSECSPERYEAR;
			newt = t - seconds;
			/*
			 * If we would use same POSIX rule beyond the last
			 * transition, it's a go. Otherwise, use the final
			 * transition.
			 */
			if (newt > lclzonep->ats[lclzonep->ftimecnt - 1]) {
				set_zone_context(newt);
				return;
			}
			tidx = hi;
		} else {
			/* t follows final transistion.  Use final */
			tidx = hi;
		}
	} else {
		if ((lidx = lclzonep->last_ats_idx) != -1 &&
		    lidx != hi &&
		    t >= lclzonep->ats[lidx] &&
		    t < lclzonep->ats[lidx + 1]) {
			/* CACHE HIT. Nothing needs to be done */
			tidx = lidx;
		} else {
			/*
			 * CACHE MISS.  Locate transition using binary search.
			 */
			while (lo <= hi) {
				tidx = (lo + hi) / 2;
				if (t == lclzonep->ats[tidx])
					break;
				else if (t < lclzonep->ats[tidx])
					hi = tidx - 1;
				else
					lo = tidx + 1;
			}
			if (lo > hi)
				tidx = hi;
		}
	}
out:
	/*
	 * Set extern globals based on located transition and summary of
	 * its previous state, which were cached when zone was loaded
	 */
	ttisp = &lclzonep->ttis[lclzonep->types[tidx]];
	prevp = &lclzonep->prev[tidx];

	if ((is_in_dst = ttisp->tt_isdst) == 0) { /* std. time */
		timezone = -ttisp->tt_gmtoff;
		newtzname[0] = &lclzonep->chars[ttisp->tt_abbrind];
		if ((alt = prevp->alt) != NULL) {
			altzone = -alt->tt_gmtoff;
			newtzname[1] = &lclzonep->chars[alt->tt_abbrind];
		} else {
			altzone = lclzonep->default_altzone;
			newtzname[1] = (char *)lclzonep->default_tzname1;
		}
	} else { /* alt. time */
		altzone = -ttisp->tt_gmtoff;
		newtzname[1] = &lclzonep->chars[ttisp->tt_abbrind];
		if ((std = prevp->std) != NULL) {
			timezone = -std->tt_gmtoff;
			newtzname[0] = &lclzonep->chars[std->tt_abbrind];
		} else {
			timezone = lclzonep->default_timezone;
			newtzname[0] = (char *)lclzonep->default_tzname0;
		}
	}

	lclzonep->last_ats_idx = tidx;
	set_tzname(newtzname);
}

/*
 * This function takes a time_t and gmt offset and produces a
 * tm struct based on specified time.
 *
 * The the following fields are calculated, based entirely
 * on the offset-adjusted value of t:
 *
 * tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec
 * tm_yday. tm_wday.  (tm_isdst is ALWAYS set to 0).
 */

static struct tm *
offtime_u(int64_t t, long offset, struct tm *tmptr)
{
	long		days;
	long		rem;
	long		y;
	int		yleap;
	const int	*ip;

	days = t / SECSPERDAY;
	rem = t % SECSPERDAY;
	rem += offset;
	while (rem < 0) {
		rem += SECSPERDAY;
		--days;
	}
	while (rem >= SECSPERDAY) {
		rem -= SECSPERDAY;
		++days;
	}
	tmptr->tm_hour = (int)(rem / SECSPERHOUR);
	rem = rem % SECSPERHOUR;
	tmptr->tm_min = (int)(rem / SECSPERMIN);
	tmptr->tm_sec = (int)(rem % SECSPERMIN);

	tmptr->tm_wday = (int)((EPOCH_WDAY + days) % DAYSPERWEEK);
	if (tmptr->tm_wday < 0)
		tmptr->tm_wday += DAYSPERWEEK;
	y = EPOCH_YEAR;
	while (days < 0 || days >= (long)__year_lengths[yleap = isleap(y)]) {
		long newy;

		newy = y + days / DAYSPERNYEAR;
		if (days < 0)
			--newy;
		days -= ((long)newy - (long)y) * DAYSPERNYEAR +
		    LEAPS_THRU_END_OF(newy > 0 ? newy - 1L : newy) -
		    LEAPS_THRU_END_OF(y > 0 ? y - 1L : y);
		y = newy;
	}
	tmptr->tm_year = (int)(y - TM_YEAR_BASE);
	tmptr->tm_yday = (int)days;
	ip = __mon_lengths[yleap];
	for (tmptr->tm_mon = 0; days >=
	    (long)ip[tmptr->tm_mon]; ++(tmptr->tm_mon)) {
		days = days - (long)ip[tmptr->tm_mon];
	}
	tmptr->tm_mday = (int)(days + 1);
	tmptr->tm_isdst = 0;

#ifdef _LP64
	/* do as much as possible before checking for error. */
	if ((y > (long)INT_MAX + TM_YEAR_BASE) ||
	    (y < (long)INT_MIN + TM_YEAR_BASE)) {
		errno = EOVERFLOW;
		return (NULL);
	}
#endif
	return (tmptr);
}

/*
 * Check whether DST is set for time in question.  Only applies to
 * POSIX timezones.  If explicit POSIX transition rules were provided
 * for the current zone, use those, otherwise use default USA POSIX
 * transitions.
 */
static int
posix_check_dst(int64_t t, state_t *sp)
{
	struct tm	gmttm;
	int64_t		jan01;
	int		year, i, idx, ridx;
	posix_daylight_t	pdaylight;

	(void) offtime_u(t, 0L, &gmttm);

	year = gmttm.tm_year + 1900;
	jan01 = t - ((gmttm.tm_yday * SECSPERDAY) +
	    (gmttm.tm_hour * SECSPERHOUR) +
	    (gmttm.tm_min * SECSPERMIN) + gmttm.tm_sec);
	/*
	 * If transition rules were provided for this zone,
	 * use them, otherwise, default to USA daylight rules,
	 * which are historically correct for the continental USA,
	 * excluding local provisions.  (This logic may be replaced
	 * at some point in the future with "posixrules" to offer
	 * more flexibility to the system administrator).
	 */
	if (sp->zonerules == POSIX)	 {	/* POSIX rules */
		pdaylight.rules[0] = &sp->start_rule;
		pdaylight.rules[1] = &sp->end_rule;
	} else { 			/* POSIX_USA: USA */
		i = 0;
		while (year < __usa_rules[i].s_year && i < MAX_RULE_TABLE) {
			i++;
		}
		pdaylight.rules[0] = (rule_t *)&__usa_rules[i].start;
		pdaylight.rules[1] = (rule_t *)&__usa_rules[i].end;
	}
	pdaylight.offset[0] = timezone;
	pdaylight.offset[1] = altzone;

	idx = posix_daylight(&jan01, year, &pdaylight);
	ridx = !idx;

	/*
	 * Note:  t, rtime[0], and rtime[1] are all bounded within 'year'
	 * beginning on 'jan01'
	 */
	if (t >= pdaylight.rtime[idx] && t < pdaylight.rtime[ridx]) {
		return (ridx);
	} else {
		return (idx);
	}
}

/*
 * Given January 1, 00:00:00 GMT for a year as an Epoch-relative time,
 * along with the integer year #, a posix_daylight_t that is composed
 * of two rules, and two GMT offsets (timezone and altzone), calculate
 * the two Epoch-relative times the two rules take effect, and return
 * them in the two rtime fields of the posix_daylight_t structure.
 * Also update janfirst by a year, by adding the appropriate number of
 * seconds depending on whether the year is a leap year or not.  (We take
 * advantage that this routine knows the leap year status.)
 */
static int
posix_daylight(int64_t *janfirst, int year, posix_daylight_t *pdaylightp)
{
	rule_t	*rulep;
	long	offset;
	int	idx;
	int	i, d, m1, yy0, yy1, yy2, dow;
	long	leapyear;
	int64_t	value;

	static const int	__secs_year_lengths[2] = {
		DAYS_PER_NYEAR * SECSPERDAY,
		DAYS_PER_LYEAR * SECSPERDAY
	};

	leapyear = isleap(year);

	for (idx = 0; idx < 2; idx++) {
		rulep = pdaylightp->rules[idx];
		offset = pdaylightp->offset[idx];

		switch (rulep->r_type) {

		case MON_WEEK_DOW:
			/*
			 * Mm.n.d - nth "dth day" of month m.
			 */
			value = *janfirst;
			for (i = 0; i < rulep->r_mon - 1; ++i)
				value += __mon_lengths[leapyear][i] *
				    SECSPERDAY;

			/*
			 * Use Zeller's Congruence to get day-of-week of first
			 * day of month.
			 */
			m1 = (rulep->r_mon + 9) % 12 + 1;
			yy0 = (rulep->r_mon <= 2) ? (year - 1) : year;
			yy1 = yy0 / 100;
			yy2 = yy0 % 100;
			dow = ((26 * m1 - 2) / 10 +
			    1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;

			if (dow < 0)
				dow += DAYSPERWEEK;

			/*
			 * Following heuristic increases accuracy of USA rules
			 * for negative years.
			 */
			if (year < 1 && leapyear)
				++dow;
			/*
			 * "dow" is the day-of-week of the first day of the
			 * month.  Get the day-of-month, zero-origin, of the
			 * first "dow" day of the month.
			 */
			d = rulep->r_day - dow;
			if (d < 0)
				d += DAYSPERWEEK;
			for (i = 1; i < rulep->r_week; ++i) {
				if (d + DAYSPERWEEK >=
				    __mon_lengths[leapyear][rulep->r_mon - 1])
					break;
				d += DAYSPERWEEK;
			}
			/*
			 * "d" is the day-of-month, zero-origin, of the day
			 * we want.
			 */
			value += d * SECSPERDAY;
			break;

		case JULIAN_DAY:
			/*
			 * Jn - Julian day, 1 == Jan 1, 60 == March 1 even
			 * in leap yrs.
			 */
			value = *janfirst + (rulep->r_day - 1) * SECSPERDAY;
			if (leapyear && rulep->r_day >= 60)
				value += SECSPERDAY;
			break;

		case DAY_OF_YEAR:
			/*
			 * n - day of year.
			 */
			value = *janfirst + rulep->r_day * SECSPERDAY;
			break;
		}
		pdaylightp->rtime[idx] = value + rulep->r_time + offset;
	}
	*janfirst += __secs_year_lengths[leapyear];

	return ((pdaylightp->rtime[0] > pdaylightp->rtime[1]) ? 1 : 0);
}

static int
open_zoneinfo(const char *name, struct stat64 *stp, int stat_only)
{
	int	fd, namelen;
	char	*fullname;

	if (name == NULL && (name = TZDEFAULT) == NULL)
		return (-1);

	if ((name[0] == '/') || strstr(name, "../"))
		return (-1);

	namelen = LEN_TZDIR + 1 + strlen(name) + 1;
	if ((fullname = lmalloc(namelen)) == NULL)
		return (-1);

	(void) strcpy(fullname, TZDIR "/");
	(void) strcpy(fullname + LEN_TZDIR + 1, name);

	if (stat_only) {
		if (stat64(fullname, stp) == -1) {
			lfree(fullname, namelen);
			return (-1);
		}
		fd = 0;
	} else {
		if ((fd = open(fullname, O_RDONLY)) == -1) {
			lfree(fullname, namelen);
			return (-1);
		}
		if (fstat64(fd, stp) == -1) {
			lfree(fullname, namelen);
			(void) close(fd);
			return (-1);
		}
	}
	lfree(fullname, namelen);

	return (fd);
}

/*
 * Check to see if the zoneinfo database has been updated.
 */
static int
check_zoneinfo(state_t *sp)
{
	struct stat64 st;

	if (open_zoneinfo(sp->zonename, &st, 1) < 0)
		return (1);

	if (sp->mtime.tv_sec != st.st_mtim.tv_sec ||
	    sp->mtime.tv_nsec != st.st_mtim.tv_nsec) {
		return (1);
	}
	return (0);
}

static int
load_zoneinfo_header(state_t *sp, struct tzhead *tzhp,
	int vers, int *gmtcntp, int *stdcntp)
{
	int	ttisstdcnt, ttisgmtcnt;
	int	tz_max_times;
	int	dsz, width;

	/*LINTED align*/
	ttisgmtcnt = decode32(tzhp->tzh_ttisgmtcnt);
	/*LINTED align*/
	ttisstdcnt = decode32(tzhp->tzh_ttisstdcnt);
	/*LINTED align*/
	sp->leapcnt = decode32(tzhp->tzh_leapcnt);
	/*LINTED align*/
	sp->timecnt = decode32(tzhp->tzh_timecnt);
	/*LINTED align*/
	sp->typecnt = decode32(tzhp->tzh_typecnt);
	/*LINTED align*/
	sp->charcnt = decode32(tzhp->tzh_charcnt);
	sp->ftimecnt = sp->timecnt;

	width = (vers == V1) ? 4 : 8;
	tz_max_times = MAX_TIMES(vers);

	if (sp->leapcnt < 0 || sp->leapcnt > TZ_MAX_LEAPS ||
	    sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
	    sp->timecnt < 0 || sp->timecnt > tz_max_times ||
	    sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
	    (ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
	    (ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0)) {
		return (-1);
	}
	dsz = sp->timecnt * width +		/* ats */
	    sp->timecnt +			/* types */
	    sp->typecnt * (4 + 2) +		/* ttinfos */
	    sp->charcnt +			/* chars */
	    sp->leapcnt * (width + 4) +		/* lsinfos */
	    ttisstdcnt +			/* ttisstds */
	    ttisgmtcnt;				/* ttisgmts */

	*gmtcntp = ttisgmtcnt;
	*stdcntp = ttisstdcnt;

	return (dsz);
}

/*
 * Try to load zoneinfo file into internal transition tables using name
 * indicated in TZ, and do validity checks.  The format of zic(1M)
 * compiled zoneinfo files isdescribed in tzfile.h
 */
static int
load_zoneinfo(const char *name, state_t *sp)
{
	char	*cp, *cp2;
	int	i, nread, dsz;
	int	fid;
	int	ttisstdcnt, ttisgmtcnt;
	char	*bufp;
	size_t	flen, hsz;
	prev_t	*prevp;
	struct	tzhead *tzhp;
	struct	stat64	stbuf;
	ttinfo_t	*most_recent_alt = NULL;
	ttinfo_t	*most_recent_std = NULL;
	ttinfo_t	*ttisp;

	if ((fid = open_zoneinfo(name, &stbuf, 0)) == -1)
		return (-1);

	flen = (size_t)stbuf.st_size;
	if (flen < sizeof (struct tzhead)) {
		(void) close(fid);
		return (-1);
	}

	/*
	 * It would be nice to use alloca() to allocate bufp but,
	 * as above, we wish to avoid allocating a big buffer in
	 * our stack frame, and also because alloca() gives us no
	 * opportunity to fail gracefully on allocation failure.
	 */
	cp = bufp = lmalloc(flen);
	if (bufp == NULL) {
		(void) close(fid);
		return (-1);
	}
	if ((nread = read(fid, bufp, flen)) != flen) {
		lfree(bufp, flen);
		(void) close(fid);
		return (-1);
	}
	if (close(fid) != 0) {
		lfree(bufp, flen);
		return (-1);
	}
	if (nread < sizeof (struct tzhead)) {
		lfree(bufp, flen);
		return (-1);
	}

	tzhp = (struct tzhead *)cp;

	hsz = (uintptr_t)tzhp->tzh_charcnt + sizeof (tzhp->tzh_charcnt)
	    - (uintptr_t)tzhp;

	sp->max_vers = (tzhp->tzh_version[0] == '\0') ? V1 : V2;

	/* check version */
	if (sp->vers > sp->max_vers)
		sp->vers = sp->max_vers;

	/* read the first header */
	if ((dsz = load_zoneinfo_header(sp, tzhp, V1,
	    &ttisgmtcnt, &ttisstdcnt)) < 0) {
		lfree(bufp, flen);
		return (-1);
	}

	/*
	 * If we are fine with V1 data, just read it. Otherwise, go ahead
	 * and read the V2 data.
	 */
	if (sp->vers == V1) {
		if ((nread - hsz) < dsz) {
			lfree(bufp, flen);
			return (-1);
		}
		cp = bufp + hsz;

		for (i = 0; i < sp->timecnt; ++i) {
			/*LINTED align*/
			sp->ats[i] = decode32(cp);
			cp += 4;
		}
	} else {
		tzhp = (struct tzhead *)(cp + hsz + dsz);

		if ((dsz = load_zoneinfo_header(sp, tzhp, V2,
		    &ttisgmtcnt, &ttisstdcnt)) < 0) {
			lfree(bufp, flen);
			return (-1);
		}

		if (((uintptr_t)bufp + nread - (uintptr_t)tzhp) < dsz) {
			lfree(bufp, flen);
			return (-1);
		}
		cp = (char *)tzhp + hsz;

		for (i = 0; i < sp->timecnt; ++i) {
			/*LINTED align*/
			sp->ats[i] = decode64(cp);
			cp += 8;
		}
	}

	/*
	 * Skip over types[] for now and load ttis[] so that when
	 * types[] are loaded we can check for transitions to STD & DST.
	 * This allows us to shave cycles in ltzset_u(), including
	 * eliminating the need to check set 'daylight' later.
	 */
	cp2 = cp + sp->timecnt;

	for (i = 0; i < sp->typecnt; ++i) {
		ttisp = &sp->ttis[i];
		/*LINTED align*/
		ttisp->tt_gmtoff = decode32(cp2);
		cp2 += 4;
		ttisp->tt_isdst = (uchar_t)*cp2++;

		if (ttisp->tt_isdst != 0 && ttisp->tt_isdst != 1) {
			lfree(bufp, flen);
			return (-1);
		}

		ttisp->tt_abbrind = (uchar_t)*cp2++;
		if (ttisp->tt_abbrind < 0 ||
		    ttisp->tt_abbrind > sp->charcnt) {
			lfree(bufp, flen);
			return (-1);
		}
	}

	/*
	 * Since ttis were loaded ahead of types, it is possible to
	 * detect whether daylight is ever set for this zone now, and
	 * also preload other information to avoid repeated lookups later.
	 * This logic facilitates keeping a running tab on the state of
	 * std zone and alternate zone transitions such that timezone,
	 * altzone and tzname[] can be determined quickly via an
	 * index to any transition.
	 *
	 * For transition #0 there are no previous transitions,
	 * so prev->std and prev->alt will be null, but that's OK,
	 * because null prev->std/prev->alt effectively
	 * indicates none existed prior.
	 */
	prevp = &sp->prev[0];

	for (i = 0; i < sp->timecnt; ++i) {

		sp->types[i] = (uchar_t)*cp++;
		ttisp = &sp->ttis[sp->types[i]];

		prevp->std = most_recent_std;
		prevp->alt = most_recent_alt;

		if (ttisp->tt_isdst == 1)
			most_recent_alt = ttisp;
		else
			most_recent_std = ttisp;

		if ((int)sp->types[i] >= sp->typecnt) {
			lfree(bufp, flen);
			return (-1);
		}

		++prevp;
	}
	/*
	 * Set pointer ahead to where it would have been if we
	 * had read types[] and ttis[] in the same order they
	 * occurred in the file.
	 */
	cp = cp2;
	for (i = 0; i < sp->charcnt; ++i)
		sp->chars[i] = *cp++;

	sp->chars[i] = '\0';	/* ensure '\0' at end */

	for (i = 0; i < sp->leapcnt; ++i) {
		struct lsinfo *lsisp;

		lsisp = &sp->lsis[i];
		if (sp->vers == V1) {
			/*LINTED align*/
			lsisp->ls_trans = decode32(cp);
			cp += 4;
		} else {
			/*LINTED align*/
			lsisp->ls_trans = decode64(cp);
			cp += 8;
		}
		/*LINTED align*/
		lsisp->ls_corr = decode32(cp);
		cp += 4;
	}

	for (i = 0; i < sp->typecnt; ++i) {
		ttisp = &sp->ttis[i];
		if (ttisstdcnt == 0) {
			ttisp->tt_ttisstd = FALSE;
		} else {
			ttisp->tt_ttisstd = *cp++;
			if (ttisp->tt_ttisstd != TRUE &&
			    ttisp->tt_ttisstd != FALSE) {
				lfree(bufp, flen);
				return (-1);
			}
		}
	}

	for (i = 0; i < sp->typecnt; ++i) {
		ttisp = &sp->ttis[i];
		if (ttisgmtcnt == 0) {
			ttisp->tt_ttisgmt = FALSE;
		} else {
			ttisp->tt_ttisgmt = *cp++;
			if (ttisp->tt_ttisgmt != TRUE &&
			    ttisp->tt_ttisgmt != FALSE) {
				lfree(bufp, flen);
				return (-1);
			}
		}
	}

	/*
	 * Handle V2 specific POSIX style transition rule
	 */
	nread -= (cp - bufp);
	if (sp->vers == V2 && nread > 2 &&
	    *cp == '\n' && *(cp + nread -1) == '\n' &&
	    (sp->typecnt + 2) <= TZ_MAX_TYPES) {
		state_t	*ts;

		*(cp + nread - 1) = '\0';
		cp++;
		ts = lmalloc(STATE_SZ(V2));
		if (ts != NULL && init_state(ts, cp, V2) == 0 &&
		    load_posixinfo(cp, ts) == 0 && ts->typecnt == 2) {
			timeINT_t lts;
			size_t ncsz = sp->charcnt + ts->charcnt;

			if (sp->charsbuf_size < ncsz) {
				char *np;

				if ((np = libc_realloc(sp->chars,
				    ncsz)) == NULL) {
					fini_state(ts);
					lfree(ts, STATE_SZ(V2));
					lfree(bufp, flen);
					return (-1);
				}
				sp->chars = np;
				sp->charsbuf_size = ncsz;
			}
			/* adjust index */
			ts->ttis[0].tt_abbrind += sp->charcnt;
			ts->ttis[1].tt_abbrind += sp->charcnt;
			/* copy new chars */
			(void) memcpy(sp->chars + sp->charcnt,
			    ts->chars, ts->charcnt);
			sp->charcnt += ts->charcnt;

			/* append types */
			sp->ttis[sp->typecnt] = ts->ttis[0];
			sp->ttis[sp->typecnt + 1] = ts->ttis[1];

			/* find where we start from */
			i = 0;
			lts = sp->ats[sp->timecnt - 1];
			while (i < ts->timecnt && ts->ats[i] <= lts)
				i++;
			/* append trans */
			while (i < ts->timecnt && sp->timecnt < TZ_MAX_TIMES) {
				sp->ats[sp->timecnt] = ts->ats[i];
				sp->types[sp->timecnt] =
				    sp->typecnt + ts->types[i];
				ttisp = &sp->ttis[sp->types[sp->timecnt]];

				prevp->std = most_recent_std;
				prevp->alt = most_recent_alt;
				if (ttisp->tt_isdst == 1)
					most_recent_alt = ttisp;
				else
					most_recent_std = ttisp;

				sp->timecnt++;
				i++;
				prevp++;
			}
			sp->typecnt += 2;
		}
		if (ts != NULL) {
			fini_state(ts);
			lfree(ts, STATE_SZ(V2));
		}
	}

	if (most_recent_alt == NULL)
		sp->daylight = 0;
	else
		sp->daylight = 1;

	sp->goahead = FALSE;
	if (sp->timecnt > 1) {
		for (i = sp->timecnt - 2; i >= 0; i++) {
			if (typesequiv(sp, sp->types[sp->timecnt - 1],
			    sp->types[i])) {
				sp->goahead = TRUE;
				break;
			}
		}
	}

	/*
	 * Other defaults set at beginning of this routine
	 * to cover case where zoneinfo file cannot be loaded
	 */
	sp->default_timezone = -sp->ttis[0].tt_gmtoff;
	sp->default_altzone  = 0;
	sp->default_tzname0  = &sp->chars[0];
	sp->default_tzname1  = _tz_spaces;

	lfree(bufp, flen);

	sp->mtime = stbuf.st_mtim;

	sp->zonerules = ZONEINFO;

	return (0);
}

static int
typesequiv(const state_t *sp, int a, int b)
{
	const ttinfo_t *ta, *tb;

	if (a == b)
		return (TRUE);

	ta = &sp->ttis[a];
	tb = &sp->ttis[b];
	if (ta->tt_gmtoff == tb->tt_gmtoff &&
	    ta->tt_isdst == tb->tt_isdst &&
	    ta->tt_ttisstd == tb->tt_ttisstd &&
	    ta->tt_ttisgmt == tb->tt_ttisgmt) {
		if (strcmp(&sp->chars[ta->tt_abbrind],
		    &sp->chars[tb->tt_abbrind]) == 0)
			return (TRUE);
	}
	return (FALSE);
}

#ifdef	_TZ_DEBUG
static void
print_state(state_t *sp)
{
	struct tm	tmp;
	int	i, c;

	(void) fprintf(stderr, "=========================================\n");
	(void) fprintf(stderr, "zonename: \"%s\"\n", sp->zonename);
	(void) fprintf(stderr, "next: 0x%p\n", (void *)sp->next);
	(void) fprintf(stderr, "zonerules: %s\n",
	    sp->zonerules == ZONERULES_INVALID ? "ZONERULES_INVALID" :
	    sp->zonerules == POSIX ? "POSIX" :
	    sp->zonerules == POSIX_USA ? "POSIX_USA" :
	    sp->zonerules == ZONEINFO ? "ZONEINFO" : "UNKNOWN");
	(void) fprintf(stderr, "daylight: %d\n", sp->daylight);
	(void) fprintf(stderr, "default_timezone: %ld\n", sp->default_timezone);
	(void) fprintf(stderr, "default_altzone: %ld\n", sp->default_altzone);
	(void) fprintf(stderr, "default_tzname0: \"%s\"\n",
	    sp->default_tzname0);
	(void) fprintf(stderr, "default_tzname1: \"%s\"\n",
	    sp->default_tzname1);
	(void) fprintf(stderr, "leapcnt: %d\n", sp->leapcnt);
	(void) fprintf(stderr, "timecnt: %d\n", sp->timecnt);
	(void) fprintf(stderr, "typecnt: %d\n", sp->typecnt);
	(void) fprintf(stderr, "charcnt: %d\n", sp->charcnt);
	(void) fprintf(stderr, "chars: \"%s\"\n", sp->chars);
	(void) fprintf(stderr, "charsbuf_size: %u\n", sp->charsbuf_size);
	(void) fprintf(stderr, "prev = {\n");
	for (c = 0, i = 0; i < sp->timecnt; i++) {
		prev_t *pp;
		int i1, i2;
		if (c != 0)
			(void) fprintf(stderr, ", ");
		pp = &sp->prev[i];
		i1 = (pp->std == NULL) ? 0 : pp->std - &sp->ttis[0];
		i2 = (pp->alt == NULL) ? 0 : pp->alt - &sp->ttis[0];
		(void) fprintf(stderr, "[%4d] %d %d", i, i1, i2);
		if (c == 2) {
			(void) fprintf(stderr, "\n");
			c = 0;
		} else {
			c++;
		}
	}
	(void) fprintf(stderr, "ats = {\n");
	for (c = 0, i = 0; i < sp->timecnt; i++) {
		char	buf[64];
		size_t	len;
		if (c != 0) {
			(void) fprintf(stderr, ", ");
		}
		(void) asctime_r(gmtime_r(&sp->ats[i], &tmp),
		    buf, sizeof (buf));
		len = strlen(buf);
		buf[len-1] = '\0';
		(void) fprintf(stderr, "[%4d] %s", i, buf);
		if (c == 1) {
			(void) fprintf(stderr, "\n");
			c = 0;
		} else {
			c++;
		}
	}
	(void) fprintf(stderr, "}\n");
	(void) fprintf(stderr, "types = {\n");
	for (c = 0, i = 0; i < sp->timecnt; i++) {
		if (c == 0) {
			(void) fprintf(stderr, "\t");
		} else {
			(void) fprintf(stderr, ", ");
		}
		(void) fprintf(stderr, "%d", sp->types[i]);
		if (c == 7) {
			(void) fprintf(stderr, "\n");
			c = 0;
		} else {
			c++;
		}
	}
	(void) fprintf(stderr, "}\n");
	(void) fprintf(stderr, "ttis = {\n");
	for (i = 0; i < sp->typecnt; i++) {
		(void) fprintf(stderr, "\t%p {\n", &sp->ttis[i]);
		(void) fprintf(stderr, "\t\ttt_gmtoff: %d\n",
		    sp->ttis[i].tt_gmtoff);
		(void) fprintf(stderr, "\t\ttt_ttisdst: %d\n",
		    sp->ttis[i].tt_isdst);
		(void) fprintf(stderr, "\t\ttt_abbrind: %d\n",
		    sp->ttis[i].tt_abbrind);
		(void) fprintf(stderr, "\t\ttt_tt_isstd: %d\n",
		    sp->ttis[i].tt_ttisstd);
		(void) fprintf(stderr, "\t\ttt_ttisgmt: %d\n",
		    sp->ttis[i].tt_ttisgmt);
		(void) fprintf(stderr, "\t}\n");
	}
	(void) fprintf(stderr, "}\n");
}
#endif

/*
 * Given a POSIX section 8-style TZ string, fill in transition tables.
 *
 * Examples:
 *
 * TZ = PST8 or GMT0
 *	Timecnt set to 0 and typecnt set to 1, reflecting std time only.
 *
 * TZ = PST8PDT or PST8PDT7
 *	Create transition times by applying USA transitions from
 *	Jan 1 of each year covering 1902-2038.  POSIX offsets
 *	as specified in the TZ are used to calculate the tt_gmtoff
 *	for each of the two zones.  If ommitted, DST defaults to
 *	std. time minus one hour.
 *
 * TZ = <PST8>8PDT  or <PST8>8<PDT9>
 *      Quoted transition.  The values in angled brackets are treated
 *      as zone name text, not parsed as offsets.  The offsets
 *      occuring following the zonename section.  In this way,
 *      instead of PST being displayed for standard time, it could
 *      be displayed as PST8 to give an indication of the offset
 *      of that zone to GMT.
 *
 * TZ = GMT0BST, M3.5.0/1, M10.5.0/2   or  GMT0BST, J23953, J23989
 *	Create transition times based on the application new-year
 *	relative POSIX transitions, parsed from TZ, from Jan 1
 *	for each year covering 1902-2038.  POSIX offsets specified
 *	in TZ are used to calculate tt_gmtoff for each of the two
 *	zones.
 *
 */
static int
load_posixinfo(const char *name, state_t *sp)
{
	const char	*stdname;
	const char	*dstname = 0;
	size_t		stdlen;
	size_t		dstlen;
	long		stdoff = 0;
	long		dstoff = 0;
	char		*cp;
	int		i;
	ttinfo_t	*dst;
	ttinfo_t	*std;
	int		quoted;
	zone_rules_t	zonetype;

	zonetype = POSIX_USA;
	stdname = name;

	if ((quoted = (*stdname == '<')) != 0)
		++stdname;

	/* Parse/extract STD zone name, len and GMT offset */
	if (*name != '\0') {
		if ((name = getzname(name, quoted)) == NULL)
			return (-1);
		stdlen = name - stdname;
		if (*name == '>')
			++name;
		if (*name == '\0' || stdlen < 1) {
			return (-1);
		} else {
			if ((name = getoffset(name, &stdoff)) == NULL)
				return (-1);
		}
	}

	/* If DST specified in TZ, extract DST zone details */
	if (*name != '\0') {

		dstname = name;
		if ((quoted = (*dstname == '<')) != 0)
			++dstname;
		if ((name = getzname(name, quoted)) == NULL)
			return (-1);
		dstlen = name - dstname;
		if (dstlen < 1)
			return (-1);
		if (*name == '>')
			++name;
		if (*name != '\0' && *name != ',' && *name != ';') {
			if ((name = getoffset(name, &dstoff)) == NULL)
				return (-1);
		} else {
			dstoff = stdoff - SECSPERHOUR;
		}

		if (*name != ',' && *name != ';') {
			/* no transtition specified; using default rule */
			if (load_zoneinfo(TZDEFRULES, sp) == 0 &&
			    sp->daylight == 1) {
				/* loading TZDEFRULES zoneinfo succeeded */
				adjust_posix_default(sp, stdoff, dstoff);
			} else {
				/*
				 * We either failed to load the default
				 * rule, or default rule doesn't have DST.
				 */
				/* loading TZDEFRULES zoneinfo failed */
				load_posix_transitions(sp, stdoff, dstoff,
				    zonetype);
			}
		} else {
			/* extract POSIX transitions from TZ */
			/* Backward compatibility using ';' separator */
			int	compat_flag = (*name == ';');

			++name;
			if ((name = getrule(name, &sp->start_rule, compat_flag))
			    == NULL)
				return (-1);
			if (*name++ != ',')
				return (-1);
			if ((name = getrule(name, &sp->end_rule, compat_flag))
			    == NULL)
				return (-1);
			if (*name != '\0')
				return (-1);
			zonetype = POSIX;
			load_posix_transitions(sp, stdoff, dstoff, zonetype);
		}
		dst = &sp->ttis[0];
		std = &sp->ttis[1];
	} else {  /* DST wasn't specified in POSIX TZ */

		/*  Since we only have STD time, there are no transitions */
		dstlen = 0;
		sp->daylight = 0;
		sp->typecnt = 1;
		sp->timecnt = 0;
		std = &sp->ttis[0];
		std->tt_gmtoff = -stdoff;
		std->tt_isdst = 0;
	}

	/* Setup zone name character data for state table */
	sp->charcnt = (int)(stdlen + 1);
	if (dstlen != 0)
		sp->charcnt += dstlen + 1;

	/* If bigger than zone name abbv. buffer, grow it */
	if ((size_t)sp->charcnt > sp->charsbuf_size) {
		if ((cp = libc_realloc(sp->chars, sp->charcnt)) == NULL)
			return (-1);
		sp->chars = cp;
		sp->charsbuf_size = sp->charcnt;
	}

	/*
	 * Copy zone name text null-terminatedly into state table.
	 * By doing the copy once during zone loading, setting
	 * tzname[] subsequently merely involves setting pointer
	 *
	 * If either or both std. or alt. zone name < 3 chars,
	 * space pad the deficient name(s) to right.
	 */

	std->tt_abbrind = 0;
	cp = sp->chars;
	(void) strncpy(cp, stdname, stdlen);
	while (stdlen < 3)
		cp[stdlen++] = ' ';
	cp[stdlen] = '\0';

	i = (int)(stdlen + 1);
	if (dstlen != 0) {
		dst->tt_abbrind = i;
		cp += i;
		(void) strncpy(cp, dstname, dstlen);
		while (dstlen < 3)
			cp[dstlen++] = ' ';
		cp[dstlen] = '\0';
	}

	/* Save default values */
	if (sp->typecnt == 1) {
		sp->default_timezone = stdoff;
		sp->default_altzone = stdoff;
		sp->default_tzname0 = &sp->chars[0];
		sp->default_tzname1 = _tz_spaces;
	} else {
		sp->default_timezone = -std->tt_gmtoff;
		sp->default_altzone = -dst->tt_gmtoff;
		sp->default_tzname0 = &sp->chars[std->tt_abbrind];
		sp->default_tzname1 = &sp->chars[dst->tt_abbrind];
	}

	sp->zonerules = zonetype;

	return (0);
}

/*
 * We loaded the TZDEFAULT which usually the one in US zones. We
 * adjust the GMT offset for the zone which has stdoff/dstoff
 * offset.
 */
static void
adjust_posix_default(state_t *sp, long stdoff, long dstoff)
{
	long	zone_stdoff = 0;
	long	zone_dstoff = 0;
	int	isdst;
	int	i;
	ttinfo_t	*zone;
	ttinfo_t	*ralt = NULL, *rstd = NULL;
	prev_t	*prevp;

	/*
	 * Initial values of zone_stdoff and zone_dstoff
	 */
	for (i = 0; i < sp->timecnt; i++) {
		zone = &sp->ttis[sp->types[i]];
		if (zone->tt_isdst == 0) {
			zone_stdoff = -zone->tt_gmtoff;
			break;
		}
	}
	for (i = 0; i < sp->timecnt; i++) {
		zone = &sp->ttis[sp->types[i]];
		if (zone->tt_isdst != 0) {
			zone_dstoff = -zone->tt_gmtoff;
			break;
		}
	}
	if (i == sp->timecnt)
		zone_dstoff = zone_stdoff;

	/*
	 * Initially we're assumed to be in standard time.
	 */
	isdst = 0;
	prevp = &sp->prev[0];

	for (i = 0; i < sp->timecnt; i++) {
		int	next_isdst;

		zone = &sp->ttis[sp->types[i]];
		next_isdst = zone->tt_isdst;

		sp->types[i] = next_isdst ? 0 : 1;

		prevp->std = rstd;
		prevp->alt = ralt;

		if (zone->tt_ttisgmt == 0) {
			/*
			 * If summer time is in effect, and the transition time
			 * was not specified as standard time, add the summer
			 * time offset to the transition time;
			 * otherwise, add the standard time offset to the
			 * transition time.
			 */
			/*
			 * Transitions from DST to DDST will effectively
			 * disappear since POSIX provides for only one DST
			 * offset.
			 */
			if (isdst != 0 && zone->tt_ttisstd == 0)
				sp->ats[i] += dstoff - zone_dstoff;
			else
				sp->ats[i] += stdoff - zone_stdoff;
		}
		if (next_isdst != 0) {
			zone_dstoff = -zone->tt_gmtoff;
			ralt = &sp->ttis[sp->types[i]];
		} else {
			zone_stdoff = -zone->tt_gmtoff;
			rstd = &sp->ttis[sp->types[i]];
		}
		isdst = next_isdst;
		prevp++;
	}
	/*
	 * Finally, fill in ttis.
	 * ttisstd and ttisgmt need not be handled.
	 */
	sp->ttis[0].tt_gmtoff = -dstoff;
	sp->ttis[0].tt_isdst = 1;
	sp->ttis[1].tt_gmtoff = -stdoff;
	sp->ttis[1].tt_isdst = 0;
	sp->typecnt = 2;
	sp->daylight = 1;
}

static void
load_posix_transitions(state_t *sp, long stdoff, long dstoff,
    zone_rules_t zonetype)
{
	ttinfo_t	*std, *dst;
	timeINT_t	*tranp;
	uchar_t	*typep;
	prev_t	*prevp;
	int	i, year, tz_max_times;
	int64_t	janfirst;
	posix_daylight_t	pdaylight;

	/*
	 * We know STD and DST zones are specified with this timezone
	 * therefore the cache will be set up with 2 transitions per
	 * year transitioning to their respective std and dst zones.
	 */
	sp->daylight = 1;
	sp->typecnt = 2;
	sp->timecnt = 0;

	/*
	 * Insert zone data from POSIX TZ into state table
	 * The Olson public domain POSIX code sets up ttis[0] to be DST,
	 * as we are doing here.  It seems to be the correct behavior.
	 * The US/Pacific zoneinfo file also lists DST as first type.
	 */
	dst = &sp->ttis[0];
	dst->tt_gmtoff = -dstoff;
	dst->tt_isdst = 1;

	std = &sp->ttis[1];
	std->tt_gmtoff = -stdoff;
	std->tt_isdst = 0;

	sp->prev[0].std = NULL;
	sp->prev[0].alt = NULL;

	/* Create transition data based on POSIX TZ */
	tranp = sp->ats;
	prevp  = &sp->prev[1];
	typep  = sp->types;

	/*
	 * We only cache from 1902 to 2037 to avoid transistions
	 * that wrap at the 32-bit boundries, since 1901 and 2038
	 * are not full years in 32-bit time.  The rough edges
	 * will be handled as transition cache misses.
	 */
	janfirst = JAN_01_1902;

	pdaylight.rules[0] = &sp->start_rule;
	pdaylight.rules[1] = &sp->end_rule;
	pdaylight.offset[0] = stdoff;
	pdaylight.offset[1] = dstoff;

	tz_max_times = (sp->vers == V1) ? TZ_MAX_TIMES_V1 : TZ_MAX_TIMES;

	for (i = MAX_RULE_TABLE; i >= 0; i--) {
		if (zonetype == POSIX_USA) {
			pdaylight.rules[0] = (rule_t *)&__usa_rules[i].start;
			pdaylight.rules[1] = (rule_t *)&__usa_rules[i].end;
		}
		for (year = __usa_rules[i].s_year;
		    (sp->timecnt + 2) <= tz_max_times &&
		    year <= __usa_rules[i].e_year; year++) {
			int	idx, ridx;

			idx = posix_daylight(&janfirst, year, &pdaylight);
			ridx = !idx;

			/*
			 * Two transitions per year. Since there are
			 * only two zone types for this POSIX zone,
			 * previous std and alt are always set to
			 * &ttis[0] and &ttis[1].
			 */
			*tranp++ = pdaylight.rtime[idx];
			*typep++ = (uchar_t)idx;
			prevp->std = std;
			prevp->alt = dst;
			++prevp;

			*tranp++ = pdaylight.rtime[ridx];
			*typep++ = (uchar_t)ridx;
			prevp->std = std;
			prevp->alt = dst;
			++prevp;

			sp->timecnt += 2;

			/* Version 1 can only handle till 2038 */
			if (sp->vers == V1) {
				if (year == 2038)
					return;
			}
		}
	}
}

/*
 * Given a pointer into a time zone string, scan until a character that is not
 * a valid character in a zone name is found.  Return ptr to that character.
 * Return NULL if error (ie. non-printable character located in name)
 */
static const char *
getzname(const char *strp, int quoted)
{
	char	c;

	if (quoted) {
		while ((c = *strp) != '\0' && c != '>' &&
		    isgraph((unsigned char)c)) {
			++strp;
		}
	} else {
		while ((c = *strp) != '\0' && isgraph((unsigned char)c) &&
		    !isdigit((unsigned char)c) && c != ',' && c != '-' &&
		    c != '+') {
			++strp;
		}
	}

	/* Found an excessively invalid character.  Discredit whole name */
	if (c != '\0' && !isgraph((unsigned char)c))
		return (NULL);

	return (strp);
}

/*
 * Given pointer into time zone string, extract first
 * number pointed to.  Validate number within range specified,
 * Return ptr to first char following valid numeric sequence.
 */
static const char *
getnum(const char *strp, int *nump, int min, int max)
{
	char	c;
	int	num;

	if (strp == NULL || !isdigit((unsigned char)(c = *strp)))
		return (NULL);
	num = 0;
	do {
		num = num * 10 + (c - '0');
		if (num > max)
			return (NULL);	/* illegal value */
		c = *++strp;
	} while (isdigit((unsigned char)c));
	if (num < min)
		return (NULL);		/* illegal value */
	*nump = num;
	return (strp);
}

/*
 * Given a pointer into a time zone string, extract a number of seconds,
 * in hh[:mm[:ss]] form, from the string.  If an error occurs, return NULL,
 * otherwise, return a pointer to the first character not part of the number
 * of seconds.
 */
static const char *
getsecs(const char *strp, long *secsp)
{
	int	num;

	/*
	 * `HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	 * "M10.4.6/26", which does not conform to Posix,
	 * but which specifies the equivalent of
	 * ``02:00 on the first Sunday on or after 23 Oct''.
	 */
	strp = getnum(strp, &num, 0, HOURSPERDAY * DAYSPERWEEK - 1);
	if (strp == NULL)
		return (NULL);
	*secsp = num * (long)SECSPERHOUR;
	if (*strp == ':') {
		++strp;
		strp = getnum(strp, &num, 0, MINSPERHOUR - 1);
		if (strp == NULL)
			return (NULL);
		*secsp += num * SECSPERMIN;
		if (*strp == ':') {
			++strp;
			/* `SECSPERMIN' allows for leap seconds.  */
			strp = getnum(strp, &num, 0, SECSPERMIN);
			if (strp == NULL)
				return (NULL);
			*secsp += num;
		}
	}
	return (strp);
}

/*
 * Given a pointer into a time zone string, extract an offset, in
 * [+-]hh[:mm[:ss]] form, from the string.
 * If any error occurs, return NULL.
 * Otherwise, return a pointer to the first character not part of the time.
 */
static const char *
getoffset(const char *strp, long *offsetp)
{
	int	neg = 0;

	if (*strp == '-') {
		neg = 1;
		++strp;
	} else if (*strp == '+') {
		++strp;
	}
	strp = getsecs(strp, offsetp);
	if (strp == NULL)
		return (NULL);		/* illegal time */
	if (neg)
		*offsetp = -*offsetp;
	return (strp);
}

/*
 * Given a pointer into a time zone string, extract a rule in the form
 * date[/time].  See POSIX section 8 for the format of "date" and "time".
 * If a valid rule is not found, return NULL.
 * Otherwise, return a pointer to the first character not part of the rule.
 *
 * If compat_flag is set, support old 1-based day of year values.
 */
static const char *
getrule(const char *strp, rule_t *rulep, int compat_flag)
{
	if (compat_flag == 0 && *strp == 'M') {
		/*
		 * Month, week, day.
		 */
		rulep->r_type = MON_WEEK_DOW;
		++strp;
		strp = getnum(strp, &rulep->r_mon, 1, MONSPERYEAR);
		if (strp == NULL)
			return (NULL);
		if (*strp++ != '.')
			return (NULL);
		strp = getnum(strp, &rulep->r_week, 1, 5);
		if (strp == NULL)
			return (NULL);
		if (*strp++ != '.')
			return (NULL);
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERWEEK - 1);
	} else if (compat_flag == 0 && *strp == 'J') {
		/*
		 * Julian day.
		 */
		rulep->r_type = JULIAN_DAY;
		++strp;
		strp = getnum(strp, &rulep->r_day, 1, DAYSPERNYEAR);

	} else if (isdigit((unsigned char)*strp)) {
		/*
		 * Day of year.
		 */
		rulep->r_type = DAY_OF_YEAR;
		if (compat_flag == 0) {
			/* zero-based day of year */
			strp = getnum(strp, &rulep->r_day, 0, DAYSPERLYEAR - 1);
		} else {
			/* one-based day of year */
			strp = getnum(strp, &rulep->r_day, 1, DAYSPERLYEAR);
			rulep->r_day--;
		}
	} else {
		return (NULL);		/* ZONERULES_INVALID format */
	}
	if (strp == NULL)
		return (NULL);
	if (*strp == '/') {
		/*
		 * Time specified.
		 */
		++strp;
		strp = getsecs(strp, &rulep->r_time);
	} else	{
		rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
	}
	return (strp);
}

/*
 * Returns default value for TZ as specified in /etc/default/init file, if
 * a default value for TZ is provided there.
 */
static char *
get_default_tz(void)
{
	char	*tz = NULL;
	uchar_t	*tzp, *tzq;
	int	flags;
	void	*defp;

	assert_no_libc_locks_held();

	if ((defp = defopen_r(TIMEZONE)) != NULL) {
		flags = defcntl_r(DC_GETFLAGS, 0, defp);
		TURNON(flags, DC_STRIP_QUOTES);
		(void) defcntl_r(DC_SETFLAGS, flags, defp);

		if ((tzp = (uchar_t *)defread_r(TZSTRING, defp)) != NULL) {
			while (isspace(*tzp))
				tzp++;
			tzq = tzp;
			while (!isspace(*tzq) &&
			    *tzq != ';' &&
			    *tzq != '#' &&
			    *tzq != '\0')
				tzq++;
			*tzq = '\0';
			if (*tzp != '\0')
				tz = libc_strdup((char *)tzp);
		}

		defclose_r(defp);
	}
	return (tz);
}

/*
 * invalidate all cache'd state_t
 */
static void
invalidate_cache(void)
{
	int	hashid;
	state_t	*p;

	/* mark all state invalid */
	for (hashid = 0; hashid < HASHTABLE; hashid++) {
		for (p = tzcache[hashid]; p != NULL; p = p->next)
			p->invalid = 1;
	}

	/* shouldn't go fast path */
	namecache = NULL;

	/* last_tzname[] may point cache being freed */
	last_tzname[0] = NULL;
	last_tzname[1] = NULL;

	/* We'll reload system TZ as well */
	systemTZ = NULL;
}

/*
 * When called first time, open the counter device and load
 * the initial value. If counter is updated, copy value to
 * private memory.
 */
static void
reload_counter(void)
{
	int	fd;
	caddr_t	addr;

	if (TZSYNC_READY()) {
		zoneinfo_seqno = *zoneinfo_seqadr;
		return;
	}

	if ((fd = open(TZSYNC_FILE, O_RDONLY)) < 0)
		return;

	addr = mmap(0, sizeof (uint32_t), PROT_READ, MAP_SHARED, fd, 0);
	(void) close(fd);

	if (addr == MAP_FAILED)
		return;
	/*LINTED*/
	zoneinfo_seqadr = (uint32_t *)addr;
	zoneinfo_seqno = *zoneinfo_seqadr;
}

/*
 * getsystemTZ() returns the TZ value if it is set in the environment, or
 * it returns the system TZ;  if the systemTZ has not yet been set, or
 * cleared by tzreload, get_default_tz() is called to read the
 * /etc/default/init file to get the value.
 */
static const char *
getsystemTZ()
{
	tznmlist_t *tzn;
	char	*tz;

	tz = getenv("TZ");
	if (tz != NULL && *tz != '\0')
		return ((const char *)tz);

	if (systemTZ != NULL)
		return (systemTZ);

	/*
	 * get_default_tz calls out stdio functions via defread.
	 */
	lmutex_unlock(&_time_lock);
	tz = get_default_tz();
	lmutex_lock(&_time_lock);

	if (tz == NULL) {
		/* no TZ entry in the file */
		systemTZ = _posix_gmt0;
		return (systemTZ);
	}

	/*
	 * look up timezone used previously. We will not free the
	 * old timezone name, because ltzset_u() can release _time_lock
	 * while it has references to systemTZ (via zonename). If we
	 * free the systemTZ, the reference via zonename can access
	 * invalid memory when systemTZ is reset.
	 */
	for (tzn = systemTZrec; tzn != NULL; tzn = tzn->link) {
		if (strcmp(tz, tzn->name) == 0)
			break;
	}
	if (tzn == NULL) {
		/* This is new timezone name */
		tzn = lmalloc(sizeof (tznmlist_t *) + strlen(tz) + 1);
		if (tzn == NULL) {
			libc_free(tz);
			return (NULL);
		}
		(void) strcpy(tzn->name, tz);
		tzn->link = systemTZrec;
		systemTZrec = tzn;
	}

	libc_free(tz);

	return (systemTZ = tzn->name);
}

/*
 * tzname[] is the user visible string which applications may have
 * references. Even though TZ was changed, references to the old tzname
 * may continue to remain in the application, and those references need
 * to be valid. They were valid by our implementation because strings being
 * pointed by tzname were never be freed nor altered by the change of TZ.
 * However, this will no longer be the case.
 *
 * state_t is now freed when cache is purged. Therefore, reading string
 * from old tzname[] addr may end up with accessing a stale data(freed area).
 * To avoid this, we maintain a copy of all timezone name strings which will
 * never be freed, and tzname[] will point those copies.
 *
 */
static int
set_one_tzname(const char *name, int idx)
{
	const unsigned char *nm;
	int	hashid, i;
	char	*s;
	tznmlist_t *tzn;

	if (name == _tz_gmt || name == _tz_spaces) {
		tzname[idx] = (char *)name;
		return (0);
	}

	nm = (const unsigned char *)name;
	hashid = (nm[0] * 29 + nm[1] * 3) % TZNMC_SZ;
	for (tzn = tznmhash[hashid]; tzn != NULL; tzn = tzn->link) {
		s = tzn->name;
		/* do the strcmp() */
		for (i = 0; s[i] == name[i]; i++) {
			if (s[i] == '\0') {
				tzname[idx] = tzn->name;
				return (0);
			}
		}
	}
	/*
	 * allocate new entry. This entry is never freed, so use lmalloc
	 */
	tzn = lmalloc(sizeof (tznmlist_t *) + strlen(name) + 1);
	if (tzn == NULL)
		return (1);

	(void) strcpy(tzn->name, name);

	/* link it */
	tzn->link = tznmhash[hashid];
	tznmhash[hashid] = tzn;

	tzname[idx] = tzn->name;
	return (0);
}

/*
 * Set tzname[] after testing parameter to see if we are setting
 * same zone name. If we got same address, it should be same zone
 * name as tzname[], unless cache have been purged.
 * Note, fini_state() resets last_tzname[].
 */
static void
set_tzname(const char **namep)
{
	if (namep[0] != last_tzname[0]) {
		if (set_one_tzname(namep[0], 0)) {
			tzname[0] = (char *)_tz_gmt;
			last_tzname[0] = NULL;
		} else {
			last_tzname[0] = namep[0];
		}
	}

	if (namep[1] != last_tzname[1]) {
		if (set_one_tzname(namep[1], 1)) {
			tzname[1] = (char *)_tz_spaces;
			last_tzname[1] = NULL;
		} else {
			last_tzname[1] = namep[1];
		}
	}
}

static int32_t
decode32_slow(const char *p)
{
	unsigned char *up = (unsigned char *)p;
	int32_t	r;

	r =  (int32_t)up[0] << 24;
	r += (int32_t)up[1] << 16;
	r += (int32_t)up[2] << 8;
	r += (int32_t)up[3];
	return (r);
}

static int64_t
decode64_slow(const char *p)
{
	unsigned char *up;
	int64_t	r;

	if (((uintptr_t)p % 4) == 0) {
		/*LINTED*/
		r = (int64_t)BE_32(*(uint32_t *)p) << 32;
		/*LINTED*/
		r += (uint64_t)BE_32(*(int32_t *)(p + 4));
		return (r);
	}

	up = (unsigned char *)p;
	r =  (int64_t)up[0] << 56;
	r += (int64_t)up[1] << 48;
	r += (int64_t)up[2] << 40;
	r += (int64_t)up[3] << 32;
	r += (int64_t)up[4] << 24;
	r += (int64_t)up[5] << 16;
	r += (int64_t)up[6] << 8;
	r += (int64_t)up[7];
	return (r);
}
