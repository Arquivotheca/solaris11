/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
 */

#include <libdllink.h>
#include <stdio.h>
#include <strings.h>
#include <libsysevent.h>
#include <sys/dlpi.h>
#include "lldp_impl.h"
#include "dcbx_impl.h"
#include "dcbx_pfc.h"
#include "dcbx_appln.h"
#include "lldp_provider.h"

/* Remove a DCBx feature from the list */
int
dcbx_feature_delete(dcbx_feature_t *dfp)
{
	lldp_agent_t	*lap = dfp->df_la;
	dcbx_feature_t	*cur;

	lldp_rw_lock(&lap->la_feature_rwlock, LLDP_RWLOCK_WRITER);
	for (cur = list_head(&lap->la_features); cur != NULL;
	    cur = list_next(&lap->la_features, cur)) {
		if (cur == dfp) {
			list_remove(&lap->la_features, cur);
			lldp_rw_unlock(&lap->la_feature_rwlock);
			dcbx_feature_refcnt_decr(cur);
			return (0);
		}
	}
	lldp_rw_unlock(&lap->la_feature_rwlock);
	return (ENOENT);
}

/* Hold reference to the feature */
void
dcbx_feature_refcnt_incr(dcbx_feature_t *dfp)
{
	lldp_mutex_lock(&dfp->df_lock);
	dfp->df_refcnt++;
	lldp_mutex_unlock(&dfp->df_lock);
}

/*
 * Decrenent reference for the feature and call the fini if it are
 * no more references to it.
 */
void
dcbx_feature_refcnt_decr(dcbx_feature_t *dfp)
{
	lldp_mutex_lock(&dfp->df_lock);
	assert(dfp->df_refcnt > 0);
	dfp->df_refcnt--;
	if (dfp->df_refcnt == 0) {
		lldp_mutex_unlock(&dfp->df_lock);
		dfp->df_fini(dfp);
	} else {
		lldp_mutex_unlock(&dfp->df_lock);
	}
}

/* Given a feature type, get the feature from the list */
dcbx_feature_t *
dcbx_feature_get(lldp_agent_t *lap, int feature)
{
	dcbx_feature_t	*cur;

	lldp_rw_lock(&lap->la_feature_rwlock, LLDP_RWLOCK_READER);
	for (cur = list_head(&lap->la_features); cur != NULL;
	    cur = list_next(&lap->la_features, cur)) {
		if (cur->df_ftype == feature) {
			dcbx_feature_refcnt_incr(cur);
			lldp_rw_unlock(&lap->la_feature_rwlock);
			return (cur);
		}
	}
	lldp_rw_unlock(&lap->la_feature_rwlock);
	return (NULL);
}

/*
 * Handles the remote change events for DCB features PFC and FCOE.
 */
int
dcbx_handle_sysevents(sysevent_t *ev, void *arg)
{
	dcbx_feature_t	*dfp = arg;
	nvlist_t	*nvl = NULL, *dnvl = NULL, *fnvl = NULL;
	char		*fname, *laname, *str;
	uint32_t	version, ctype;
	boolean_t	update = B_FALSE;

	if (strcmp(sysevent_get_subclass_name(ev), ESC_LLDP_REMOTE) != 0)
		return (0);

	if (sysevent_get_attr_list(ev, &nvl) != 0) {
		syslog(LOG_WARNING, "sysevent_get_attr_list failed; "
		    "dropping event");
		return (0);
	}

	if (nvlist_lookup_uint32(nvl, LLDP_EVENT_VERSION, &version) != 0) {
		syslog(LOG_WARNING, "dropped event with no LLDP_EVENT_VERSION");
		goto out;
	}

	if (version != LLDP_EVENT_CUR_VERSION) {
		syslog(LOG_WARNING, "dropped event with unsupported "
		    "LLDP_EVENT_VERSION %d\n", version);
		goto out;
	}

	if (nvlist_lookup_string(nvl, LLDP_AGENT_NAME, &laname) != 0) {
		syslog(LOG_WARNING, "dropped event with no LLDP_AGENT_NAME");
		goto out;
	}

	/*
	 * we are interested in only those events that are generated by the
	 * agent on which we are enabled.
	 */
	if (strcmp(laname, dfp->df_la->la_linkname) != 0)
		goto out;

	if (nvlist_lookup_uint32(nvl, LLDP_CHANGE_TYPE, &ctype) != 0) {
		syslog(LOG_WARNING, "dropped event with no LLDP_CHANGE_TYPE");
		goto out;
	}

	lldp_mutex_lock(&dfp->df_lock);
	switch (ctype) {
	case LLDP_REMOTE_INFOAGE:
	case LLDP_REMOTE_SHUTDOWN:
		update = B_TRUE;
		break;
	case LLDP_REMOTE_CHANGED:
		if (dfp->df_ftype == DCBX_TYPE_PFC)
			fname = LLDP_NVP_PFC;
		else if (dfp->df_ftype == DCBX_TYPE_APPLICATION)
			fname = LLDP_NVP_APPLN;
		else
			break;

		if (nvlist_lookup_nvlist(nvl, LLDP_ADDED_TLVS, &dnvl) == 0) {
			if (lldp_get_nested_nvl(dnvl, LLDP_NVP_ORGANIZATION,
			    LLDP_8021_OUI_LIST, fname, &fnvl) == 0) {
				update = B_TRUE;
				break;
			}
		}
		if (nvlist_lookup_nvlist(nvl, LLDP_MODIFIED_TLVS, &dnvl) == 0) {
			if (lldp_get_nested_nvl(dnvl, LLDP_NVP_ORGANIZATION,
			    LLDP_8021_OUI_LIST, fname, &fnvl) == 0) {
				update = B_TRUE;
				break;
			}
		}
		if (nvlist_lookup_nvlist(nvl, LLDP_DELETED_TLVS, &dnvl) == 0) {
			if (nvlist_lookup_string(dnvl, fname, &str) == 0) {
				fnvl = NULL;
				update = B_TRUE;
				break;
			}
		}
		break;
	}
	if (update) {
		(void) nvlist_free(dfp->df_peercfg);
		dfp->df_peercfg = NULL;
		if (fnvl != NULL)
			(void) nvlist_dup(dnvl, &dfp->df_peercfg, 0);
		dfp->df_p_dcbxupdate = B_TRUE;
		(void) pthread_cond_signal(&dfp->df_condvar);
	}
	lldp_mutex_unlock(&dfp->df_lock);
out:
	nvlist_free(nvl);
	return (0);
}

/* Set properties for DCBx PFC and Application features */
int
dcbx_set_prop(lldp_agent_t *lap, lldp_propclass_t pclass,
    lldp_proptype_t ptype, void *pval, uint32_t flags)
{
	dcbx_feature_t	*dfp;
	int		feature_type, err;

	switch (pclass) {
	case LLDP_PROPCLASS_PFC_TLV:
		feature_type = DCBX_TYPE_PFC;
		break;
	case LLDP_PROPCLASS_APPLN_TLV:
		feature_type = DCBX_TYPE_APPLICATION;
		break;
	default:
		return (EINVAL);
	}

	if ((dfp = dcbx_feature_get(lap, feature_type)) == NULL)
		return (ENOENT);
	err = dfp->df_setprop(dfp, ptype, pval, flags);
	dcbx_feature_refcnt_decr(dfp);
	return (err);
}

/* Get DCBx PFC and Application feature property values */
int
dcbx_get_prop(lldp_agent_t *lap, lldp_propclass_t pclass,
    lldp_proptype_t ptype, char *buf, uint_t bufsize)
{
	dcbx_feature_t	*dfp;
	int		feature_type, err;

	switch (pclass) {
	case LLDP_PROPCLASS_PFC_TLV:
		feature_type = DCBX_TYPE_PFC;
		break;
	case LLDP_PROPCLASS_APPLN_TLV:
		feature_type = DCBX_TYPE_APPLICATION;
		break;
	default:
		return (EINVAL);
	}

	if ((dfp = dcbx_feature_get(lap, feature_type)) == NULL)
		return (ENOENT);
	err = dfp->df_getprop(dfp, ptype, buf, bufsize);
	dcbx_feature_refcnt_decr(dfp);
	return (err);
}

/* Get the event type for a DCBx feture */
char *
dcbx_type2eventsc(dcbx_feature_t *dfp)
{

	/* Once we have more events defined, we can make this a switch */
	if (dfp->df_ftype == DCBX_TYPE_PFC)
		return (ESC_LLDP_PFC);

	assert(dfp->df_ftype == DCBX_TYPE_APPLICATION);
	return (ESC_LLDP_APPLN);
}

/*
 * Got a notification from the underlying port about a change in its
 * Flow control mode, enable or disable PFC depending on the change.
 */
void
dcbx_fc_notify(lldp_agent_t *lap, dl_fc_info_t *fcinfo)
{
	int		err;
#ifdef	_WILLING_PROP
	lldp_pfc_t	pfc;
	dcbx_feature_t	*dfp;
#endif

	switch (fcinfo->dfi_mode) {
	case LINK_FLOWCTRL_PFC:
	case LINK_FLOWCTRL_AUTO:
		err = i_lldpd_set_tlv(lap, LLDP_PROPTYPE_8021TLV,
		    LLDP_8021_PFC_TLV, NULL, LLDP_OPT_APPEND);
		if (err == 0 || err == EEXIST) {
			/*
			 * Calling dcbx_set_prop instead of lldp_set_prop
			 * means this value won't persist. But, that should
			 * be fine since whenever LLDP comes it it always
			 * gets the PFC map from the underlying device.
			 */
#ifdef	_WILLING_PROP
			/* Check if we are willing to accept peer's config */
			pfc.lp_willing = fcinfo->dfi_mode == LINK_FLOWCTRL_AUTO;
			pfc.lp_enable = fcinfo->dfi_pfc;

			if ((dfp = dcbx_feature_get(lap, DCBX_TYPE_PFC)) ==
			    NULL) {
				break;
			}
			(void) dfp->df_setprop(dfp, LLDP_PROPTYPE_PFCMAP,
			    (void *)&pfc, 0);
			dcbx_feature_refcnt_decr(dfp);
#endif
			(void) dcbx_set_prop(lap, LLDP_PROPCLASS_PFC_TLV,
			    LLDP_PROPTYPE_PFCMAP, (void *)&fcinfo->dfi_pfc, 0);
		}
		break;
	case LINK_FLOWCTRL_NONE:
	case LINK_FLOWCTRL_RX:
	case LINK_FLOWCTRL_TX:
	case LINK_FLOWCTRL_BI:
		(void) i_lldpd_set_tlv(lap, LLDP_PROPTYPE_8021TLV,
		    LLDP_8021_PFC_TLV, NULL, LLDP_OPT_REMOVE);
		break;
	default:
		syslog(LOG_WARNING, "Unknown flow control mode %u\n",
		    fcinfo->dfi_mode);
		break;
	}
}

/*
 * Called when any DCBx feature changes locally. Update the local MIB
 * and send a LLDP message to the peer.
 */
void
dcbx_something_changed_local(dcbx_feature_t *dfp)
{
	lldp_agent_t	*lap = dfp->df_la;
	nvlist_t	*nvl;
	int		err;

	/* Update the Feature's TLV in the Local MIB */
	lldp_rw_lock(&lap->la_txmib_rwlock, LLDP_RWLOCK_WRITER);
	err = nvlist_lookup_nvlist(lap->la_local_mib, lap->la_msap, &nvl);
	if (err != 0) {
		syslog(LOG_ERR, "dcbx_something_changed_local: Failed to "
		    "retrieve local MIB for %s", lap->la_linkname);
		goto ret;
	}
	if (dfp->df_setcfg != NULL)
		err = dfp->df_setcfg(dfp, nvl, dfp->df_opercfg);
	else
		err = nvlist_merge(nvl, dfp->df_opercfg, 0);
	if (err != 0) {
		syslog(LOG_ERR, "dcbx_something_changed_local: Error modifying "
		    "feature %d on local MIB %s", dfp->df_ftype,
		    lap->la_linkname);
	}
ret:
	lldp_rw_unlock(&lap->la_txmib_rwlock);
	if (err == 0)
		lldp_something_changed_local(lap);
}

/* checks if the underlying NIC supports DCB features */
boolean_t
lldpd_islink_indcb(datalink_id_t linkid)
{
	char	propval[DLADM_PROP_VAL_MAX];
	char	*valptr[1];
	uint_t	valcnt = 1;
	uint8_t	ntcs;

	valptr[0] = propval;
	if (dladm_get_linkprop(dld_handle, linkid, DLADM_PROP_VAL_CURRENT,
	    "ntcs", (char **)valptr, &valcnt) != DLADM_STATUS_OK) {
		return (B_FALSE);
	}
	ntcs = (uint32_t)strtol(propval, NULL, 10);
	return (ntcs > 0);
}

/*
 * For a given link, if it supports PFC, following function returns the
 * number of traffic classes supported and the priority map. A link
 * supports PFC if the link is in the dcb mode (i.e. ntcs > 0) and
 * flowctrl datalink property is either "pfc" or "auto". If both
 * are true, the datalink property "pfcmap" gives the priorities
 * for which PFC is enabled.
 */
int
lldpd_link2pfcparam(datalink_id_t linkid, lldp_pfc_t *pfc)
{
	char	propval[DLADM_PROP_VAL_MAX];
	char	*valptr[1];
	uint_t	valcnt = 1;

	/* Check if PFC is supported on this link */
	valptr[0] = propval;
	if (dladm_get_linkprop(dld_handle, linkid, DLADM_PROP_VAL_CURRENT,
	    "flowctrl", (char **)valptr, &valcnt) != DLADM_STATUS_OK) {
		return (ENOTSUP);
	}
	if (strcmp(propval, "pfc") != 0 && strcmp(propval, "auto") != 0)
		return (ENOTSUP);

	/* Get the number of Traffic class */
	if (dladm_get_linkprop(dld_handle, linkid, DLADM_PROP_VAL_CURRENT,
	    "ntcs", (char **)valptr, &valcnt) != DLADM_STATUS_OK) {
		return (ENOTSUP);
	}
	pfc->lp_cap = (uint8_t)strtol(propval, NULL, 10);

	/* Get the number of PFC map */
	if (dladm_get_linkprop(dld_handle, linkid, DLADM_PROP_VAL_CURRENT,
	    "pfcmap", (char **)valptr, &valcnt) != DLADM_STATUS_OK) {
		syslog(LOG_ERR, "error getting pfc map");
		return (ENOTSUP);
	}
	pfc->lp_enable = (uint8_t)strtol(propval, NULL, 2);

	if (getzoneid() == GLOBAL_ZONEID)
		pfc->lp_willing = B_TRUE;
	else
		pfc->lp_willing = B_FALSE;
	return (0);
}

/*
 * retrieves the feature information from `lap'. Note that the caller has to
 * free `nvlp'
 */
void
dcbx_get_feature_nvl(lldp_agent_t *lap, uint_t ftype, nvlist_t **nvlp)
{
	nvpair_t	*nvp;
	nvlist_t	*mnvl, *fnvl, *rnvl = NULL;
	char		*fname;

	*nvlp = NULL;
	if (ftype == DCBX_TYPE_PFC)
		fname = LLDP_NVP_PFC;
	else if (ftype == DCBX_TYPE_APPLICATION)
		fname = LLDP_NVP_APPLN;
	else
		return;

	lldp_rw_lock(&lap->la_rxmib_rwlock, LLDP_RWLOCK_READER);
	for (nvp = nvlist_next_nvpair(lap->la_remote_mib, NULL); nvp != NULL;
	    nvp = nvlist_next_nvpair(lap->la_remote_mib, nvp)) {
		if (nvpair_value_nvlist(nvp, &mnvl) == 0) {
			/*
			 * Yes, if there are multiple DCBX peers we overwrite
			 * the previous one to get the information from the
			 * latest peer.
			 */
			if (lldp_get_nested_nvl(mnvl, LLDP_NVP_ORGANIZATION,
			    LLDP_8021_OUI_LIST, fname, &fnvl) == 0) {
				rnvl = mnvl;
			}
		}
	}
	if (rnvl != NULL && nvlist_dup(rnvl, nvlp, 0) != 0)
		*nvlp = NULL;
	lldp_rw_unlock(&lap->la_rxmib_rwlock);
}

/*
 * This function is called after waiting for a period of time longer than the
 * longest TTL of any of the peers.
 */
static void
dcbx_mpeer_timer_cbfunc(void *args)
{
	dcbx_feature_t	*dfp = args;
	lldp_agent_t	*lap = dfp->df_la;

	lldp_mutex_lock(&dfp->df_lock);
	dfp->df_mpeer_toid = 0;
	if (dfp->df_npeer > 1) {
		/*
		 * Number of peers is still more than 1 and we have detected
		 * multi-peer condition and as per the Spec we should behave
		 * as if there is no feature TLV.
		 */
		dfp->df_mpeer_detected = B_TRUE;
	} else {
		/*
		 * the number of peers now is less than 1, so the multi-peer
		 * condition is false. We have to get the feature TLV from the
		 * only peer and process it.
		 */
		(void) nvlist_free(dfp->df_peercfg);
		dfp->df_peercfg = NULL;
		dcbx_get_feature_nvl(lap, dfp->df_ftype, &dfp->df_peercfg);
		dfp->df_mpeer_detected = B_FALSE;
	}

	dfp->df_p_dcbxupdate = B_TRUE;
	(void) pthread_cond_signal(&dfp->df_condvar);
	lldp_mutex_unlock(&dfp->df_lock);
}

/*
 * From the spec:
 *
 * DCBX is expected to operate over a point to point link. If multiple LLDP peer
 * ports running DCBX are detected, then DCBX should behave as if the peer
 * port's DCBX TLVs are not present until the multiple LLDP peer port condition
 * is no longer present. When it is detected that the number of peer ports
 * running DCBX exceeds 1 for a period longer than the longest TTL of any of the
 * peers, a multi-peer condition is detected. During the time when the
 * multi-peer condition has not been detected the DCBX data from the most recent
 * DCBX peer shall be used.
 */
void
dcbx_multi_peer(dcbx_feature_t *dfp)
{
	lldp_agent_t	*lap = dfp->df_la;
	nvlist_t	*mnvl, *fnvl;
	nvpair_t	*nvp;
	uint16_t	ttl, maxTTL = 0;
	uint_t		npeer = 0;
	struct timeval	time;

	/*
	 * Let's check if the given `lap' has more than one DCBX peer
	 * peer and if so we will get the max TTL for all of the peers
	 */
	lldp_rw_lock(&lap->la_rxmib_rwlock, LLDP_RWLOCK_READER);
	for (nvp = nvlist_next_nvpair(lap->la_remote_mib, NULL); nvp != NULL;
	    nvp = nvlist_next_nvpair(lap->la_remote_mib, nvp)) {
		if (nvpair_value_nvlist(nvp, &mnvl) == 0 &&
		    (lldp_get_nested_nvl(mnvl, LLDP_NVP_ORGANIZATION,
		    LLDP_8021_OUI_LIST, LLDP_NVP_PFC, &fnvl) == 0 ||
		    lldp_get_nested_nvl(mnvl, LLDP_NVP_ORGANIZATION,
		    LLDP_8021_OUI_LIST, LLDP_NVP_APPLN, &fnvl) == 0) &&
		    lldp_nvlist2ttl(mnvl, &ttl) == 0) {
			++npeer;
			if (ttl > maxTTL)
				maxTTL = ttl;
		}
	}
	lldp_rw_unlock(&lap->la_rxmib_rwlock);

	/*
	 * if there are multiple peers, we will add a timer that will be fired
	 * after waiting for `maxTTL' period of time. This timer will mark
	 * `df_mpeer_detected' to B_TRUE, if npeer is > 1.
	 */
	if (npeer > 1 && dfp->df_mpeer_toid == 0 && !dfp->df_mpeer_detected) {
		time.tv_sec = maxTTL;
		time.tv_usec = 0;
		dfp->df_mpeer_toid = lldp_timeout(dfp, dcbx_mpeer_timer_cbfunc,
		    &time);
	} else if (npeer == 1 && dfp->df_mpeer_detected) {
		assert(dfp->df_mpeer_toid == 0);
		dfp->df_mpeer_detected = B_FALSE;
	}
	dfp->df_npeer = npeer;
}
