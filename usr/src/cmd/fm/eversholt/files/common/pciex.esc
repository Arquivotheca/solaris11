/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright (c) 2006, 2011, Oracle and/or its affiliates. All rights reserved.
 */

#pragma dictionary "PCIEX"

#include <fm/topo_hc.h>

/*
 * FIT rates - assume leaf devices are somewhat less reliable than
 * root complexes, switches and bridges
 */
#define PCIEX_RC_FIT 500
#define PCIEX_SW_FIT 500
#define PCIEX_BDG_FIT 500
#define PCIEX_DEV_FIT 1000
#define PCIEX_RC_INV_FIT 500
#define PCIEX_DEV_INV_FIT 1000
#define PCIEX_RC_NR_FIT 500
#define PCIEX_SW_NR_FIT 500
#define PCIEX_BDG_NR_FIT 500
#define PCIEX_DEV_NR_FIT 1000
#define PCIEX_BUS_FIT 500
#define PCIEX_BUS_NR_FIT 500

/*
 * SERD parameters.
 * 
 * PCI Express correctable link errors are automatically handled by the
 * hardware, so have relatively little impact and we can allow quite a
 * high frequency. We will also be quite conservative about nonfatal internal
 * errors reported by the driver.
 *
 * Nonfatal dpe errors (ptlp/ecrc errors) have to be recovered by the hardened
 * driver which may cause intermittant performance/responsiveness problems, so
 * we have tighter serd parameters for these. These are most likely errors in
 * buffers/caches within devices and bridges, so use similar rates to cpu
 * data cache parity errors.
 */
#define CORRLINK_COUNT 6
#define CORRLINK_TIME 2h
#define BTLP_COUNT 18
#define BTLP_TIME 1h
#define BDLLP_COUNT 18
#define BDLLP_TIME 1h
#define RTO_COUNT 6
#define RTO_TIME 2h
#define RNR_COUNT 6
#define RNR_TIME 2h
#define RE_COUNT 36
#define RE_TIME 1h
#define NONFATAL_DPE_COUNT 3
#define NONFATAL_DPE_TIME 168h

/*
 * if the source-id payload is valid, then check it matches
 */
#define SOURCE_ID_MATCHES_BDF \
	(!payloadprop_defined("source-valid") || \
	payloadprop("source-valid") == 0 || \
	payloadprop("source-id") == ((b << 8) | (d << 3) | f))

#define SOURCE_ID_MATCHES_OWN_BDF \
	(payloadprop_defined("source-valid") && \
	payloadprop("source-valid") == 1 && \
	payloadprop("source-id") == (confprop(pciexrc, TOPO_PCI_BDF) + 0))

/*
 * Other useful macros. These use the EXCAP property (PCI Express Capabilities
 * register) to find the type for PCI Express devices, and the CLASS-CODE
 * property (PCI Class Code register) for to find the type of PCI devices behind
 * a PCI Express-PCI bridge - note that 60400 and 60401 are defined as PCI-PCI
 * bridges, everything else is consider a PCI leaf device.
 */
#define	PCIEXFN		pciexbus/pciexdev/pciexfn
#define	PCIEXFNHZ	pciexbus<>/pciexdev<>/pciexfn<>
#define	PCIEXFN1	pciexbus[b]/pciexdev[d]/pciexfn[f]
#define	PCIFN		pcibus/pcidev/pcifn
#define	PCIFNHZ		pcibus<>/pcidev<>/pcifn<>
#define	PCIFN1		pcibus[b]/pcidev[d]/pcifn[f]
#define IS_LF(f) 	(confprop(f, TOPO_PCI_EXCAP) == "pciexdev")
#define IS_BG(f) 	(confprop(f, TOPO_PCI_EXCAP) == "pcibus")
#define IS_SD(f)	(confprop(f, TOPO_PCI_EXCAP) == "pciexswd")
#define IS_SU(f)	(confprop(f, TOPO_PCI_EXCAP) == "pciexswu")
#define	IS_PCI_LF(f)	(confprop_defined(f, TOPO_PCI_CLASS) && \
			confprop(f, TOPO_PCI_CLASS) != "60400" && \
			confprop(f, TOPO_PCI_CLASS) != "60401")

/*
 * define faults
 */
event fault.io.pciex.fw_corrupt@PCIEXFN, FITrate=PCIEX_DEV_FIT, retire=0;
event fault.io.pciex.fw_mismatch@PCIEXFN, FITrate=PCIEX_DEV_FIT, retire=0;

event fault.io.pciex.device-interr@PCIEXFN, FITrate=PCIEX_DEV_FIT;

event fault.io.pciex.device-interr-deg@PCIEXFN, FITrate=PCIEX_DEV_FIT, retire=0;

engine serd.io.pciex.flt-nf@PCIEXFN, N=NONFATAL_DPE_COUNT, T=NONFATAL_DPE_TIME;
event fault.io.pciex.device-interr-unaf@PCIEXFN, FITrate=PCIEX_DEV_FIT,
	engine=serd.io.pciex.flt-nf@PCIEXFN;

engine serd.io.device.nonfatal@PCIEXFN, N=CORRLINK_COUNT, T=CORRLINK_TIME;
event fault.io.pciex.device-interr-corr@PCIEXFN, FITrate=PCIEX_DEV_FIT,
	engine=serd.io.device.nonfatal@PCIEXFN;
engine serd.io.device.nonfatal@PCIEXFN/PCIEXFN,
	N=CORRLINK_COUNT, T=CORRLINK_TIME;
event fault.io.pciex.device-interr-corr@PCIEXFN/PCIEXFN, FITrate=PCIEX_DEV_FIT,
	engine=serd.io.device.nonfatal@PCIEXFN/PCIEXFN;
engine serd.io.device.nonfatal@pciexrc/PCIEXFN,
	N=CORRLINK_COUNT, T=CORRLINK_TIME;
event fault.io.pciex.device-interr-corr@pciexrc/PCIEXFN, FITrate=PCIEX_DEV_FIT,
	engine=serd.io.device.nonfatal@pciexrc/PCIEXFN;

event fault.io.pciex.device-interr@pciexrc, FITrate=PCIEX_RC_FIT;

event fault.io.pciex.device-interr-deg@pciexrc, FITrate=PCIEX_RC_FIT, retire=0;

engine serd.io.pciex.flt-nf@pciexrc, N=NONFATAL_DPE_COUNT, T=NONFATAL_DPE_TIME;
event fault.io.pciex.device-interr-unaf@pciexrc, FITrate=PCIEX_RC_FIT,
	engine=serd.io.pciex.flt-nf@pciexrc;

engine serd.io.device.nonfatal@pciexrc, N=CORRLINK_COUNT, T=CORRLINK_TIME;
event fault.io.pciex.device-interr-corr@pciexrc, FITrate=PCIEX_RC_FIT,
	engine=serd.io.device.nonfatal@pciexrc;

event fault.io.pciex.device-invreq@PCIEXFN, FITrate=PCIEX_DEV_INV_FIT;

event fault.io.pciex.device-invreq@pciexrc, FITrate=PCIEX_RC_FIT;

event fault.io.pciex.device-noresp@PCIEXFN, FITrate=PCIEX_DEV_NR_FIT;

event fault.io.pciex.device-noresp@pciexrc, FITrate=PCIEX_RC_NR_FIT;

event fault.io.pciex.bus-noresp@PCIEXFN, FITrate=PCIEX_BUS_NR_FIT;

event fault.io.pciex.bus-linkerr@PCIEXFN, FITrate=PCIEX_BUS_FIT;

engine serd.io.pciex.corrlink-bus@pciexrc/PCIEXFN,
	N=CORRLINK_COUNT, T=CORRLINK_TIME;
event fault.io.pciex.bus-linkerr-corr@pciexrc/PCIEXFN, FITrate=PCIEX_BUS_FIT,
	engine=serd.io.pciex.corrlink-bus@pciexrc/PCIEXFN;
engine serd.io.pciex.corrlink-bus@PCIEXFN/PCIEXFN,
	N=CORRLINK_COUNT, T=CORRLINK_TIME;
event fault.io.pciex.bus-linkerr-corr@PCIEXFN/PCIEXFN, FITrate=PCIEX_BUS_FIT,
	engine=serd.io.pciex.corrlink-bus@PCIEXFN/PCIEXFN;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Handling of leaf driver detected internal errors. Use serd engine if
 * no service impact - otherwise fail immediately
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event ereport.io.device.inval_state@PCIEXFN{within(5s)};
event ereport.io.device.no_response@PCIEXFN{within(5s)};
event ereport.io.device.stall@PCIEXFN{within(5s)};
event ereport.io.device.badint_limit@PCIEXFN{within(5s)};
event ereport.io.device.intern_corr@PCIEXFN{within(5s)};
event ereport.io.device.intern_uncorr@PCIEXFN{within(5s)};
event ereport.io.service.lost@PCIEXFN{within(5s)};
event ereport.io.service.degraded@PCIEXFN{within(5s)};
event ereport.io.service.unaffected@PCIEXFN{within(5s)};
event ereport.io.service.restored@PCIEXFN{within(30s)};
event ereport.io.service.lost@PCIFN{within(5s)};
event ereport.io.service.degraded@PCIFN{within(5s)};
event ereport.io.service.unaffected@PCIFN{within(5s)};

event error.io.pciex.noimpact-d@PCIEXFN;
event error.io.pciex.degraded-d@PCIEXFN;
event error.io.pciex.lost-d@PCIEXFN;
event error.io.service.restored@PCIEXFN;
event error.io.service.restored@PCIFN;
event error.io.device.nf-device@PCIEXFN;
event error.io.device.deg-device@PCIEXFN;
event error.io.device.f-device@PCIEXFN;

prop error.io.device.f-device@PCIEXFN (1)->
    ereport.io.device.inval_state@PCIEXFN,
    ereport.io.device.no_response@PCIEXFN,
    ereport.io.device.stall@PCIEXFN,
    ereport.io.device.badint_limit@PCIEXFN,
    ereport.io.device.intern_corr@PCIEXFN,
    ereport.io.device.intern_uncorr@PCIEXFN;

prop error.io.device.f-device@PCIEXFN (0)->
    error.io.pciex.lost-d@PCIEXFN;

prop error.io.device.deg-device@PCIEXFN (1)->
    ereport.io.device.inval_state@PCIEXFN,
    ereport.io.device.no_response@PCIEXFN,
    ereport.io.device.stall@PCIEXFN,
    ereport.io.device.badint_limit@PCIEXFN,
    ereport.io.device.intern_corr@PCIEXFN,
    ereport.io.device.intern_uncorr@PCIEXFN;

prop error.io.device.deg-device@PCIEXFN (1)->
    error.io.pciex.degraded-d@PCIEXFN;

prop error.io.device.nf-device@PCIEXFN (1)->
    ereport.io.device.inval_state@PCIEXFN,
    ereport.io.device.no_response@PCIEXFN,
    ereport.io.device.stall@PCIEXFN,
    ereport.io.device.badint_limit@PCIEXFN,
    ereport.io.device.intern_corr@PCIEXFN,
    ereport.io.device.intern_uncorr@PCIEXFN;

prop error.io.device.nf-device@PCIEXFN (1)->
    error.io.pciex.noimpact-d@PCIEXFN;

/*
 * handling of service impact ereports.
 */
prop error.io.pciex.lost-d@PCIEXFN (1)->
    ereport.io.service.lost@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    ereport.io.service.lost@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) };

prop error.io.pciex.lost-d@PCIEXFN (0)->
    ereport.io.service.unaffected@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    ereport.io.service.unaffected@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) },
    ereport.io.service.degraded@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    ereport.io.service.degraded@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) };

prop error.io.pciex.degraded-d@PCIEXFN (1)->
    ereport.io.service.degraded@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    ereport.io.service.degraded@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) };

prop error.io.pciex.degraded-d@PCIEXFN (0)->
    ereport.io.service.unaffected@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    ereport.io.service.unaffected@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) };

prop error.io.pciex.noimpact-d@PCIEXFN (1)->
    ereport.io.service.unaffected@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    ereport.io.service.unaffected@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) },
    error.io.service.restored@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    error.io.service.restored@PCIFNHZ { is_under(PCIEXFN, PCIFNHZ) };

prop error.io.service.restored@PCIEXFN (1)->
    ereport.io.service.lost@PCIEXFN,
    ereport.io.service.degraded@PCIEXFN;

prop error.io.service.restored@PCIEXFN (1)->
    ereport.io.service.restored@PCIEXFN;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCI Express hostbridge (root complex) may cause:
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - nr-d:		the device not to respond to a valid upstream request
 * - ca-d:		the device to completer abort a valid upstream request
 * - mtlp-d:		a malformed tlp to be transmitted downstream
 * - badreq-d:		a bad downstream request - not CRC error (may cause
 *			completer to respond with ur or ca)
 * - ecrcreq-d:		TLP with end-to-end CRC error transmitted downstream
 * - ecrccomp-d:	TLP with end-to-end CRC error transmitted downstream
 * - poisreq-d:		poisoned request transmitted downstream
 * - poiscomp-d:	poisoned completion transmitted downstream
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */
event error.io.pciex.nr-d@pciexrc/PCIEXFN;
event error.io.pciex.ca-d@pciexrc/PCIEXFN;
event error.io.pciex.mtlp-d@pciexrc/PCIEXFN;
event error.io.pciex.fatlink@pciexrc/PCIEXFN;
event error.io.pciex.badreq-d@pciexrc/PCIEXFN;
event error.io.pciex.nf-poisecrc-d@pciexrc/PCIEXFN;
event error.io.pciex.f-poisecrc-d@pciexrc/PCIEXFN;
event error.io.pciex.deg-poisecrc-d@pciexrc/PCIEXFN;
event ereport.io.pciex.dl.btlp@pciexrc{within(5s)};
event ereport.io.pciex.dl.bdllp@pciexrc{within(5s)};
event ereport.io.pciex.dl.rto@pciexrc{within(5s)};
event ereport.io.pciex.dl.rnr@pciexrc{within(5s)};
event ereport.io.pciex.pl.re@pciexrc{within(5s)};
event ereport.io.pciex.dl.btlp@pciexrc/PCIEXFN{within(5s)};
event ereport.io.pciex.dl.bdllp@pciexrc/PCIEXFN{within(5s)};
event ereport.io.pciex.dl.rto@pciexrc/PCIEXFN{within(5s)};
event ereport.io.pciex.dl.rnr@pciexrc/PCIEXFN{within(5s)};
event ereport.io.pciex.pl.re@pciexrc/PCIEXFN{within(5s)};

prop fault.io.pciex.device-noresp@pciexrc (1)->
    error.io.pciex.nr-d@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-invreq@pciexrc (1)->
    error.io.pciex.badreq-d@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc {
    payloadprop_defined("detector") && setserdsuffix("_btlp") &&
    setserdn(BTLP_COUNT) && setserdt(BTLP_TIME) } (0)->
    ereport.io.pciex.dl.btlp@pciexrc,
    ereport.io.pciex.dl.btlp@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc {
    payloadprop_defined("detector") && setserdsuffix("_bdllp") &&
    setserdn(BDLLP_COUNT) && setserdt(BDLLP_TIME) } (0)->
    ereport.io.pciex.dl.bdllp@pciexrc,
    ereport.io.pciex.dl.bdllp@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc {
    payloadprop_defined("detector") && setserdsuffix("_rto") &&
    setserdn(RTO_COUNT) && setserdt(RTO_TIME) } (0)->
    ereport.io.pciex.dl.rto@pciexrc,
    ereport.io.pciex.dl.rto@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc {
    payloadprop_defined("detector") && setserdsuffix("_rnr") &&
    setserdn(RNR_COUNT) && setserdt(RNR_TIME) } (0)->
    ereport.io.pciex.dl.rnr@pciexrc,
    ereport.io.pciex.dl.rnr@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc {
    payloadprop_defined("detector") && setserdsuffix("_re") &&
    setserdn(RE_COUNT) && setserdt(RE_TIME) } (0)->
    ereport.io.pciex.pl.re@pciexrc,
    ereport.io.pciex.pl.re@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-unaf@pciexrc (1)->
    error.io.pciex.nf-poisecrc-d@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-deg@pciexrc (1)->
    error.io.pciex.deg-poisecrc-d@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr@pciexrc (1)->
    error.io.pciex.f-poisecrc-d@pciexrc/PCIEXFNHZ,
    error.io.pciex.ca-d@pciexrc/PCIEXFNHZ,
    error.io.pciex.mtlp-d@pciexrc/PCIEXFNHZ,
    error.io.pciex.fatlink@pciexrc/PCIEXFNHZ;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCI Express leaf device or upstream switch port may cause:
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - flt-nr-u:		the device not to respond to a valid downstream request
 * - flt-ca-u:		the device to completer abort a valid downstream request
 * - flt-badreq-u:	a bad upstream request - not CRC error (may cause
 *			completer to respond with ur or ca) - leaf only
 * - flt-mtlp-u:	a malformed tlp transmitted upstream - leaf only
 * - flt-ecrcreq-u:	request with end-to-end CRC error transmitted upstream
 * - flt-ecrccomp-u:	compl with end-to-end CRC error transmitted upstream
 * - flt-poisreq-u:	poisoned request transmitted upstream
 * - flt-poiscomp-u:	poisoned completion transmitted upstream
 * - device:		internal error reported by leaf device
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */

event error.io.pciex.flt-nr-u@PCIEXFN;
event error.io.pciex.flt-ca-u@PCIEXFN;
event error.io.pciex.flt-mtlp-u@PCIEXFN;
event error.io.pciex.fatlink@PCIEXFN;
event error.io.pciex.device-msg-storm@PCIEXFN;	
event error.io.pciex.flt-badreq-u@PCIEXFN;
event error.io.pciex.flt-nf-poisecrc-u@PCIEXFN;
event error.io.pciex.flt-f-poisecrc-u@PCIEXFN;
event error.io.pciex.flt-deg-poisecrc-u@PCIEXFN;
event ereport.io.pciex.dl.btlp@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.bdllp@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.rto@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.rnr@PCIEXFN{within(5s)};
event ereport.io.pciex.pl.re@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.btlp@PCIEXFN/PCIEXFN{within(5s)};
event ereport.io.pciex.dl.bdllp@PCIEXFN/PCIEXFN{within(5s)};
event ereport.io.pciex.dl.rto@PCIEXFN/PCIEXFN{within(5s)};
event ereport.io.pciex.dl.rnr@PCIEXFN/PCIEXFN{within(5s)};
event ereport.io.pciex.pl.re@PCIEXFN/PCIEXFN{within(5s)};
event ereport.io.device.fw_corrupt@PCIEXFN{within(5s)};
event ereport.io.device.fw_mismatch@PCIEXFN{within(5s)};

prop fault.io.pciex.device-noresp@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.flt-nr-u@PCIEXFN;

prop fault.io.pciex.device-noresp@PCIEXFN { IS_SU(PCIEXFN) } (1)->
    error.io.pciex.flt-nr-u@PCIEXFN;

prop fault.io.pciex.device-invreq@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.flt-badreq-u@PCIEXFN;

prop fault.io.pciex.device-interr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_btlp") &&
    setserdn(BTLP_COUNT) && setserdt(BTLP_TIME) } (0)->
    ereport.io.pciex.dl.btlp@pciexrc,
    ereport.io.pciex.dl.btlp@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_bdllp") &&
    setserdn(BDLLP_COUNT) && setserdt(BDLLP_TIME) } (0)->
    ereport.io.pciex.dl.bdllp@pciexrc,
    ereport.io.pciex.dl.bdllp@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_rto") &&
    setserdn(RTO_COUNT) && setserdt(RTO_TIME) } (0)->
    ereport.io.pciex.dl.rto@pciexrc,
    ereport.io.pciex.dl.rto@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_rnr") &&
    setserdn(RNR_COUNT) && setserdt(RNR_TIME) } (0)->
    ereport.io.pciex.dl.rnr@pciexrc,
    ereport.io.pciex.dl.rnr@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_re") &&
    setserdn(RE_COUNT) && setserdt(RE_TIME) } (0)->
    ereport.io.pciex.pl.re@pciexrc,
    ereport.io.pciex.pl.re@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_btlp") &&
    setserdn(BTLP_COUNT) && setserdt(BTLP_TIME) } (0)->
    ereport.io.pciex.dl.btlp@PCIEXFN,
    ereport.io.pciex.dl.btlp@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_bdllp") &&
    setserdn(BDLLP_COUNT) && setserdt(BDLLP_TIME) } (0)->
    ereport.io.pciex.dl.bdllp@PCIEXFN,
    ereport.io.pciex.dl.bdllp@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_rto") &&
    setserdn(RTO_COUNT) && setserdt(RTO_TIME) } (0)->
    ereport.io.pciex.dl.rto@PCIEXFN,
    ereport.io.pciex.dl.rto@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_rnr") &&
    setserdn(RNR_COUNT) && setserdt(RNR_TIME) } (0)->
    ereport.io.pciex.dl.rnr@PCIEXFN,
    ereport.io.pciex.dl.rnr@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_re") &&
    setserdn(RE_COUNT) && setserdt(RE_TIME) } (0)->
    ereport.io.pciex.pl.re@PCIEXFN,
    ereport.io.pciex.pl.re@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-unaf@PCIEXFN { IS_SU(PCIEXFN) } (1)->
    error.io.pciex.flt-nf-poisecrc-u@PCIEXFN;

prop fault.io.pciex.device-interr-corr@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    error.io.device.nf-device@PCIEXFN;

prop fault.io.pciex.device-interr-unaf@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.flt-nf-poisecrc-u@PCIEXFN;

prop fault.io.pciex.device-interr-deg@PCIEXFN { IS_SU(PCIEXFN) } (1)->
    error.io.pciex.flt-deg-poisecrc-u@PCIEXFN;

prop fault.io.pciex.device-interr@PCIEXFN { IS_SU(PCIEXFN) } (1)->
    error.io.pciex.flt-f-poisecrc-u@PCIEXFN,
    error.io.pciex.flt-ca-u@PCIEXFN,
    error.io.pciex.flt-mtlp-u@PCIEXFN,
    error.io.pciex.fatlink@PCIEXFN;

prop fault.io.pciex.device-interr-deg@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.flt-deg-poisecrc-u@PCIEXFN,
    error.io.device.deg-device@PCIEXFN;

prop fault.io.pciex.device-interr@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.flt-f-poisecrc-u@PCIEXFN,
    error.io.device.f-device@PCIEXFN,
    error.io.pciex.flt-ca-u@PCIEXFN,
    error.io.pciex.flt-mtlp-u@PCIEXFN,
    error.io.pciex.fatlink@PCIEXFN,
    error.io.pciex.device-msg-storm@PCIEXFN;	

prop fault.io.pciex.fw_corrupt@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    ereport.io.device.fw_corrupt@PCIEXFN;

prop fault.io.pciex.fw_corrupt@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.service.lost@PCIEXFN,
    ereport.io.service.degraded@PCIEXFN;

prop fault.io.pciex.fw_mismatch@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    ereport.io.device.fw_mismatch@PCIEXFN;

prop fault.io.pciex.fw_mismatch@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.service.lost@PCIEXFN,
    ereport.io.service.degraded@PCIEXFN;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCI Express downstream switch port may cause
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - nr-d:		the device not to respond to an upstream request
 * - ca-d:		the device to completer abort an upstream request
 * - ecrcreq-d:		TLP with end-to-end CRC error transmitted upstream
 * - ecrccomp-d:	TLP with end-to-end CRC error transmitted upstream
 * - poisreq-d:		poisoned request transmitted upstream
 * - poiscomp-d:	poisoned completion transmitted upstream
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */

event error.io.pciex.nr-d@PCIEXFN/PCIEXFN;
event error.io.pciex.ca-d@PCIEXFN/PCIEXFN;
event error.io.pciex.fatlink@PCIEXFN/PCIEXFN;
event error.io.pciex.mtlp-d@PCIEXFN/PCIEXFN;
event error.io.pciex.nf-poisecrc-d@PCIEXFN/PCIEXFN;
event error.io.pciex.f-poisecrc-d@PCIEXFN/PCIEXFN;
event error.io.pciex.deg-poisecrc-d@PCIEXFN/PCIEXFN;

prop fault.io.pciex.device-noresp@PCIEXFN { IS_SD(PCIEXFN) } (1)->
    error.io.pciex.nr-d@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN { IS_SD(PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_btlp") &&
    setserdn(BTLP_COUNT) && setserdt(BTLP_TIME) } (0)->
    ereport.io.pciex.dl.btlp@PCIEXFN,
    ereport.io.pciex.dl.btlp@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN { IS_SD(PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_bdllp") &&
    setserdn(BDLLP_COUNT) && setserdt(BDLLP_TIME) } (0)->
    ereport.io.pciex.dl.bdllp@PCIEXFN,
    ereport.io.pciex.dl.bdllp@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN { IS_SD(PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_rto") &&
    setserdn(RTO_COUNT) && setserdt(RTO_TIME) } (0)->
    ereport.io.pciex.dl.rto@PCIEXFN,
    ereport.io.pciex.dl.rto@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN { IS_SD(PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_rnr") &&
    setserdn(RNR_COUNT) && setserdt(RNR_TIME) } (0)->
    ereport.io.pciex.dl.rnr@PCIEXFN,
    ereport.io.pciex.dl.rnr@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-corr@PCIEXFN { IS_SD(PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_re") &&
    setserdn(RE_COUNT) && setserdt(RE_TIME) } (0)->
    ereport.io.pciex.pl.re@PCIEXFN,
    ereport.io.pciex.pl.re@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-unaf@PCIEXFN { IS_SD(PCIEXFN) } (1)->
    error.io.pciex.nf-poisecrc-d@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr-deg@PCIEXFN { IS_SD(PCIEXFN) } (1)->
    error.io.pciex.deg-poisecrc-d@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.device-interr@PCIEXFN { IS_SD(PCIEXFN) } (1)->
    error.io.pciex.ca-d@PCIEXFN/PCIEXFNHZ,
    error.io.pciex.f-poisecrc-d@PCIEXFN/PCIEXFNHZ,
    error.io.pciex.mtlp-d@PCIEXFN/PCIEXFNHZ,
    error.io.pciex.fatlink@PCIEXFN/PCIEXFNHZ;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCIEX bus may cause:
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - flt-nr-u:		a device to not respond because the link is down
 * - nr-d:		a device to not respond because the link is down
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */

event error.io.pciex.nr-d@PCIEXFN;
event error.io.pciex.mtlp-d@PCIEXFN;

prop fault.io.pciex.bus-noresp@PCIEXFN { !IS_SD(PCIEXFN) } (0)->
    error.io.pciex.flt-nr-u@PCIEXFN,
    error.io.pciex.nr-d@PCIEXFN;

prop fault.io.pciex.bus-linkerr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_btlp") &&
    setserdn(BTLP_COUNT) && setserdt(BTLP_TIME) } (0)->
    ereport.io.pciex.dl.btlp@PCIEXFN,
    ereport.io.pciex.dl.btlp@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_bdllp") &&
    setserdn(BDLLP_COUNT) && setserdt(BDLLP_TIME) } (0)->
    ereport.io.pciex.dl.bdllp@PCIEXFN,
    ereport.io.pciex.dl.bdllp@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_rto") &&
    setserdn(RTO_COUNT) && setserdt(RTO_TIME) } (0)->
    ereport.io.pciex.dl.rto@PCIEXFN,
    ereport.io.pciex.dl.rto@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_rnr") &&
    setserdn(RNR_COUNT) && setserdt(RNR_TIME) } (0)->
    ereport.io.pciex.dl.rnr@PCIEXFN,
    ereport.io.pciex.dl.rnr@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@PCIEXFN/PCIEXFN {
    !IS_SD(PCIEXFN/PCIEXFN) &&
    payloadprop_defined("detector") && setserdsuffix("_re") &&
    setserdn(RE_COUNT) && setserdt(RE_TIME) } (0)->
    ereport.io.pciex.pl.re@PCIEXFN,
    ereport.io.pciex.pl.re@PCIEXFN/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_btlp") &&
    setserdn(BTLP_COUNT) && setserdt(BTLP_TIME) } (0)->
    ereport.io.pciex.dl.btlp@pciexrc,
    ereport.io.pciex.dl.btlp@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_bdllp") &&
    setserdn(BDLLP_COUNT) && setserdt(BDLLP_TIME) } (0)->
    ereport.io.pciex.dl.bdllp@pciexrc,
    ereport.io.pciex.dl.bdllp@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_rto") &&
    setserdn(RTO_COUNT) && setserdt(RTO_TIME) } (0)->
    ereport.io.pciex.dl.rto@pciexrc,
    ereport.io.pciex.dl.rto@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_rnr") &&
    setserdn(RNR_COUNT) && setserdt(RNR_TIME) } (0)->
    ereport.io.pciex.dl.rnr@pciexrc,
    ereport.io.pciex.dl.rnr@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr-corr@pciexrc/PCIEXFN {
    payloadprop_defined("detector") && setserdsuffix("_re") &&
    setserdn(RE_COUNT) && setserdt(RE_TIME) } (0)->
    ereport.io.pciex.pl.re@pciexrc,
    ereport.io.pciex.pl.re@pciexrc/PCIEXFNHZ;

prop fault.io.pciex.bus-linkerr@PCIEXFN { !IS_SD(PCIEXFN) } (0)->
    error.io.pciex.flt-mtlp-u@PCIEXFN,
    error.io.pciex.mtlp-d@PCIEXFN,
    error.io.pciex.fatlink@PCIEXFN;

/*
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty pciex-pci bridge may cause
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * The following errors to propagate onto the PCI Express fabric
 * - flt-nr-u:		the device not to respond to a valid downstream request
 * - flt-ca-u:		the device to completer abort a valid downstream request
 * - flt-ecrcreq-u:	request with end-to-end CRC error transmitted upstream
 * - flt-ecrccomp-u:	compl with end-to-end CRC error transmitted upstream
 * - flt-poisreq-u:	poisoned request transmitted upstream
 * - flt-poiscomp-u:	poisoned completion transmitted upstream
 * - corrlink:		correctable link or physical level error upstream
 * - fatlink:		fatal link or physical level error upstream
 * - sec-interr:	internal error on pci express to pci bridge
 *
 * And the following errors to propagate onto the secondary pci or pci/x bus
 * (these will be handled by code in the pci.esc file).
 * - nr-pw-d:		the device not to respond to a valid upstream request
 * - nr-drw-d:		the device not to respond to a valid upstream request
 * - retry-to-d:	failure to retry an downstream delayed request
 * - ta-pw-d:		the device responds with a ta to a valid upstream
 *			request
 * - ta-drw-d:		the device responds with a ta to a valid upstream
 *			request
 * - ape-d:	address/parity to get corrupted during downstream transmission.
 * - dpe-d:	data/parity to get corrupted during downstream transmission.
 * - scpe-d:	split completion to get corrupted during downstream transmission
 */

event error.io.pci.ape-d@PCIEXFN/PCIFN;
event error.io.pci.f-dpe-d@PCIEXFN/PCIFN;
event error.io.pci.deg-dpe-d@PCIEXFN/PCIFN;
event error.io.pci.nf-dpe-d@PCIEXFN/PCIFN;
event error.io.pci.retry-to-d@PCIEXFN/PCIFN;
event error.io.pci.nr-pw-d@PCIEXFN/PCIFN;
event error.io.pci.nr-drw-d@PCIEXFN/PCIFN;
event error.io.pci.ta-pw-d@PCIEXFN/PCIFN;
event error.io.pci.ta-drw-d@PCIEXFN/PCIFN;
event error.io.pcix.scpe-d@PCIEXFN/PCIFN;
event error.io.pciex.sec-interr@PCIEXFN;
event ereport.io.pci.sec-sta@PCIEXFN{within(5s)};

prop fault.io.pciex.device-noresp@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    error.io.pciex.flt-nr-u@PCIEXFN,
    error.io.pci.retry-to-d@PCIEXFN/PCIFNHZ,
    error.io.pci.nr-pw-d@PCIEXFN/PCIFNHZ,
    error.io.pci.nr-drw-d@PCIEXFN/PCIFNHZ;

prop fault.io.pciex.device-interr-unaf@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    error.io.pciex.flt-nf-poisecrc-u@PCIEXFN,
    error.io.pci.nf-dpe-d@PCIEXFN/PCIFNHZ;

prop fault.io.pciex.device-interr-deg@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    error.io.pciex.flt-deg-poisecrc-u@PCIEXFN,
    error.io.pci.deg-dpe-d@PCIEXFN/PCIFNHZ;

prop fault.io.pciex.device-interr@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    error.io.pciex.flt-f-poisecrc-u@PCIEXFN,
    error.io.pciex.flt-ca-u@PCIEXFN,
    error.io.pciex.flt-mtlp-u@PCIEXFN,
    error.io.pciex.sec-interr@PCIEXFN,
    error.io.pciex.fatlink@PCIEXFN,
    error.io.pci.ta-pw-d@PCIEXFN/PCIFNHZ,
    error.io.pci.ta-drw-d@PCIEXFN/PCIFNHZ,
    error.io.pci.ape-d@PCIEXFN/PCIFNHZ,
    error.io.pcix.scpe-d@PCIEXFN/PCIFNHZ,
    error.io.pci.f-dpe-d@PCIEXFN/PCIFNHZ;

prop fault.io.pciex.device-interr-unaf@PCIEXFN { IS_BG(PCIEXFN) } (0)->
    ereport.io.pci.sec-sta@PCIEXFN;

prop fault.io.pciex.device-interr@PCIEXFN { IS_BG(PCIEXFN) } (0)->
    ereport.io.pci.sec-sta@PCIEXFN;

/*
 * the following rules for ptlp and ecrc faults are split into fatal and
 * nonfatal, depending on the service impact reported by the leaf driver
 */
event error.io.pciex.nf-poisecrc-d@PCIEXFN;
event error.io.pciex.deg-poisecrc-d@PCIEXFN;
event error.io.pciex.f-poisecrc-d@PCIEXFN;
event error.io.pciex.ecrcreq-d@PCIEXFN;
event error.io.pciex.ecrccomp-d@PCIEXFN;
event error.io.pciex.poisreq-d@PCIEXFN;
event error.io.pciex.poiscomp-d@PCIEXFN;
event error.io.pciex.flt-poisreq-u@PCIEXFN;
event error.io.pciex.flt-poiscomp-u@PCIEXFN;
event error.io.pciex.flt-ecrcreq-u@PCIEXFN;
event error.io.pciex.flt-ecrccomp-u@PCIEXFN;

prop error.io.pciex.nf-poisecrc-d@PCIEXFN (1)->
    error.io.pciex.ecrcreq-d@PCIEXFN,
    error.io.pciex.ecrccomp-d@PCIEXFN,
    error.io.pciex.poisreq-d@PCIEXFN,
    error.io.pciex.poiscomp-d@PCIEXFN;

prop error.io.pciex.nf-poisecrc-d@PCIEXFN (1)->
    error.io.pciex.noimpact-d@PCIEXFN;

prop error.io.pciex.f-poisecrc-d@PCIEXFN (1)->
    error.io.pciex.ecrcreq-d@PCIEXFN,
    error.io.pciex.ecrccomp-d@PCIEXFN,
    error.io.pciex.poisreq-d@PCIEXFN,
    error.io.pciex.poiscomp-d@PCIEXFN;

prop error.io.pciex.f-poisecrc-d@PCIEXFN (0)->
    error.io.pciex.lost-d@PCIEXFN;

prop error.io.pciex.deg-poisecrc-d@PCIEXFN (1)->
    error.io.pciex.ecrcreq-d@PCIEXFN,
    error.io.pciex.ecrccomp-d@PCIEXFN,
    error.io.pciex.poisreq-d@PCIEXFN,
    error.io.pciex.poiscomp-d@PCIEXFN;

prop error.io.pciex.deg-poisecrc-d@PCIEXFN (1)->
    error.io.pciex.degraded-d@PCIEXFN;

prop error.io.pciex.flt-nf-poisecrc-u@PCIEXFN (1)->
    error.io.pciex.flt-ecrcreq-u@PCIEXFN,
    error.io.pciex.flt-ecrccomp-u@PCIEXFN,
    error.io.pciex.flt-poisreq-u@PCIEXFN,
    error.io.pciex.flt-poiscomp-u@PCIEXFN;

prop error.io.pciex.flt-nf-poisecrc-u@PCIEXFN (1)->
    error.io.pciex.noimpact-d@PCIEXFN;

prop error.io.pciex.flt-deg-poisecrc-u@PCIEXFN (1)->
    error.io.pciex.flt-ecrcreq-u@PCIEXFN,
    error.io.pciex.flt-ecrccomp-u@PCIEXFN,
    error.io.pciex.flt-poisreq-u@PCIEXFN,
    error.io.pciex.flt-poiscomp-u@PCIEXFN;

prop error.io.pciex.flt-deg-poisecrc-u@PCIEXFN (1)->
    error.io.pciex.degraded-d@PCIEXFN;

prop error.io.pciex.flt-f-poisecrc-u@PCIEXFN (1)->
    error.io.pciex.flt-ecrcreq-u@PCIEXFN,
    error.io.pciex.flt-ecrccomp-u@PCIEXFN,
    error.io.pciex.flt-poisreq-u@PCIEXFN,
    error.io.pciex.flt-poiscomp-u@PCIEXFN;

prop error.io.pciex.flt-f-poisecrc-u@PCIEXFN (0)->
    error.io.pciex.lost-d@PCIEXFN;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * declarations
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event error.io.pciex.fatal@PCIEXFN;
event error.io.pciex.nonfatal@PCIEXFN;
event error.io.pciex.nr-fwd-d@PCIEXFN;
event error.io.pciex.mtlp-fwd-d@PCIEXFN;
event error.io.pciex.flt-ur-u@PCIEXFN;
event error.io.pciex.ca-d@PCIEXFN;
event error.io.pciex.ca-fwd-d@PCIEXFN;
event error.io.pciex.poisreq-fwd-d@PCIEXFN;
event error.io.pciex.poisreq-fwd-d@pciexrc/PCIEXFN;
event error.io.pciex.poisreq-fwd-d@PCIEXFN/PCIEXFN;
event error.io.pciex.poiscomp-fwd-d@PCIEXFN;
event error.io.pciex.poiscomp-fwd-d@PCIEXFN/PCIEXFN;
event error.io.pciex.ecrcreq-fwd-d@PCIEXFN;
event error.io.pciex.ecrccomp-fwd-d@PCIEXFN;
event error.io.pciex.source-ecrcreq-u@PCIEXFN;
event error.io.pciex.source-ecrccomp-u@PCIEXFN;
event error.io.pciex.source-poiscomp-u@PCIEXFN;
event error.io.pciex.source-poisreq-u@PCIEXFN;
event error.io.pciex.badreq-d@PCIEXFN;
event error.io.pci.badreq-pw-d@PCIEXFN/PCIFN;
event error.io.pci.badreq-drw-d@PCIEXFN/PCIFN;
event error.io.pci.target-ma-d@PCIEXFN;
event error.io.pci.target-rta-d@PCIEXFN;
event error.io.pci.dpdata-pw-d@PCIEXFN/PCIFN;
event error.io.pci.dpdata-dw-d@PCIEXFN/PCIFN;
event error.io.pci.dpdata-dr-d@PCIEXFN/PCIFN;
event error.io.pciex.ca-u@PCIEXFN;
event error.io.pciex.ca-u@PCIEXFN/PCIEXFN;
event error.io.pciex.ca-u@pciexrc/PCIEXFN;
event error.io.pciex.ur-u@PCIEXFN;
event error.io.pciex.ur-u@PCIEXFN/PCIEXFN;
event error.io.pciex.ur-u@pciexrc/PCIEXFN;
event error.io.pciex.nr-u@PCIEXFN;
event error.io.pciex.nr-u@PCIEXFN/PCIEXFN;
event error.io.pciex.nr-u@pciexrc/PCIEXFN;
event error.io.pciex.mtlp-u@PCIEXFN;
event error.io.pciex.mtlp-u@PCIEXFN/PCIEXFN;
event error.io.pciex.mtlp-u@pciexrc/PCIEXFN;
event error.io.pciex.badreq-u@PCIEXFN;
event error.io.pciex.badreq-u@PCIEXFN/PCIEXFN;
event error.io.pciex.badreq-u@pciexrc/PCIEXFN;
event error.io.pciex.poisreq-u@PCIEXFN;
event error.io.pciex.poisreq-u@PCIEXFN/PCIEXFN;
event error.io.pciex.poisreq-u@pciexrc/PCIEXFN;
event error.io.pciex.poiscomp-u@PCIEXFN;
event error.io.pciex.poiscomp-u@PCIEXFN/PCIEXFN;
event error.io.pciex.poiscomp-u@pciexrc/PCIEXFN;
event error.io.pciex.ecrcreq-u@PCIEXFN;
event error.io.pciex.ecrcreq-u@PCIEXFN/PCIEXFN;
event error.io.pciex.ecrccomp-u@PCIEXFN;
event error.io.pciex.ecrccomp-u@PCIEXFN/PCIEXFN;

event ereport.io.pci.ma@PCIEXFN{within(5s)};
event ereport.io.pci.mdpe@PCIEXFN{within(5s)};
event ereport.io.pci.dpe@PCIEXFN{within(5s)};
event ereport.io.pci.rta@PCIEXFN{within(5s)};
event ereport.io.pci.sta@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.dllp@PCIEXFN{within(5s)};
event ereport.io.pciex.pl.te@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.sd@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.fcp@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.rof@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.mtlp@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.ur@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.ca@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.ptlp@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.ecrc@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.uc@PCIEXFN{within(5s)};
event ereport.io.pciex.tl.cto@PCIEXFN{within(5s)};
event ereport.io.pciex.dl.dllp@pciexrc{within(5s)};
event ereport.io.pciex.pl.te@pciexrc{within(5s)};
event ereport.io.pciex.dl.sd@pciexrc{within(5s)};
event ereport.io.pciex.tl.fcp@pciexrc{within(5s)};
event ereport.io.pciex.tl.rof@pciexrc{within(5s)};
event ereport.io.pciex.tl.mtlp@pciexrc{within(5s)};
event ereport.io.pciex.tl.ur@pciexrc{within(5s)};
event ereport.io.pciex.tl.ca@pciexrc{within(5s)};
event ereport.io.pciex.tl.ptlp@pciexrc{within(5s)};
event ereport.io.pciex.tl.ecrc@pciexrc{within(5s)};
event ereport.io.pciex.tl.cto@pciexrc{within(5s)};
event ereport.io.pci.sec-ma@pciexrc{within(5s)};
event ereport.io.pci.sec-mdpe@pciexrc{within(5s)};
event ereport.io.pci.sec-dpe@pciexrc{within(5s)};
event ereport.io.pci.sec-rta@pciexrc{within(5s)};
event ereport.io.pci.sec-sta@pciexrc{within(5s)};
event ereport.io.pci.sec-mdpe@PCIEXFN{within(5s)};
event ereport.io.pci.sec-dpe@PCIEXFN{within(5s)};
event ereport.io.pci.sec-rserr@PCIEXFN{within(5s)};
event ereport.io.pci.sserr@PCIEXFN{within(5s)};
event ereport.io.pci.sec-rserr@pciexrc{within(5s)};
event ereport.io.pciex.rc.fe-msg@pciexrc{within(5s)};
event ereport.io.pciex.rc.nfe-msg@pciexrc{within(5s)};
event ereport.io.pciex.rc.mue-msg@pciexrc{within(5s)};
event ereport.io.pciex.bdg.sec-interr@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-ude@PCIEXFN{within(5s)};
event ereport.io.pci.target-mdpe@PCIEXFN{within(5s)};
event ereport.io.pci.target-mdpe@PCIFN{within(5s)};

/*
 * DE Workaround for PLX PEX8532 Switch Erratum #59 --
 * "When the 8532 downstream port is receiving an ERR_CORR message, it is
 *  setting the Received System Error bit in the Secondary Status register."
 */
#define	PLX_VENDID		"10b5"
#define	PLX_DEVID_PEX8532	"8532"
#define	IS_PEX8532(f)	(confprop(f, TOPO_PCI_VENDID) == PLX_VENDID && \
			confprop(f, TOPO_PCI_DEVID) == PLX_DEVID_PEX8532)
event upset.io.pciex.discard_err59@PCIEXFN;
prop upset.io.pciex.discard_err59@PCIEXFN { IS_SD(PCIEXFN) &&
    IS_PEX8532(PCIEXFN) } (0)->
    ereport.io.pci.sec-rserr@PCIEXFN;

/*
 * handling of fatal and nonfatal error messages propagated up to root complex
 *
 * Use these for errors reported by root-complex on behalf of another device.
 * Can use source-id payload to identify where the message came from.
 */
prop error.io.pciex.fatal@PCIEXFN1 (1)->
    ereport.io.pciex.rc.mue-msg@pciexrc { is_under(pciexrc, PCIEXFN1) },
    ereport.io.pciex.rc.fe-msg@pciexrc { is_under(pciexrc, PCIEXFN1) &&
	SOURCE_ID_MATCHES_BDF };

prop error.io.pciex.fatal@PCIEXFN (0)->
    ereport.io.pci.sserr@PCIEXFN;

prop error.io.pciex.fatal@PCIEXFN { is_under(PCIEXFN1, PCIEXFN) } (0)->
    ereport.io.pci.sserr@PCIEXFN1,
    ereport.io.pci.sec-rserr@PCIEXFN1;

prop error.io.pciex.fatal@PCIEXFN { is_under(pciexrc, PCIEXFN) } (0)->
    ereport.io.pci.sec-rserr@pciexrc;

prop error.io.pciex.nonfatal@PCIEXFN1 (1)->
    ereport.io.pciex.rc.mue-msg@pciexrc { is_under(pciexrc, PCIEXFN1) },
    ereport.io.pciex.rc.nfe-msg@pciexrc { is_under(pciexrc, PCIEXFN1) &&
	SOURCE_ID_MATCHES_BDF };

prop error.io.pciex.nonfatal@PCIEXFN (0)->
    ereport.io.pci.sserr@PCIEXFN;

prop error.io.pciex.nonfatal@PCIEXFN { is_under(PCIEXFN1, PCIEXFN) } (0)->
    ereport.io.pci.sserr@PCIEXFN1,
    ereport.io.pci.sec-rserr@PCIEXFN1;

prop error.io.pciex.nonfatal@PCIEXFN { is_under(pciexrc, PCIEXFN) } (0)->
    ereport.io.pci.sec-rserr@pciexrc;

/*
 * link-level errors - could generate ereports at either end of link
 * 
 * can use may propagations here as these ereports are only seen for these
 * faults.
 */
prop error.io.pciex.fatlink@PCIEXFN { !IS_SD(PCIEXFN) } (0)->
    error.io.pciex.fatal@PCIEXFN;

prop error.io.pciex.fatlink@PCIEXFN { !IS_SD(PCIEXFN) } (0)->
    ereport.io.pciex.dl.dllp@PCIEXFN,
    ereport.io.pciex.tl.fcp@PCIEXFN,
    ereport.io.pciex.tl.rof@PCIEXFN;

prop error.io.pciex.fatlink@PCIEXFN/PCIEXFN { IS_SD(PCIEXFN) } (0)->
    error.io.pciex.fatal@PCIEXFN;

prop error.io.pciex.fatlink@PCIEXFN/PCIEXFN { IS_SD(PCIEXFN) } (0)->
    ereport.io.pciex.dl.dllp@PCIEXFN,
    ereport.io.pciex.pl.te@PCIEXFN,
    ereport.io.pciex.dl.sd@PCIEXFN,
    ereport.io.pciex.tl.fcp@PCIEXFN,
    ereport.io.pciex.tl.rof@PCIEXFN;

prop error.io.pciex.fatlink@pciexrc/PCIEXFN (0)->
    ereport.io.pciex.dl.dllp@pciexrc,
    ereport.io.pciex.pl.te@pciexrc,
    ereport.io.pciex.dl.sd@pciexrc,
    ereport.io.pciex.tl.fcp@pciexrc,
    ereport.io.pciex.tl.rof@pciexrc;

/*
 * bridge internal error
 */
prop error.io.pciex.sec-interr@PCIEXFN { IS_BG(PCIEXFN) } (2) ->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.bdg.sec-interr@PCIEXFN;

/*
 * downstream poisoned request
 *
 * - poisreq-d cascades down to the leaf device/bridge and any switch ports
 *   on route must raise a ptlp ereport while any switch ports forwarding
 *   the poisoned request must raise sec-mdpe ereports. The originator of the
 *   poisoning (be it root complex or downstream port of a switch) also raises
 *   sec-mdpe. A hardened leaf driver will also raise ptlp. A target-mdpe may
 *   be seen at the leaf (which may be a pci device beyond the bridge).
 *
 * Additionally, the leaf/bridge may treat the request as a ur, which the
 * root complex will see and report an ma. Use flt-ur-u to represent this.
 *
 * The fault can always be recognized and the source identified using the ptlp
 * and sec-mdpe ereports.
 */
prop error.io.pciex.poisreq-d@PCIEXFN (1)->
    error.io.pciex.poisreq-fwd-d@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_SD(PCIEXFN) ||
    IS_SU(PCIEXFN) } (1)->
    error.io.pciex.flt-ur-u@PCIEXFN,
    error.io.pciex.poisreq-fwd-d@PCIEXFN/PCIEXFNHZ; 

prop error.io.pciex.poisreq-fwd-d@pciexrc/PCIEXFN (1)->
    ereport.io.pci.sec-mdpe@pciexrc;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN/PCIEXFN { IS_SU(PCIEXFN) } (0)->
    ereport.io.pci.sec-mdpe@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_SU(PCIEXFN) } (2)->
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_SU(PCIEXFN) } (0)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN/PCIEXFN { IS_SD(PCIEXFN) } (1)->
    ereport.io.pci.sec-mdpe@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_SD(PCIEXFN) } (0)->
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (3)->
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    error.io.pci.dpdata-pw-d@PCIEXFN/PCIFNHZ,
    error.io.pci.dpdata-dw-d@PCIEXFN/PCIFNHZ;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.flt-ur-u@PCIEXFN;

prop error.io.pciex.poisreq-fwd-d@PCIEXFN (0)->
    ereport.io.pci.target-mdpe@PCIEXFN;

/*
 * downstream poisoned completion
 *
 * - poiscomp-d cascades down to the leaf device/bridge and any switch ports on
 *   route must raise ptlp and mdpe ereports.  A hardened leaf driver will also
 *   raise pltp and mdpe. For non-hardened leaf devices, no ptlp/mdpe may be
 *   reported, and though we should still see a nonfatal error reported from
 *   the root complex identifying the leaf device, we won't actually be informed
 *   that the error was an ptlp.
 */
prop error.io.pciex.poiscomp-d@PCIEXFN (1)->
    error.io.pciex.poiscomp-fwd-d@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN (1)->
    error.io.pciex.poiscomp-fwd-d@PCIEXFN/PCIEXFNHZ; 

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_SU(PCIEXFN) } (2)->
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_SU(PCIEXFN) } (1)->
    ereport.io.pci.mdpe@PCIEXFN,
    ereport.io.pci.sec-mdpe@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_SU(PCIEXFN) } (0)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_SD(PCIEXFN) } (0)->
    ereport.io.pci.mdpe@PCIEXFN,
    ereport.io.pci.sec-mdpe@PCIEXFN,
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (4)->
    ereport.io.pci.mdpe@PCIEXFN,
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    error.io.pci.dpdata-dr-d@PCIEXFN/PCIFNHZ;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poiscomp-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pci.mdpe@PCIEXFN,
    ereport.io.pci.dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN;

/*
 * downstream request with ecrc error.
 *
 * - ecrcreq-d cascades down to the leaf device/bridge and any switches on
 *   route can optionally raise an ecrc ereport. A hardened leaf driver may also
 *   raise ecrc. For non-hardened leaf devices, no ecrc may be reported, and
 *   though we should still see a nonfatal error reported from the root complex
 *   identifying the leaf device, we won't actually be informed that the error
 *   was an ecrc.
 *
 * Additionally, as the leaf/bridge will just throw away the packet, we should
 * eventually get a cto at the root complex - so use an nr-u at the pciex
 * leaf or bridge to get the appropriate behaviour. For the case where the leaf
 * driver wasn't hardened we may be able to identify the leaf device (and
 * therefore any intermediate switches which might have caused the problem)
 * either via a target-ma ereport if available or via the nonfatal error
 * reported from the root complex identifying the leaf device. The combination
 * of a nonfatal error reported from the root complex and a cto from the root
 * complex is sufficient to positively identify this case.
 */
prop error.io.pciex.ecrcreq-d@PCIEXFN (1)->
    error.io.pciex.ecrcreq-fwd-d@PCIEXFN,
    error.io.pciex.ecrcreq-fwd-d@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) };

prop error.io.pciex.ecrcreq-fwd-d@PCIEXFN { IS_SU(PCIEXFN) ||
    IS_SD(PCIEXFN) } (1)->
    error.io.pciex.flt-nr-u@PCIEXFN;

prop error.io.pciex.ecrcreq-fwd-d@PCIEXFN { IS_SU(PCIEXFN) ||
    IS_SD(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.ecrcreq-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (3)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.tl.ecrc@PCIEXFN,
    error.io.pciex.flt-nr-u@PCIEXFN;

prop error.io.pciex.ecrcreq-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (2)->
    error.io.pciex.nonfatal@PCIEXFN,
    error.io.pciex.flt-nr-u@PCIEXFN;

prop error.io.pciex.ecrcreq-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@PCIEXFN;

/*
 * downstream completion with ecrc error.
 *
 * - ecrccomp-d cascades down to the leaf device/bridge and any switches on
 *   route can optionally raise an ecrc ereport. A hardened leaf driver may
 *   also raise ecrc. For non-hardened leaf devices, no ecrc may be reported,
 *   and though we should still see a nonfatal error reported from the root
 *   complex identifying the leaf device, we won't actually be informed that
 *   the error was an ecrc.
 *
 * Additionally, as the leaf/bridge will just throw away the packet, we should
 * eventually get a cto. Note the leaf ereports are optional (ie in case driver
 * not hardened) but if we get both ecrc and cto we need to distinguish from
 * cto only which would be an nr-d.
 */
prop error.io.pciex.ecrccomp-d@PCIEXFN (1)->
    error.io.pciex.ecrccomp-fwd-d@PCIEXFN,
    error.io.pciex.ecrccomp-fwd-d@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) };

prop error.io.pciex.ecrccomp-fwd-d@PCIEXFN { IS_SU(PCIEXFN) ||
    IS_SD(PCIEXFN) } (0)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.tl.ecrc@PCIEXFN;

prop error.io.pciex.ecrccomp-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (3)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.tl.ecrc@PCIEXFN,
    error.io.pciex.nr-d@PCIEXFN;

prop error.io.pciex.ecrccomp-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.ecrccomp-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@PCIEXFN,
    error.io.pciex.nr-d@PCIEXFN;

/*
 * upstream poisoned request
 *
 * - flt-poisreq-u is on the pciex node which generated the fault
 * - source-poisreq-u refers to at least one leaf or bridge device
 *   whose bdf (if leaf) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - poisreq-u propagates up to the root complex and any switch ports on
 *   route will raise a ptlp ereport, while any upstream devices generating
 *   or forwarding the poisoned packed will raise an mdpe ereport. The root
 *   complex should also report a ptlp.
 *
 * Additionally, as the root complex may treat the request as a ur, which the
 * leaf/bridge will see (and if hardened report) as an ma (including sending a 
 * ta onto the child pci bus if this was a delayed write).
 *
 * We can always recognize what sort of fault this is from the ptlp (with no
 * sec-mdpe) at the root complex. Recognizing which originating devices may be
 * implicated can be done using the mdpe ereport (for a hardened leaf driver),
 * or for a non-hardened leaf driver by using the source-id payload in the ptlp
 * ereport to identify the originator of the request.  The ptlp/mdpe ereports
 * at the intervening switches will narrow the fault down to a single suspect.
 */

prop error.io.pciex.flt-poisreq-u@PCIEXFN1 { (IS_LF(PCIEXFN) ||
    IS_BG(PCIEXFN)) && is_under(PCIEXFN1, PCIEXFN) } (0)->
    error.io.pciex.source-poisreq-u@PCIEXFN;

prop error.io.pciex.source-poisreq-u@PCIEXFN1 { IS_LF(PCIEXFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(pciexrc, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ptlp@pciexrc,
    ereport.io.pciex.tl.ur@pciexrc;

prop error.io.pciex.source-poisreq-u@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pci.ma@PCIEXFN;

prop error.io.pciex.source-poisreq-u@PCIEXFN { IS_BG(PCIEXFN) &&
    is_under(pciexrc, PCIEXFN) } (0)->
    ereport.io.pciex.tl.ptlp@pciexrc,
    ereport.io.pciex.tl.ur@pciexrc;

prop error.io.pciex.source-poisreq-u@PCIEXFN { IS_BG(PCIEXFN) } (0)->
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN,
    error.io.pci.ta-drw-d@PCIEXFN/PCIFN;

prop error.io.pciex.flt-poisreq-u@PCIEXFN (1)->
    error.io.pciex.poisreq-u@PCIEXFN;

/*
 * the remaining propagations are also used for poisoned requests propagating
 * up due to a fault behind a pcie-pci bridge
 */
prop error.io.pciex.poisreq-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.poisreq-u@PCIEXFN;

prop error.io.pciex.poisreq-u@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    ereport.io.pci.mdpe@PCIEXFN;

prop error.io.pciex.poisreq-u@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pci.mdpe@PCIEXFN;

prop error.io.pciex.poisreq-u@PCIEXFN { IS_SD(PCIEXFN) } (2)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN;

prop error.io.pciex.poisreq-u@PCIEXFN { IS_SD(PCIEXFN) } (0)->
    ereport.io.pci.mdpe@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poisreq-u@PCIEXFN { IS_SU(PCIEXFN) } (1)->
    ereport.io.pci.mdpe@PCIEXFN;

prop error.io.pciex.poisreq-u@PCIEXFN { IS_SU(PCIEXFN) } (0)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poisreq-u@pciexrc/PCIEXFN (1)->
    ereport.io.pci.sec-dpe@pciexrc;

/*
 * upstream poisoned completion
 *
 * - flt-poiscomp-u is on the pciex node which generated the fault. There will
 *   be a target-mdpe downstream from here.
 * - source-poiscomp-u refers to at least one leaf or bridge device
 *   whose bdf (if leaf) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - poiscomp-u propagates up to the root complex and any switches on
 *   route will raise ptlp and sec-mdpe ereports. The root complex will also
 *   raise a sec-mdpe and ptlp.
 *
 * We can always recognize what sort of fault this is from the ptlp/sec-mdpe at
 * the root complex. Recognizing which originating devices may be implicated
 * can be done using the source-id payload in the ptlp ereport to identify the
 * originator of the completion. The ptlp/sec-mdpe ereports at the intervening
 * switches will narrow the fault down to a single suspect.
 */
prop error.io.pciex.flt-poiscomp-u@PCIEXFN { IS_LF(PCIEXFN1) &&
    is_under(PCIEXFN, PCIEXFN1) } (0)->
    ereport.io.pci.target-mdpe@PCIEXFN1;

prop error.io.pciex.flt-poiscomp-u@PCIEXFN { IS_PCI_LF(PCIFN) &&
    is_under(PCIEXFN, PCIFN) } (0)->
    ereport.io.pci.target-mdpe@PCIFN;

prop error.io.pciex.flt-poiscomp-u@PCIEXFN1 { (IS_LF(PCIEXFN) ||
    IS_BG(PCIEXFN)) && is_under(PCIEXFN1, PCIEXFN) } (0)->
    error.io.pciex.source-poiscomp-u@PCIEXFN;

prop error.io.pciex.source-poiscomp-u@PCIEXFN1 { IS_LF(PCIEXFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(pciexrc, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ptlp@pciexrc;

prop error.io.pciex.source-poiscomp-u@PCIEXFN1 { IS_BG(PCIEXFN1) &&
    is_under(pciexrc, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ptlp@pciexrc;

prop error.io.pciex.flt-poiscomp-u@PCIEXFN (1)->
    error.io.pciex.poiscomp-u@PCIEXFN;

/*
 * the remaining propagations are also used for poisoned completions propagating
 * up due to a fault behind a pcie-pci bridge
 */
prop error.io.pciex.poiscomp-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.poiscomp-u@PCIEXFN;

prop error.io.pciex.poiscomp-u@PCIEXFN { IS_SD(PCIEXFN) } (2)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN;

prop error.io.pciex.poiscomp-u@PCIEXFN { IS_SD(PCIEXFN) } (1)->
    ereport.io.pci.sec-mdpe@PCIEXFN,
    ereport.io.pci.mdpe@PCIEXFN;

prop error.io.pciex.poiscomp-u@PCIEXFN { IS_SD(PCIEXFN) } (0)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poiscomp-u@PCIEXFN { IS_SU(PCIEXFN) } (0)->
    ereport.io.pci.mdpe@PCIEXFN,
    ereport.io.pci.sec-mdpe@PCIEXFN,
    ereport.io.pci.sec-dpe@PCIEXFN,
    ereport.io.pciex.tl.ptlp@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.poiscomp-u@pciexrc/PCIEXFN (1)->
    ereport.io.pci.sec-dpe@pciexrc;

prop error.io.pciex.poiscomp-u@pciexrc/PCIEXFN (0)->
    ereport.io.pci.sec-mdpe@pciexrc;

/*
 * upstream request with ecrc error.
 *
 * - flt-ecrcreq-u is on the pciex node which generated the fault.
 * - source-ecrcreq-u cascades down to at least one leaf device (pciex or pci),
 *   whose bdf (if pciex) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - ecrcreq-u propagates up to the root complex which must report it with an
 *   ecrc ereport and any switches on route can optionally raise an ecrc ereport
 *
 * Additionally, as the root complex will just throw away the packet, we may
 * eventually get a cto - so use an nr-d at the pciex leaf or bridge to get
 * the appropriate behaviour.
 *
 * We can always recognize what sort of fault this is from the ecrc (with no
 * cto) at the root complex. Recognizing which leaf device may be implicated
 * can be done from the cto ereport (for a hardened leaf driver) or for a
 * non-hardened leaf using the source-id payload of the ecrc.
 */
prop error.io.pciex.flt-ecrcreq-u@PCIEXFN1 { (IS_LF(PCIEXFN) ||
    IS_BG(PCIEXFN)) && is_under(PCIEXFN1, PCIEXFN) } (0)->
    error.io.pciex.source-ecrcreq-u@PCIEXFN;

prop error.io.pciex.source-ecrcreq-u@PCIEXFN (0)->
    error.io.pciex.nr-d@PCIEXFN;

prop error.io.pciex.source-ecrcreq-u@PCIEXFN1 { IS_LF(PCIEXFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(pciexrc, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ecrc@pciexrc;

prop error.io.pciex.source-ecrcreq-u@PCIEXFN { IS_BG(PCIEXFN) &&
    is_under(pciexrc, PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@pciexrc;

prop error.io.pciex.flt-ecrcreq-u@PCIEXFN (1)->
     error.io.pciex.ecrcreq-u@PCIEXFN;

prop error.io.pciex.ecrcreq-u@PCIEXFN/PCIEXFN (1)->
     error.io.pciex.ecrcreq-u@PCIEXFN;

prop error.io.pciex.ecrcreq-u@PCIEXFN { IS_SD(PCIEXFN)||IS_SU(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

/*
 * upstream completion with ecrc error.
 *
 * - flt-ecrccomp-u is on the pciex node which generated the fault.
 * - source-ecrccomp-u cascades down to at least one leaf device (pciex or pci),
 *   whose bdf (if pciex) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - ecrccomp-u propagates up to the root complex, which should report it with
 *   an ecrc ereport and any switches on route can optionally raise an ecrc
 *   ereport.
 *
 * Additionally, as the root complex will just throw away the packet, we'll
 * eventually get a cto - so use an flt-nr-u at the pciex leaf or bridge to get
 * the appropriate behaviour.
 *
 * We can always recognize what sort of fault this from the ecrc/cto from the
 * root complex. Recognizing which leaf device may be implicated can be done
 * using either the source-id payload of the ecrc or the target-ma ereport if
 * available.
 */
prop error.io.pciex.flt-ecrccomp-u@PCIEXFN1 { (IS_LF(PCIEXFN) ||
    IS_BG(PCIEXFN)) && is_under(PCIEXFN1, PCIEXFN) } (0)->
    error.io.pciex.source-ecrccomp-u@PCIEXFN;

prop error.io.pciex.source-ecrccomp-u@PCIEXFN (0)->
    error.io.pciex.flt-nr-u@PCIEXFN;

prop error.io.pciex.source-ecrccomp-u@PCIEXFN1 { IS_LF(PCIEXFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(pciexrc, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ecrc@pciexrc;

prop error.io.pciex.source-ecrccomp-u@PCIEXFN { IS_BG(PCIEXFN) &&
    is_under(pciexrc, PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@pciexrc;

prop error.io.pciex.flt-ecrccomp-u@PCIEXFN (1)->
    error.io.pciex.ecrccomp-u@PCIEXFN;

prop error.io.pciex.ecrccomp-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.ecrccomp-u@PCIEXFN;

prop error.io.pciex.ecrccomp-u@PCIEXFN { IS_SD(PCIEXFN)||IS_SU(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ecrc@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

/*
 * no response to downstream requester
 *
 * - nr-d will effectively cascade downstream to the requester. The fault here
 *   is always at the root complex. For a hardened leaf device driver, we will
 *   always be able to recognize this as the requester will report this as a
 *   cto. For non-hardened leaf devices, no cto will be reported, and though we
 *   should still see a nonfatal error reported from the root complex
 *   identifying the leaf device, we won't actually be informed that the error
 *   was a cto.
 */
prop error.io.pciex.nr-d@PCIEXFN (1)->
    error.io.pciex.nr-fwd-d@PCIEXFN { IS_BG(PCIEXFN) || IS_LF(PCIEXFN) },
    error.io.pciex.nr-fwd-d@PCIEXFNHZ { (IS_BG(PCIEXFNHZ) ||
    IS_LF(PCIEXFNHZ)) && is_under(PCIEXFN, PCIEXFNHZ) }; 

prop error.io.pciex.nr-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (2)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.tl.cto@PCIEXFN;

prop error.io.pciex.nr-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (0)->
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN,
    error.io.pci.nr-drw-d@PCIEXFN/PCIFN,
    error.io.pci.ta-drw-d@PCIEXFN/PCIFN;

prop error.io.pciex.nr-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.nr-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pciex.tl.cto@PCIEXFN;

/*
 * no response to upstream requester
 *
 * - flt-nr-u will effectively cascade upstream to the root complex which will
 *   report it as a cto.
 *
 * We have to use target-ma to informs us which device failed to respond.
 */
prop error.io.pciex.flt-nr-u@PCIEXFN (1)->
    error.io.pci.target-ma-d@PCIEXFN;

prop error.io.pciex.flt-nr-u@PCIEXFN (1)->
    error.io.pciex.nr-u@PCIEXFN;

prop error.io.pciex.nr-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.nr-u@PCIEXFN;

prop error.io.pciex.nr-u@pciexrc/PCIEXFN (1)->
    ereport.io.pciex.tl.cto@pciexrc;

prop error.io.pciex.nr-u@pciexrc/PCIEXFN (0)->
    ereport.io.pci.sec-ma@pciexrc;

/*
 * downstream malformed tlp
 *
 * This will cascade downstream to the receiver which will report it as an mtlp.
 * For non-hardened leaf drivers, no mtlp will be reported, and though we should
 * still see a fatal error reported from the root complex identifying the leaf
 * device, we won't actually be informed that the error was a mtlp.
 * Note that sw-mtlp-d is to handle the case where the switch is actually
 * the target of the packet (config request etc).
 */
prop error.io.pciex.mtlp-d@PCIEXFN (1)->
    error.io.pciex.mtlp-fwd-d@PCIEXFN { !IS_SD(PCIEXFN) },
    error.io.pciex.mtlp-fwd-d@PCIEXFNHZ { !IS_SD(PCIEXFNHZ) &&
    is_under(PCIEXFN, PCIEXFNHZ) };

prop error.io.pciex.mtlp-fwd-d@PCIEXFN { IS_SU(PCIEXFN) } (2)->
    error.io.pciex.fatal@PCIEXFN,
    ereport.io.pciex.tl.mtlp@PCIEXFN;

prop error.io.pciex.mtlp-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (2)->
    error.io.pciex.fatal@PCIEXFN,
    ereport.io.pciex.tl.mtlp@PCIEXFN;

prop error.io.pciex.mtlp-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    error.io.pciex.fatal@PCIEXFN;

prop error.io.pciex.mtlp-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pciex.tl.mtlp@PCIEXFN;

/*
 * upstream malformed tlp
 *
 * This will cascade upstream to the receiver which will report it as an mtlp.
 */
prop error.io.pciex.flt-mtlp-u@PCIEXFN (1)->
    error.io.pciex.mtlp-u@PCIEXFN;

prop error.io.pciex.mtlp-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.mtlp-u@PCIEXFN;

prop error.io.pciex.mtlp-u@pciexrc/PCIEXFN (1)->
    ereport.io.pciex.tl.mtlp@pciexrc;

/*
 * downstream completer aborts
 *
 * This could be the fault of the root complex or a switch reporting an internal
 * error, or of the leaf device sending an invalid request (the latter is
 * handled by the flt-badreq-u case below).
 *
 * This is reported by the completer or by an intervening downstream switch
 * port. The completer abort response propagates down to the initiator which
 * will set the legacy pci bit rta.
 *
 * The fault can always be recognized by the ca ereport from the root complex
 * or downstream switch port. The originator of the request can be recognized
 * by the rta for a hardened driver or by using the source-id payload of the
 * ca ereport for a non-hardened driver.
 */
prop error.io.pciex.ca-d@pciexrc/PCIEXFN (0)->
    ereport.io.pciex.tl.ca@pciexrc;

prop error.io.pciex.ca-d@pciexrc/PCIEXFN (1)->
    ereport.io.pci.sec-sta@pciexrc;

prop error.io.pciex.ca-d@PCIEXFN/PCIEXFN (0)->
    ereport.io.pci.sec-sta@PCIEXFN;

prop error.io.pciex.ca-d@PCIEXFN/PCIEXFN (2)->
    ereport.io.pciex.tl.ca@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.ca-d@PCIEXFN (1)->
    error.io.pciex.ca-fwd-d@PCIEXFN { IS_BG(PCIEXFN) || IS_LF(PCIEXFN) },
    error.io.pciex.ca-fwd-d@PCIEXFNHZ { (IS_BG(PCIEXFNHZ) ||
    IS_LF(PCIEXFNHZ)) && is_under(PCIEXFN, PCIEXFNHZ) };

prop error.io.pciex.ca-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    ereport.io.pci.rta@PCIEXFN;

prop error.io.pciex.ca-fwd-d@PCIEXFN { IS_BG(PCIEXFN) } (0)->
    ereport.io.pci.sec-sta@PCIEXFN,
    error.io.pci.ta-drw-d@PCIEXFN/PCIFN;

prop error.io.pciex.ca-fwd-d@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pci.rta@PCIEXFN;

/*
 * upstream completer aborts
 *
 * This could be the fault of the leaf device/bridge/upstream switch port
 * reporting an internal error, or of the root complex sending an invalid
 * request (the latter case is handled by badreq-d below).
 *
 * This is reported as a ca by the completer. The completer (for non-posted
 * requests) sends the appropriate error bits in the completion message to
 * the initiator which will set the legacy pci bit sec-rta.
 *
 * The fault can always be recognized from the sec-rta bit at the root complex.
 *
 * If the fault was with a PCI Express leaf with a hardened driver, then we
 * will identify the device from the ca ereport.
 *
 * If the fault was with a PCI Express leaf with a non-hardened driver, then we
 * can still identify the leaf device from the source-id payload of the nonfatal
 * message ereport from the root complex or from the target-rta ereport.
 */
prop error.io.pciex.flt-ca-u@PCIEXFN { !IS_LF(PCIEXFN) } (1)->
    ereport.io.pciex.tl.ca@PCIEXFN;

prop error.io.pciex.flt-ca-u@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ca@PCIEXFN;

prop error.io.pciex.flt-ca-u@PCIEXFN (0)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pci.sta@PCIEXFN;

prop error.io.pciex.flt-ca-u@PCIEXFN (2)->
    error.io.pci.target-rta-d@PCIEXFN,
    error.io.pciex.ca-u@PCIEXFN;

prop error.io.pciex.ca-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.ca-u@PCIEXFN;

prop error.io.pciex.ca-u@pciexrc/PCIEXFN (0)->
    ereport.io.pci.sec-rta@pciexrc;

/*
 * upstream bad request
 *
 * When detecting bad data on a request the completer (or any switch on the
 * way to the completer) may report ur or ca. If the switch detects the problem
 * first then the request doesn't get forwarded on to the completer.
 *
 * These are reported as ur/ca ereports. For non-posted requests, the reporter
 * then sends the appropriate error bits in the completion message to the
 * initiator which will set the legacy pci bits ma or rta.
 *
 * For flt-badreq-u, the ca/ur ereports contain a source-id payload that
 * identifies the initiator.
 *
 * The fault can always be recognized by the ca/ur ereport from the root
 * complex or downstream switch port. The originator of the request can be
 * recognized by the rta/ma for a hardened driver or by using the source-id
 * payload of the ca/ur ereport for a non-hardened driver.
 */
prop error.io.pciex.flt-badreq-u@PCIEXFN (0)->
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pci.rta@PCIEXFN;

prop error.io.pciex.flt-badreq-u@PCIEXFN1 {
    SOURCE_ID_MATCHES_BDF && is_under(pciexrc, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ur@pciexrc,
    ereport.io.pciex.tl.ca@pciexrc;

prop error.io.pciex.flt-badreq-u@PCIEXFN (1)->
    error.io.pciex.badreq-u@PCIEXFN;

prop error.io.pciex.badreq-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.badreq-u@PCIEXFN;

prop error.io.pciex.badreq-u@pciexrc/PCIEXFN (0)->
    ereport.io.pci.sec-sta@pciexrc;

prop error.io.pciex.flt-badreq-u@PCIEXFN1 { IS_SD(PCIEXFN) &&
    SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIEXFN1) } (0)->
    ereport.io.pciex.tl.ur@PCIEXFN,
    ereport.io.pciex.tl.ca@PCIEXFN;

prop error.io.pciex.flt-badreq-u@PCIEXFN1 { IS_SD(PCIEXFN) &&
    is_under(PCIEXFN, PCIEXFN1) } (0)->
    ereport.io.pci.sec-sta@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

/*
 * downstream bad request
 *
 * When detecting bad data on a request the completer (or any switch on the
 * way to the completer) may report ur or ca. If the switch detects the problem
 * first then the request doesn't get forwarded on to the completer.
 *
 * These are reported as ur/ca ereports (except where the completer is a non-
 * hardened leaf driver when all we get is a nonfatal error from the root
 * complex identifying the leaf device). The reporter then sends the appropriate
 * error bits in the completion message to the initiator which will set the
 * legacy pci bits ma or rta (oddly there is no equivalent in pcie error
 * reporting).
 */
prop error.io.pciex.badreq-d@PCIEXFN (1)->
    error.io.pciex.flt-ur-u@PCIEXFN,
    error.io.pciex.flt-ca-u@PCIEXFN,
    error.io.pciex.flt-ur-u@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    error.io.pciex.flt-ca-u@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    error.io.pci.badreq-pw-d@PCIEXFNHZ/PCIFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    error.io.pci.badreq-drw-d@PCIEXFNHZ/PCIFNHZ { is_under(PCIEXFN,PCIEXFNHZ) };

prop error.io.pciex.flt-ur-u@PCIEXFN { !IS_LF(PCIEXFN) } (1)->
    ereport.io.pciex.tl.ur@PCIEXFN;

prop error.io.pciex.flt-ur-u@PCIEXFN { IS_LF(PCIEXFN) } (0)->
    ereport.io.pciex.tl.ur@PCIEXFN;

prop error.io.pciex.flt-ur-u@PCIEXFN (2)->
    error.io.pci.target-ma-d@PCIEXFN,
    error.io.pciex.ur-u@PCIEXFN;

prop error.io.pciex.flt-ur-u@PCIEXFN (0)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pciex.ur-u@PCIEXFN/PCIEXFN (1)->
    error.io.pciex.ur-u@PCIEXFN;

prop error.io.pciex.ur-u@pciexrc/PCIEXFN (0)->
    ereport.io.pci.sec-ma@pciexrc;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Stub unused legacy pci ereports at root complex.
 * Stub tl.uc as we can't do anything useful with it (we should eventually
 * get a cto which we can do something with - a uc without a cto is a genuinely
 * spurious completion which is at least harmless).
 * Stub messages that the root complex sends to itself.
 * Stub mce/mue/ce/nr/noadverr.
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

event error.io.pciex.discard_rc@pciexrc;

event ereport.io.pciex.noadverr@PCIEXFN{within(5s)};
event ereport.io.pciex.correctable@PCIEXFN{within(5s)};
event ereport.io.pciex.nonfatal@PCIEXFN{within(5s)};
event ereport.io.pciex.a-nonfatal@PCIEXFN{within(5s)};
event ereport.io.pciex.fatal@PCIEXFN{within(5s)};
event ereport.io.pci.nr@PCIEXFN{within(5s)};
event ereport.io.pci.nr@pciexrc{within(5s)};
event ereport.io.pci.ma@pciexrc{within(5s)};
event ereport.io.pci.rta@pciexrc{within(5s)};
event ereport.io.pci.sta@pciexrc{within(5s)};
event ereport.io.pci.dpe@pciexrc{within(5s)};
event ereport.io.pci.mdpe@pciexrc{within(5s)};
event ereport.io.pci.sserr@pciexrc{within(5s)};
event ereport.io.pciex.tl.uc@pciexrc{within(5s)};
event ereport.io.pciex.noadverr@pciexrc{within(5s)};
event ereport.io.pciex.a-nonfatal@pciexrc{within(5s)};
event ereport.io.pciex.rc.ce-msg@pciexrc{within(5s)};
event ereport.io.pciex.rc.mce-msg@pciexrc{within(5s)};

event upset.io.pciex.discard_uc@PCIEXFN;
event upset.io.pciex.discard@PCIEXFN;
event upset.io.pciex.discard@pciexrc;

prop upset.io.pciex.discard_uc@PCIEXFN { IS_BG(PCIEXFN) } (1)->
    ereport.io.pciex.tl.uc@PCIEXFN;

prop upset.io.pciex.discard_uc@PCIEXFN { IS_LF(PCIEXFN) } (1)->
    ereport.io.pciex.tl.uc@PCIEXFN;

prop upset.io.pciex.discard@PCIEXFN (1)->
    ereport.io.pci.nr@PCIEXFN,
    ereport.io.pciex.noadverr@PCIEXFN,
    ereport.io.pciex.correctable@PCIEXFN,
    ereport.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.a-nonfatal@PCIEXFN,
    ereport.io.pciex.fatal@PCIEXFN;

prop error.io.pciex.discard_rc@pciexrc (0)->
    ereport.io.pciex.rc.mue-msg@pciexrc,
    ereport.io.pciex.rc.fe-msg@pciexrc { SOURCE_ID_MATCHES_OWN_BDF },
    ereport.io.pciex.rc.nfe-msg@pciexrc { SOURCE_ID_MATCHES_OWN_BDF };

prop upset.io.pciex.discard@pciexrc (1)->
    error.io.pciex.discard_rc@pciexrc,
    ereport.io.pci.nr@pciexrc,
    ereport.io.pciex.noadverr@pciexrc,
    ereport.io.pciex.a-nonfatal@pciexrc,
    ereport.io.pciex.rc.ce-msg@pciexrc,
    ereport.io.pciex.rc.mce-msg@pciexrc,
    ereport.io.pciex.tl.uc@pciexrc,
    ereport.io.pci.ma@pciexrc,
    ereport.io.pci.rta@pciexrc,
    ereport.io.pci.sta@pciexrc,
    ereport.io.pci.dpe@pciexrc,
    ereport.io.pci.mdpe@pciexrc,
    ereport.io.pci.sserr@pciexrc;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * rules for propagations from child PCI bus
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

event error.io.pci.retry-to-u@PCIEXFN/PCIFN;
event error.io.pci.ma-u@PCIEXFN/PCIFN;
event error.io.pci.ta-u@PCIEXFN/PCIFN;
event error.io.pci.ape-u@PCIEXFN/PCIFN;
event error.io.pci.source-ape-u@PCIFN;
event error.io.pci.target-ma-d@PCIFN;
event error.io.pci.target-rta-d@PCIFN;
event error.io.pci.badreq-pw-u@PCIEXFN/PCIFN;
event error.io.pci.badreq-drw-u@PCIEXFN/PCIFN;
event error.io.pci.source-perr-u@PCIFN;
event error.io.pci.source-dpdata-u@PCIFN;
event error.io.pci.dpdata-pw-u@PCIEXFN/PCIFN;
event error.io.pci.dpdata-dw-u@PCIEXFN/PCIFN;
event error.io.pci.dpdata-dr-u@PCIEXFN/PCIFN;
event error.io.pci.perr-pw-u@PCIEXFN/PCIFN;
event error.io.pci.perr-dw-u@PCIEXFN/PCIFN;
event error.io.pci.perr-dr-u@PCIEXFN/PCIFN;
event error.io.pci.serr-u@PCIEXFN/PCIFN;
event error.io.pcix.scpe-u@PCIEXFN/PCIFN;
event error.io.pcix.source-scpe-u@PCIFN;
event error.io.pcix.spl-comp-ma-u@PCIEXFN/PCIFN;
event error.io.pcix.spl-comp-ta-u@PCIEXFN/PCIFN;
event error.io.pcix.spl-comp-ma-d@PCIEXFN/PCIFN;
event error.io.pcix.spl-comp-ta-d@PCIEXFN/PCIFN;
event error.io.pcix.uscmd@PCIEXFN;

event ereport.io.pcix.sec-spl-dis@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.uscmd@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-perr@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-uadr@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-uat@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-serr@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-tex@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-rma@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-rta@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-ma-sc@PCIEXFN{within(5s)};
event ereport.io.pciex.bdg.sec-ta-sc@PCIEXFN{within(5s)};
event ereport.io.pci.dto@PCIEXFN{within(5s)};
event ereport.io.pci.sec-rta@PCIEXFN{within(5s)};
event ereport.io.pci.sec-ma@PCIEXFN{within(5s)};

/*
 * ma-u will only propagate on to pciex bus for non-posted accesses. It
 * is then represented as an unsupported request.
 */
prop error.io.pci.ma-u@PCIEXFN/PCIFN (0)->
    ereport.io.pciex.tl.ur@PCIEXFN,
    error.io.pciex.ur-u@PCIEXFN;

prop error.io.pci.ma-u@PCIEXFN/PCIFN (2)->
    ereport.io.pci.sec-ma@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pci.target-ma-d@PCIFN1 { IS_BG(PCIEXFN) && IS_PCI_LF(PCIFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIFN1) } (0)->
    ereport.io.pciex.bdg.sec-rma@PCIEXFN;

/*
 * ta-u will only propagate on to pciex bus for non-posted accesses. It is
 * then represented as a completer abort.
 */
prop error.io.pci.ta-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.sta@PCIEXFN,
    ereport.io.pciex.tl.ca@PCIEXFN,
    error.io.pciex.ca-u@PCIEXFN;

prop error.io.pci.ta-u@PCIEXFN/PCIFN (2)->
    ereport.io.pci.sec-rta@PCIEXFN,
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pci.target-rta-d@PCIFN1 { IS_BG(PCIEXFN) && IS_PCI_LF(PCIFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIFN1) } (0)->
    ereport.io.pciex.bdg.sec-rta@PCIEXFN;

/*
 * PERR# on a delayed write is represented as an unsupported request
 */
prop error.io.pci.perr-dw-u@PCIEXFN/PCIFN (1)->
    ereport.io.pci.sec-mdpe@PCIEXFN;

prop error.io.pci.perr-dw-u@PCIEXFN/PCIFN (0)->
    error.io.pciex.flt-ur-u@PCIEXFN;

prop error.io.pci.perr-pw-u@PCIEXFN/PCIFN (1)->
    ereport.io.pci.sec-mdpe@PCIEXFN;

prop error.io.pci.perr-pw-u@PCIEXFN/PCIFN (0)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pci.perr-dr-u@PCIEXFN/PCIFN (1)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pci.source-perr-u@PCIFN1 { IS_BG(PCIEXFN) && IS_PCI_LF(PCIFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIFN1) } (0)->
    ereport.io.pciex.bdg.sec-perr@PCIEXFN;

/*
 * If the bridge receives data with bad ecc/parity from pci/pci-x, it will
 * propagate onto pci express as a poisoned tlp
 */
prop error.io.pci.dpdata-dr-u@PCIEXFN/PCIFN (2)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    error.io.pciex.poiscomp-u@PCIEXFN;

prop error.io.pci.dpdata-dr-u@PCIEXFN/PCIFN (0)->
    error.io.pciex.nonfatal@PCIEXFN;

prop error.io.pci.dpdata-dr-u@PCIEXFN/PCIFN (1)->
    ereport.io.pci.sec-mdpe@PCIEXFN,
    ereport.io.pci.mdpe@PCIEXFN;

prop error.io.pci.dpdata-dw-u@PCIEXFN/PCIFN (1)->
    ereport.io.pci.sec-dpe@PCIEXFN;

prop error.io.pci.dpdata-dw-u@PCIEXFN/PCIFN (0)->
    error.io.pciex.nonfatal@PCIEXFN,
    error.io.pciex.poisreq-u@PCIEXFN,
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN,
    error.io.pci.ta-drw-d@PCIEXFN/PCIFN;

prop error.io.pci.dpdata-pw-u@PCIEXFN/PCIFN (2)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    error.io.pciex.poisreq-u@PCIEXFN;

prop error.io.pci.dpdata-pw-u@PCIEXFN/PCIFN (0)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pci.ma@PCIEXFN;

prop error.io.pci.source-dpdata-u@PCIFN { is_under(pciexrc, PCIFN) } (0)->
    ereport.io.pciex.tl.ptlp@pciexrc,
    ereport.io.pciex.tl.ur@pciexrc;

prop error.io.pci.source-dpdata-u@PCIFN1 { IS_BG(PCIEXFN) && IS_PCI_LF(PCIFN1)
    && SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIFN1) } (0)->
    ereport.io.pciex.bdg.sec-ude@PCIEXFN;

/*
 * If the bridge sees an address or attribute parity error it is considered
 * a fatal error.
 */
prop error.io.pci.ape-u@PCIEXFN/PCIFN (2)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    error.io.pciex.fatal@PCIEXFN;

prop error.io.pci.source-ape-u@PCIFN1 { IS_BG(PCIEXFN) && IS_PCI_LF(PCIFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIFN1) } (0)->
    ereport.io.pciex.bdg.sec-uat@PCIEXFN,
    ereport.io.pciex.bdg.sec-uadr@PCIEXFN;

prop error.io.pci.ape-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.sec-rserr@PCIEXFN,
    ereport.io.pciex.bdg.sec-serr@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN;

/*
 * If the bridge sees a split completion error (pci-x only) it could
 * result in a number of things
 * - unrecovered split completion message data error (uscmd). This would
 *   happen on a pio write. A completer abort is returned to the initiator.
 * - for various faults in the split completion (eg address parity error)
 *   we will respond with a target abort (which the child device will treat
 *   as a split completion ta)
 * - for other faults we can't tell who send the split completion and so
 *   just drop the request (which the child device sees as a split
 *   completion ma)
 */
prop error.io.pcix.scpe-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.sec-dpe@PCIEXFN,
    ereport.io.pci.sec-rserr@PCIEXFN,
    ereport.io.pciex.bdg.sec-serr@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN,
    error.io.pciex.fatal@PCIEXFN;

prop error.io.pcix.source-scpe-u@PCIFN1 { IS_BG(PCIEXFN) && IS_PCI_LF(PCIFN1) &&
    SOURCE_ID_MATCHES_BDF && is_under(PCIEXFN, PCIFN1) } (0)->
    ereport.io.pciex.bdg.sec-uat@PCIEXFN,
    ereport.io.pciex.bdg.sec-uadr@PCIEXFN;

prop error.io.pcix.scpe-u@PCIEXFN/PCIFN (1)->
    error.io.pcix.uscmd@PCIEXFN,
    error.io.pcix.spl-comp-ma-d@PCIEXFN/PCIFN,
    error.io.pcix.spl-comp-ta-d@PCIEXFN/PCIFN;

prop error.io.pcix.uscmd@PCIEXFN (4)->
    error.io.pciex.fatal@PCIEXFN,
    ereport.io.pci.sta@PCIEXFN,
    ereport.io.pciex.tl.ca@PCIEXFN,
    ereport.io.pciex.bdg.uscmd@PCIEXFN;

prop error.io.pcix.uscmd@PCIEXFN (0)->
    error.io.pciex.ca-u@PCIEXFN;

/*
 * Similarly a child device may have responded with a master abort or
 * target abort to one of our split competions. The hardware just logs these.
 */
prop error.io.pcix.spl-comp-ma-u@PCIEXFN/PCIFN (3)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pcix.sec-spl-dis@PCIEXFN,
    ereport.io.pciex.bdg.sec-ma-sc@PCIEXFN;

prop error.io.pcix.spl-comp-ma-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.sec-ma@PCIEXFN;

prop error.io.pcix.spl-comp-ta-u@PCIEXFN/PCIFN (4)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pcix.sec-spl-dis@PCIEXFN,
    ereport.io.pciex.bdg.sec-ta-sc@PCIEXFN,
    ereport.io.pci.sec-rta@PCIEXFN;

/*
 * SERR# is considered fatal
 */
prop error.io.pci.serr-u@PCIEXFN/PCIFN (3)->
    error.io.pciex.fatal@PCIEXFN,
    ereport.io.pci.sec-rserr@PCIEXFN,
    ereport.io.pciex.bdg.sec-serr@PCIEXFN;

/*
 * Retry time-out is nonfatal. The initial requester has stopped retrying so
 * there's nothing else the hardware can do but flag the error.
 */
prop error.io.pci.retry-to-u@PCIEXFN/PCIFN (2)->
    error.io.pciex.nonfatal@PCIEXFN,
    ereport.io.pciex.bdg.sec-tex@PCIEXFN;

prop error.io.pci.retry-to-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.sta@PCIEXFN,
    ereport.io.pci.dto@PCIEXFN,
    error.io.pciex.ca-u@PCIEXFN;

/*
 * A bad dma request (eg with invalid address) propagates onto pci express
 * as a bad dma request. The end result may be a master abort or target abort
 * (depending on whether the child is pci-x or pci).
 */
prop error.io.pci.badreq-pw-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pci.rta@PCIEXFN,
    error.io.pciex.badreq-u@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN;

prop error.io.pci.badreq-pw-u@PCIEXFN/PCIFN {
    is_under(pciexrc, PCIEXFN/PCIFN) } (0)->
    ereport.io.pciex.tl.ur@pciexrc,
    ereport.io.pciex.tl.ca@pciexrc;

prop error.io.pci.badreq-pw-u@PCIEXFN/PCIFN { IS_SD(PCIEXFN1) &&
    is_under(PCIEXFN1, PCIEXFN/PCIFN) } (0)->
    ereport.io.pciex.tl.ur@PCIEXFN1,
    ereport.io.pciex.tl.ca@PCIEXFN1,
    ereport.io.pci.sec-sta@PCIEXFN1,
    error.io.pciex.nonfatal@PCIEXFN1;

prop error.io.pci.badreq-drw-u@PCIEXFN/PCIFN (0)->
    ereport.io.pci.ma@PCIEXFN,
    ereport.io.pci.rta@PCIEXFN,
    error.io.pciex.badreq-u@PCIEXFN,
    ereport.io.pci.sec-sta@PCIEXFN;

prop error.io.pci.badreq-drw-u@PCIEXFN/PCIFN {
    is_under(pciexrc, PCIEXFN/PCIFN) } (0)->
    ereport.io.pciex.tl.ur@pciexrc,
    ereport.io.pciex.tl.ca@pciexrc;

prop error.io.pci.badreq-drw-u@PCIEXFN/PCIFN { IS_SD(PCIEXFN1) &&
    is_under(PCIEXFN1, PCIEXFN/PCIFN) } (0)->
    ereport.io.pciex.tl.ur@PCIEXFN1,
    ereport.io.pciex.tl.ca@PCIEXFN1,
    ereport.io.pci.sec-sta@PCIEXFN1,
    error.io.pciex.nonfatal@PCIEXFN1;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * target- propagations
 * 
 * A Root Complex driver may generate "target-" ereports when knowledge of the
 * physical address associated with a fault allows the target device to be
 * determined. This is not a requirement of the Diagnosis Engine, but can be
 * valuable when available.
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event error.io.pci.target-ma-d@PCIEXFN/PCIFN;
event error.io.pci.target-rta-d@PCIEXFN/PCIFN;
event ereport.io.pci.target-rta@PCIEXFN{within(5s)};
event ereport.io.pci.target-ma@PCIEXFN{within(5s)};

prop error.io.pci.target-ma-d@PCIEXFN (0)->
    ereport.io.pci.target-ma@PCIEXFN,
    ereport.io.pci.target-ma@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    error.io.pci.target-ma-d@PCIEXFNHZ/PCIFNHZ { is_under(PCIEXFN, PCIEXFNHZ) };

prop error.io.pci.target-rta-d@PCIEXFN (0)->
    ereport.io.pci.target-rta@PCIEXFN,
    ereport.io.pci.target-rta@PCIEXFNHZ { is_under(PCIEXFN, PCIEXFNHZ) },
    error.io.pci.target-rta-d@PCIEXFNHZ/PCIFNHZ { is_under(PCIEXFN,PCIEXFNHZ) };

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * stub unused pciex-pci bridge ereports
 * - ignore usc/sec-unex-spl
 * - ignore sec-spl-or/sec-spl-dly as these aren't really faults (tuning info)
 * - ignore ecc.ue ereports (we get everything we need from dpe/mdpe)
 * - ignore ecc.ce ereports for now (could do serd on these)
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

event ereport.io.pciex.bdg.usc@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-unex-spl@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-spl-or@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-spl-dly@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-ecc.ce-addr@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-ecc.ce-attr@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-ecc.ce-data@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-ecc.ue-addr@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-ecc.ue-attr@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-ecc.ue-data@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-s-ce@PCIEXFN{within(5s)};
event ereport.io.pcix.sec-s-ue@PCIEXFN{within(5s)};

event upset.io.pciex.discard-bdg@PCIEXFN;

prop upset.io.pciex.discard-bdg@PCIEXFN (1)->
    ereport.io.pciex.bdg.usc@PCIEXFN,
    ereport.io.pcix.sec-unex-spl@PCIEXFN,
    ereport.io.pcix.sec-spl-or@PCIEXFN,
    ereport.io.pcix.sec-spl-dly@PCIEXFN,
    ereport.io.pcix.sec-ecc.ce-addr@PCIEXFN,
    ereport.io.pcix.sec-ecc.ce-attr@PCIEXFN,
    ereport.io.pcix.sec-ecc.ce-data@PCIEXFN,
    ereport.io.pcix.sec-ecc.ue-addr@PCIEXFN,
    ereport.io.pcix.sec-ecc.ue-attr@PCIEXFN,
    ereport.io.pcix.sec-ecc.ue-data@PCIEXFN,
    ereport.io.pcix.sec-s-ce@PCIEXFN,
    ereport.io.pcix.sec-s-ue@PCIEXFN;
