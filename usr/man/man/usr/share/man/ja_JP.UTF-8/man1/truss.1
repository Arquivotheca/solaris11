'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
.TH truss 1 "2011 年 6 月 7 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
truss \- システムコールとシグナルの追跡
.SH 形式
.LP
.nf
\fBtruss\fR [\fB-fcaeildDE\fR] [\fB-\fR [tTvx] [!] \fIsyscall\fR ,...] 
     [\fB-\fR [sS] [!] \fIsignal\fR ,...] [\fB-\fR [mM] [!] \fIfault\fR ,...] 
     [\fB-\fR [rw] [!] \fIfd\fR ,...] 
     [\fB-\fR [uU] [!] \fIlib\fR ,... : [:] [!] \fIfunc\fR ,...] 
     [\fB-o\fR \fIoutfile\fR] \fIcommand\fR | \fB-p\fR \fIpid\fR[\fI/lwps\fR]...
.fi

.SH 機能説明
.sp
.LP
\fBtruss\fR ユーティリティーは指定されたコマンドを実行し、それ自体が実行するシステムコール、受け取ったシグナル、および検出したマシン障害の追跡情報を生成します。追跡出力の各行には、障害またはシグナルの名前、あるいはシステムコール名とその引数および戻り値が示されます。システムコールの引数は、可能なかぎの、関連するシステムヘッダー内の定義に従って記号で表示されます (パス名へのポインタ引数の場合、ポイント先の文字列が表示される)。エラーが発生した場合の戻り値は、\fBIntro\fR(3) のマニュアルページに説明されているエラーコード名を使用して報告されます。エラーが発生して、カーネルが失われた特権を報告する場合、特権名 (\fBprivileges\fR(5) を参照) は、エラーコード名の後に、角括弧 (\fB[ ]\fR) で囲まれて報告されます。エラーレポートの詳細については、「注意事項」を参照してください。\fB\fR
.sp
.LP
\fBtruss\fR は、\fB-u\fR オプションにより、追跡するプロセスによって実行されたユーザーレベルの関数呼び出しの開始および終了時の追跡情報も生成します。この場合、入れ子レベルを示すためにインデントが行われます。
.SH オプション
.sp
.LP
リスト引数を受け付けるオプションでは、リスト内のすべての可能なメンバーを指定する短縮形として名前 \fBall\fR を使用できます。リストが \fB!\fR で始まるオプションは否定を意味します (たとえば、追跡せずに除外するなど)。同じオプションを複数回指定できます。リスト内の同じ名前に対しては、あとから指定されたオプションが先に指定されているオプション (リスト内で左側にあるもの) を無効にします。
.sp
.LP
次のオプションがサポートされています。 
.sp
.ne 2
.mk
.na
\fB\fB-a\fR\fR
.ad
.sp .6
.RS 4n
各 \fBexec()\fR システムコールに渡される引数文字列を表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR\fR
.ad
.sp .6
.RS 4n
追跡情報を 1 行ずつ表示するのではなく、追跡されたシステムコール、障害、およびシグナルをカウントします。追跡されたコマンドが終了するか、あるいは \fBtruss\fR が割り込まれたときに、要約レポートが生成されます。\fB-f\fR も指定すると、子プロセスについて追跡されたシステムコール、障害、およびシグナルもすべてカウントに含められます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-d\fR\fR
.ad
.sp .6
.RS 4n
追跡出力の各行にタイムスタンプを含めます。タイムスタンプは、\fIseconds\fR\|. \fIfraction\fR という形式で行頭に示されます。これは、追跡の開始時からの経過秒数を示したものです。追跡出力の最初の行には、個々のタイムスタンプ測定の基点となるベースタイムが、epoch からの経過秒数 (\fBtime\fR(2) のマニュアルページを参照) と日付文字列 (\fBctime\fR(3C) および \fBdate\fR(1) のマニュアルページを参照) の両方の形式で表示されます。報告される時間は、当該イベントが発生した時間です。どのシステムコールについても、イベントはシステムコールの終了時であり、システムコールの開始時ではありません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-D\fR\fR
.ad
.sp .6
.RS 4n
追跡出力の各行にデルタタイムを含めます。\fIseconds\fR\|. \|\fIfraction\fR という形式で示されるこの値は、\fBLWP\fR が呼び出したイベントの前回の報告以降にそのイベントが次に発生した時点までの経過時間を示します。システムコールの場合、これはシステムコール内で経過した時間ではありません。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR\fR
.ad
.sp .6
.RS 4n
各 \fBexec()\fR システムコールに渡される環境文字列を表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-E\fR\fR
.ad
.sp .6
.RS 4n
追跡出力の各行にデルタタイムを含めます。\fIseconds\fR\fB\&.\fR\fIfraction\fR という形式で示されるこの値は、システムコールが始まってから終わるまでの経過時間を示します。 
.sp
\fB-D\fR オプションとは異なり、この時間は、システムコール内で費やされた総時間です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR\fR
.ad
.sp .6
.RS 4n
\fBfork()\fR または \fBvfork()\fR によって作成されたすべての子プロセスを追跡し、それらのシグナル、障害、およびシステムコールを追跡出力に含めます。通常は、最初のコマンドまたはプロセスだけが追跡されます。\fB-f\fR を指定すると、追跡出力の各行にプロセス ID が表示され、どのプロセスがシステムコールを実行したか、あるいはどのプロセスがシグナルを受信したかが示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-i\fR\fR
.ad
.sp .6
.RS 4n
割り込み可能な休眠状態のシステムコールを表示しません。端末デバイスまたはパイプ上での \fBopen()\fR や \fBread()\fR など、特定のシステムコールは不確定時間に休眠でき、割り込み可能です。一般に、システムコールが 1 秒を超えてそのような休眠状態になっている場合、\fBtruss\fR はそれらを報告します。システムコールは完了時に再度、報告されます。\fB-i\fR オプションは、そのようなシステムコールを、完了時のみの 1 度だけ報告します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-l\fR\fR
.ad
.sp .6
.RS 4n
追跡出力の各行に対応する軽量プロセス (\fILWP\fR) の ID を含めます。\fB-f\fR も指定すると、プロセス ID と LWP ID の両方を含めます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-m\fR [\fB!\fR]\fIfault\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
追跡または除外するマシン障害を指定します。コンマで区切ったリストに指定した障害が追跡されます。障害は、名前または番号で指定できます (\fB<sys/fault.h>\fR を参照)。リストが \fB!\fR で始まる場合、指定された障害は追跡出力から除外されます。デフォルトは \fB-mall\fR \fB-m\fR \fB!fltpage\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-M\fR [\fB!\fR]\fIfault\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
プロセスを停止するマシン障害を指定します。指定した障害は、\fB-m\fR で指定されるセットに追加されます。指定された障害の 1 つが見つかると、\fBtruss\fR はプロセスを停止したままにし、終了します (\fB-T\fR オプションを参照)。デフォルトは \fB\fR\fB-M\fR\fB!all\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR \fIoutfile\fR\fR
.ad
.sp .6
.RS 4n
追跡出力に使用されるファイル。デフォルトでは、出力は標準エラー出力に送られます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR\fR
.ad
.sp .6
.RS 4n
\fBtruss\fR に指定される \fIcommand\fR 引数を、実行されるコマンドとしてではなく、既存のプロセス (\fBps\fR(1) のマニュアルページを参照) のプロセス ID のリストとして解釈します。プロセスのユーザー ID とグループ ID が実行するユーザーの ID と一致するか、あるいはユーザーが特権ユーザーである場合、\fBtruss\fR は各プロセスを制御し、それらの追跡を開始します。ユーザーは、選択した (つまり、\fB/\fR\fIthread-id\fR をプロセス ID に追加した) スレッドだけを追跡できます。複数のスレッドを選択するには、区切り文字「\fB-\fR」と「\fB,\fR」を使用します。たとえば、「\fB/1,2,7-9\fR」は、スレッド \fB1\fR、\fB2\fR、\fB7\fR、\fB8\fR、および \fB9\fR を追跡します。プロセスの指定は、\fB/proc\fR ディレクトリ内の名前を指定することによっても行えます (例: \fB/proc/12345\fR)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-r\fR [\fB!\fR]\fIfd\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
指定したファイル記述子の \fBread()\fR ごとに、入出力バッファーの全内容を表示します。\fB\fR出力は行当たり 32 バイトに整形され、各バイトは \fBASCII\fR 文字 (先頭に 1 個のブランクが入る)、または、水平タブ (\et) や復帰改行 (\en) などの制御文字のために 2 文字の C 言語エスケープシーケンスとして表示されます。ただし、\fBASCII\fR 解釈が不可能な場合は、2 文字の 16 進表現となります (\fB-r\fR が指定されない場合でも追跡された各 \fBprint >read()\fR の入出力バッファーの最初の 12 バイトは表示される)。\fB\fRデフォルトは \fB\fR\fB-r\fR\fB!all\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR [\fB!\fR]\fIsignal\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
追跡または除外するシグナルを指定します。コンマで区切ったリストに指定したシグナルを追跡します。シグナルが無視される (ブロックされてない) 場合でも、追跡出力には、指定された各シグナルの受信が示されます (ブロックされているシグナルはブロックが解放されるまで受信されない)。シグナルは、名前または番号で指定できます (\fB<sys/signal.h>\fR を参照)。リストが \fB!\fR で始まる場合、指定されたシグナルは追跡出力から除外されます。デフォルトは \fB-sall\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-S\fR [\fB!\fR]\fIsignal\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
プロセスを停止するシグナルを指定します。指定されたシグナルは、\fB-s\fR で指定されるセットに追加されます。指定されたシグナルのどれかが受信された場合、\fBtruss\fR はプロセスを停止したままにし、終了します (\fB-T\fR オプションを参照)。デフォルトは \fB\fR\fB-S\fR\fB!all\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR [\fB!\fR]\fIsyscall\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
追跡または除外するシステムコールを指定します。コンマで区切ったリストに指定されたシステムコールの追跡が行われます。リストが \fB!\fR で始まる場合、指定したシステムコールが追跡出力から除外されます。デフォルトは \fB-tall\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-T\fR [\fB!\fR]\fIsyscall\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
プロセスを停止するシステムコールを指定します。指定されたシステムコールが、\fB-t\fR によって指定されるセットに追加されます。指定されたシステムコールの 1 つが見つかると、\fBtruss\fR はプロセスを停止したままにし、終了します。つまり、\fBtruss\fR はプロセスを解放して実行を終了しますが、当該システムコールの完了時にそのプロセスを停止状態のままにします。これにより、停止したプロセスにデバッガなどのプロセス検査ツール (\fBproc\fR(1) のマニュアルページを参照) を適用できるようになります。追跡を継続するには、同じオプションまたは異なるオプションを指定して、停止されたプロセスに \fBtruss\fR を適用し直します。デフォルトは \fB\fR\fB-T\fR\fB!all\fR です。
.sp
この方法で停止されたままになったプロセスは、アプリケーション \fBkill\fR \fB-CONT\fR によって再開することはできません。これは、停止シグナル (\fBsignal.h\fR(3HEAD) のマニュアルページを参照) のデフォルトアクションによってではなく、\fB/proc\fR を介したイベント上でこのプロセスが停止されているためです。停止中のプロセスを再実行するように設定するには、\fBproc\fR(1) のマニュアルページで説明されている \fBprun\fR(1) コマンドを使用できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-u\fR [\fB!\fR]\fIlib\fR,...\fB:\fR[\fB:\fR][\fB!\fR]\fIfunc\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
ユーザーレベルの関数呼び出しを追跡します。\fIlib\fR,\|.\|.\|. は、動的なライブラリ名 (\fB\&.so.\fR\fIn\fR 接尾辞を除く) をコンマで区切ったリストです。\fIfunc\fR,\|.\|.\|. は、関数名をコンマで区切ったリストです。どちらの場合でも、名前の表現にメタ文字 \fB*\fR、\fB?\fR、\fB[]\fR を使用できます。これらのメタ文字の指定は \fBsh\fR(1) における指定と同じ意味を持ちますが、ファイルに対してではなくライブラリ名または関数名に対して使用されることになります。ライブラリまたは関数のリストを空にすると、デフォルトで \fB*\fR が使用され、ライブラリ内のすべてのライブラリまたは関数が追跡されます。リストの先頭に \fB!\fR を付けると、追跡から除外されるライブラリまたは関数の名前を指定したことになります。1 つのライブラリを除外すると、そのライブラリ内のすべての関数が除外されます。つまり、ライブラリ除外リストのあとに続く関数リストは無視されます。
.sp
関数リストとライブラリリストを分離する 1 つの \fB:\fR は、ライブラリの外部から、それらのライブラリに対する呼び出しは追跡しますが、ライブラリ内部の他の関数からの呼び出しは除外することを意味します。2 つの \fB:\|:\fR は、呼び出し元に関係なくすべての呼び出しを追跡することを意味します。
.sp
ライブラリのパターンには、正確な一致がないかぎり、実行可能ファイルと動的リンカーのいずれとも対応付けはしません (\fBl*\fR は \fBld.so.1\fR に対応付けられない)。これらのオブジェクトのどちらかに含まれる関数を追跡するには、次のように名前を明確に指定する必要があります。
.sp
.in +2
.nf
\fBtruss -u a.out -u ld ...\fR
.fi
.in -2
.sp

\fBa.out\fR はこの目的で使用されるリテラル名であり、実行可能ファイルの名前を意味するわけではありません。\fBa.out\fR 関数呼び出しを追跡すると、すべての呼び出しが暗黙に追跡されます (デフォルトは \fB:\|:\fR)。
.sp
\fB-u\fR オプションは複数回指定することが可能で、この場合左から順に受け付けられます。プロセスが lthread にリンクしている場合は、呼び出しの追跡出力に関数呼び出しを行なったスレッドの ID が含められます。\fBtruss\fR は、関数名を見つけるために各ライブラリ内の動的シンボルテーブルを検索するとともに、ストリップされてなければ標準のシンボルテーブルも検索します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-U\fR [\fB!\fR]\fIlib\fR,\|.\|.\|.\|\fB:\fR[\fB:\fR][\fB!\fR]\fIfunc\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
プロセスを停止するユーザーレベルの関数呼び出しを指定します。指定される関数は、\fB-u\fR で指定されるセットに追加されます。指定された関数の 1 つが呼び出されると、\fBtruss\fR はプロセスを停止したままにし、終了します (\fB-T\fR オプションを参照)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-v\fR [\fB!\fR]\fIsyscall\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
冗長。指定されたシステムコールに対してアドレスで渡された任意の構造体の内容を表示します (\fB-t\fR による追跡が行われた場合)。入力した値とオペレーティングシステムによって返される値が示されます。入力と出力の両方に使用されるフィールドについては、出力値だけが示されます。デフォルトは \fB\fR\fB-v\fR\fB!all\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR [\fB!\fR]\fIfd\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
指定したファイル記述子の \fBwrite()\fR ごとに入出力バッファの内容を表示します (\fB-r\fR オプションを参照)。デフォルトは \fB\fR\fB-w\fR\fB!all\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR [\fB!\fR]\fIsyscall\fR,\|.\|.\|.\fR
.ad
.sp .6
.RS 4n
指定されたシステムコールの引数を raw 形式で表示します (\fB-t\fR による追跡が行われた場合)。これは、通常、記号表示ではなく 16 進表示であり、raw ビットのままの方が良いと考えるハッカーのためのものです。デフォルトは \fB\fR\fB-x\fR\fB!all\fR です。
.RE

.sp
.LP
\fB-t\fR、\fB-T\fR、\fB-v\fR、および \fB-x\fR オプションが受け付けるシステムコール名については、『\fI『man pages section 2: System Calls』\fR』を参照してください。システムコール番号も指定できます。
.sp
.LP
指定したコマンドを開始および追跡するのに \fBtruss\fR を使用する場合、\fB-o\fR オプションを使用するか、あるいは標準エラー出力を端末以外のファイルにリダイレクトすると、\fBtruss\fR はハングアップ、割り込みシグナル、および終了シグナルを無視して動作します。これにより、端末からの割り込みシグナルと終了シグナルを受け取る対話型プログラムの追跡が容易になります。
.sp
.LP
追跡出力を端末に転送したままにした場合、あるいは、既存のプロセスを追跡する (\fB-p\fR オプション) 場合、\fBtruss\fR は追跡したすべてのプロセスを解放して処理を終了するので、ハングアップ、割り込み、終了の各シグナルに応答します。これにより、ユーザーは過度の追跡出力を抑制でき、既存のプロセスを解放できるようになります。解放されたプロセスは、なんの影響も受けず、それまでどおりの通常の処理を継続します。
.sp
.LP
既存のプロセスを追跡すると、truss はプロセスを解放して、truss 終了時に実行中に設定します。これには、\fBSIGINT\fR、\fBSIGHUP\fR、\fBSIGQUIT\fR などのシグナルによる終了も含まれます。これにより、ユーザーは過度の追跡出力を抑制でき、既存のプロセスを解放できるようになります。解放されたプロセスは、なんの影響も受けず、それまでどおりの通常の処理を継続します。
.SH 使用例
.LP
\fB例 1 \fRコマンドを追跡する
.sp
.LP
この例は、端末上の \fBfind\fR(1) コマンドの追跡情報を生成します。

.sp
.in +2
.nf
example$ \fBtruss find . -print >find.out\fR
.fi
.in -2
.sp

.LP
\fB例 2 \fR一般的なシステムコールを追跡する
.sp
.LP
オープン、クローズ、読み取り、書き込みの各システムコールの追跡情報だけを表示するには、次のように指定します。

.sp
.in +2
.nf
example$ \fBtruss -t open,close,read,write find . -print >find.out\fR 
.fi
.in -2
.sp

.LP
\fB例 3 \fRシェルスクリプトを追跡する
.sp
.LP
この例は、ファイル \fBtruss.out\fR 上の \fBspell\fR(1) コマンドの追跡情報を生成します。

.sp
.in +2
.nf
example$ \fBtruss -f -o truss.out spell \fIdocument\fR\fR
.fi
.in -2
.sp

.sp
.LP
\fBspell\fR はシェルスクリプトであるため、シェルだけでなくシェルによって生成されたプロセスも追跡するためには \fB-f\fR フラグが必要です (spell スクリプトは 8 つのプロセスのパイプラインを実行する)。

.LP
\fB例 4 \fR出力を簡潔にする
.sp
.LP
出力を簡潔にする例を示します。

.sp
.in +2
.nf
example$ \fBtruss nroff -mm \fIdocument\fR >nroff.out\fR 
.fi
.in -2
.sp

.sp
.LP
この例は、出力の 97% が \fBlseek()\fR、\fBread()\fR、および \fBwrite()\fR システムコールの追跡情報であり、冗長です。出力を簡潔にまとめるには次のように指定します。

.sp
.in +2
.nf
example$ \fBtruss -t !lseek,read,write nroff -mm \fIdocument\fR >nroff.out\fR 
.fi
.in -2
.sp

.LP
\fB例 5 \fRC ライブラリの外部からのライブラリ呼び出しを追跡する
.sp
.LP
この例は、C ライブラリの外部から C ライブラリ内の任意の関数に対して行われるユーザーレベルの呼び出しをすべて追跡します。

.sp
.in +2
.nf
example$ \fBtruss -u libc ...\fR
.fi
.in -2
.sp

.LP
\fB例 6 \fRC ライブラリ内からのライブラリ呼び出しを追跡する
.sp
.LP
この例では、C ライブラリからその C ライブラリ自体の関数に対して行われる呼び出しが含められます。

.sp
.in +2
.nf
example$ \fBtruss -u libc:: ...\fR
.fi
.in -2
.sp

.LP
\fB例 7 \fRC ライブラリ以外のライブラリ呼び出しを追跡する
.sp
.LP
この例は、C ライブラリ以外のすべてのライブラリに対して行われるユーザーレベルの呼び出しをすべて追跡します。

.sp
.in +2
.nf
example$ \fBtruss -u '*' -u !libc ...\fR
.fi
.in -2
.sp

.LP
\fB例 8 \fR\fBpritf\fR および \fBscanf\fR 関数呼び出しを追跡する
.sp
.LP
この例は、C ライブラリに含まれる printf および scanf ファミリ内の関数に対するユーザーレベルの呼び出しをすべて追跡します。

.sp
.in +2
.nf
example$ \fBtruss -u 'libc:*printf,*scanf' ...\fR
.fi
.in -2
.sp

.LP
\fB例 9 \fRユーザーレベルの関数呼び出しをすべて追跡する
.sp
.LP
この例は、任意の場所から任意の場所に対して行われるユーザーレベルの関数呼び出しをすべて追跡します。

.sp
.in +2
.nf
example$ \fBtruss -u a.out -u ld:: -u :: ...\fR
.fi
.in -2
.sp

.LP
\fB例 10 \fRシステムコールの追跡結果を詳細に表示する
.sp
.LP
この例は、プロセス #1 の \fBinit\fR(1M) システムコールのアクティビティーを追跡し、詳細な追跡情報を表示します (特権ユーザーがこのコマンドを実行できます)。

.sp
.in +2
.nf
example# \fBtruss -p -v all 1\fR
.fi
.in -2
.sp

.sp
.LP
\fBtruss\fR に割り込みを行うと、\fBinit\fR は通常の動作に戻ります。

.SH ファイル
.sp
.ne 2
.mk
.na
\fB\fB/proc/*\fR\fR
.ad
.RS 11n
.rt  
プロセスファイル
.RE

.SH 属性
.sp
.LP
属性についての詳細は、マニュアルページの \fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件system/core-os
.TE

.SH 関連項目
.sp
.LP
\fBdate\fR(1), \fBfind\fR(1), \fBproc\fR(1), \fBps\fR(1), \fBsh\fR(1), \fBspell\fR(1), \fBinit\fR(1M), \fBIntro\fR(3), \fBexec\fR(2), \fBfork\fR(2), \fBlseek\fR(2), \fBopen\fR(2), \fBread\fR(2), \fBtime\fR(2), \fBvfork\fR(2), \fBwrite\fR(2), \fBctime\fR(3C), \fBsignal.h\fR(3HEAD), \fBproc\fR(4), \fBattributes\fR(5), \fBmwac\fR(5), \fBprivileges\fR(5), \fBthreads\fR(5)
.sp
.LP
\fI『man pages section 2: System Calls』\fR
.SH 注意事項
.sp
.LP
『\fI『man pages section 2: System Calls』\fR』で説明されているシステムコールの中には、実際のオペレーティングシステムインタフェースとは異なるものがあります。追跡情報が、この説明と若干異なる場合もあります。
.sp
.LP
マシン障害 (ページフォルトは除く) が発生するたびに、障害の原因となった \fBLWP\fR にシグナルが送られます。シグナルがブロックされない場合、各マシン障害 (ページフォルトを除く) が通知された直後に、受信シグナルが通知されます。
.sp
.LP
オペレーティングシステムは、プロセスの追跡に一定のセキュリティ制限を課します。具体的には、ユーザーは、自身が読み取りできないオブジェクトファイル (\fBa.out\fR) を持つコマンドを追跡することはできません。set-uid と set-gid をもつコマンドは、特権ユーザー以外は追跡できません。特権ユーザーが実行する場合を除き、\fBtruss\fR は set-id または読み取り不可能なオブジェクトファイルの \fBexec()\fR を実行するプロセスを制御できません。このようなプロセスは、\fBtruss\fR からは独立して、\fBexec()\fR ポイントで通常どおり処理を継続します。
.sp
.LP
ほかの制御プロセスとの衝突を防ぐため、\fBtruss\fR は、\fB/proc\fR インタフェースを介してほかのプロセスによって制御されているプロセスを追跡しません。このため、\fBtruss\fR を \fBproc\fR(4) ベースのデバッガだけでなく、それ自身の別のインスタンスにも適用できます。
.sp
.LP
8 カラムごとに標準のタブストップが設定されていると仮定して、追跡出力にはタブ文字が含まれます。
.sp
.LP
複数のプロセスまたはマルチスレッドプロセス (複数の \fBLWP)\fR を含むプロセス) の追跡出力は、厳密に時間順には生成されません。たとえば、パイプにおける \fBread()\fR は、対応する \fBwrite()\fR よりも前に報告される場合があります。しかし、個々の \fBLWP\fR (従来型のプロセスには 1 つしか含まれない) について出力は、厳密に時間順に行なわれます。
.sp
.LP
複数のプロセスを追跡する場合、\fBtruss\fR は追跡対象のプロセスごとに 1 つの制御プロセスとして動作します。前述の \fBspell\fR コマンドの例の場合、\fBspell\fR 自身が 9 つのプロセススロット (シェル用に 1 つ、8 メンバーを持つパイプライン用に 8 つ) を使用し、\fBtruss\fR がさらに 9 つのプロセスを追加するため、プロセススロットは合計で 18 になります。
.sp
.LP
\fB-v\fR オプションでは、すべてのシステムコールで渡すことができるあらゆる構造体を表示できるわけではありません。
.sp
.LP
\fBtruss\fR は、失われた特権が原因で発生したシステムコールによって返されたエラーをレポートする場合、エラーコードと単純な特権名を続けて表示するか、または特権の詳細な説明を表示します。\fBprivileges\fR(5) を参照してください。詳細な説明には、以下の内容を含めることができます。
.sp
.ne 2
.mk
.na
\fB\fB[ALL]\fR\fR
.ad
.RS 14n
.rt  
このプロセスでは、要求された操作のための特権がすべて必要になります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB[MULTIPLE]\fR\fR
.ad
.RS 14n
.rt  
このプロセスには、複数の特権はありません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB[ZONE]\fR\fR
.ad
.RS 14n
.rt  
このプロセスでは、ゾーン (\fBALL\fR のゾーンローカルバリアント) で使用できる特権の 1 つがありません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB[GLOBAL]\fR\fR
.ad
.RS 14n
.rt  
要求された操作では、プロセスがグローバルゾーンで実行されている必要があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB[MWAC]\fR\fR
.ad
.RS 14n
.rt  
要求された操作は、プロセス用に定められている \fBmwac\fR(5) ポリシーに違反しています。
.RE

