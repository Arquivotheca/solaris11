'\" te
.\" Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
.TH mdb 1 "2011 年 8 月 24 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
mdb \- モジュラーデバッガ
.SH 形式
.LP
.nf
\fBmdb\fR [\fB-fkmuwyAFKMSUW\fR] [\(+-o \fIoption\fR] [\fB-p\fR \fIpid\fR] [\fB-s\fR \fIdistance\fR] 
     [\fB-I\fR \fIpath\fR] [\fB-L\fR \fIpath\fR] [\fB-P\fR \fIprompt\fR] [\fB-R\fR \fIroot\fR] 
     [\fB-V\fR \fIdis-version\fR] [object [core] | core | suffix]
.fi

.SH 機能説明
.SS "はじめに"
.sp
.LP
\fBmdb\fR ユーティリティーは、稼働中のオペレーティングシステム、オペレーティングシステムのクラッシュダンプ、ユーザープロセス、ユーザープロセスのコアダンプ、およびオブジェクトファイルの低レベルのデバッグと編集を行うための拡張可能なユーティリティーです。\fBmdb\fR の機能の詳細については、マニュアル\fI『Oracle Solaris Modular Debugger Guide』\fRを参照してください。
.sp
.LP
デバッギングとは、欠陥を取り除くために、ソフトウェアプログラムの実行と状態を分析するプロセスのことです。従来のデバッグ用のツールは、実行制御の機能を備えたもので、それによって、プログラマは制御された環境でプログラムを実行し直したり、プログラムデータの現在の状態を表示したり、プログラム開発に使用するソース言語の表現を評価したりできます。
.sp
.LP
残念ながら、これらの手法は、バグが再現しない、プログラムの状態が大規模で分散しているオペレーティングシステムなどの複雑なソフトウェアシステムのデバッグには適さないことがよくあります。また、高度に最適化され、デバッグ情報が削除されている、それ自体が低レベルのデバッグ用ツールであるプログラムや、開発者が事後情報にしかアクセスできない顧客環境にも適しません。
.sp
.LP
\fBmdb\fR では、前述のようなプログラムや状況をデバッグするために、徹底的にカスタマイズできます。mdb に含まれている動的なモジュール機能を使用して、プログラム固有の分析を行う場合に、プログラマ独自のデバッギングコマンドを実行できます。プログラムの実行時、事後分析時などさまざまな状況で、各 \fBmdb\fR モジュールをプログラム検査に使用できます。
.SS "定義"
.sp
.LP
ターゲットとは、デバッガによって検査されるプログラムのことです。\fI\fR\fBmdb\fR は現在、次の種類のターゲットをサポートしています。ユーザープロセス、ユーザープロセスのコアファイル、稼働中のオペレーティングシステム (\fB/dev/kmem\fR および \fB/dev/ksyms\fR 経由)、オペレーティングシステムのクラッシュダンプ、オペレーティングシステムのクラッシュダンプ内に記録されたユーザープロセスイメージ、\fBELF\fR オブジェクトファイル、および raw バイナリファイル。各ターゲットは、1 つ以上のアドレス空間、1 つ以上のシンボルテーブル、ロードオブジェクトセット、後述のデバッガコマンドを使って検査できるスレッドセットなど、プロパティーの標準セットをエクスポートします。
.sp
.LP
デバッガコマンド (\fBmdb\fR 用語法では、\fIdcmd\fR と表記し、「ディーコマンド」と読む) は、デバッガルーチンで、現ターゲットのどのプロパティーにもアクセスできます。\fBmdb\fR は、標準入力からコマンドを構文解析し、次に対応する dcmd を実行します。各 dcmd は、文字列や数値引数のリストも受け取ることができます (後述の構文の説明を参照)。あとで説明しますが、\fBmdb\fR には、常に使用可能な組み込み dcmd セットが入っています。独自の dcmd を記述して、\fBmdb\fR そのものの機能を拡張することもできます (\fI『Oracle Solaris Modular Debugger Guide』\fRを参照)。
.sp
.LP
\fIwalker\fR は、特定のプログラムデータ構造体の要素を調べたり、繰り返し調べたりする方法を記述するルーチンセットです。walker は、dcmd や \fBmdb\fR そのものからデータ構造体の実装状態をカプセル化します。walker は、対話処理でも使用でき、ほかの dcmd や walker を構築するためのプリミティブとしても使用できます。dcmd の場合と同様に、独自の walker をデバッガモジュールの一部として実装することにより、\fBmdb\fR を拡張できます。
.sp
.LP
デバッガモジュール (\fIdmod\fR と表記し、「ディーモッド」と読む) は、動的に読み込まれるライブラリで、一連の dcmd と walker が含まれています。初期設定の状態では、\fBmdb\fR は、ターゲット内に存在するロードオブジェクトに対応する dmod を読み込もうとします。その後、\fBmdb\fR を実行している間はいつでも、dmod の読み込みや読み込み解除ができます。\fBmdb\fR には、Solaris カーネルをデバッグするための標準 dmod セットが付属しています。独自のデバッガモジュールの開発に関する詳細は、\fI『Oracle Solaris Modular Debugger Guide』\fRを参照してください。
.sp
.LP
「マクロファイル」とは、実行するコマンドセットが入っているテキストファイルのことです。\fI\fR一般的に、マクロファイルは、単純データ構造体の表示プロセスを自動化するときに使用されます。\fBmdb\fR には、\fBadb\fR(1) 用に記述されたマクロファイルの実行に関して完全な下位互換性があり、Solaris インストールには、エディタツールで使用できる Solaris カーネルのデバッグ用マクロファイルセットが含まれています。
.SS "構文"
.sp
.LP
デバッガは、標準入力からコマンドを処理します。端末からの標準入力の場合、\fBmdb\fR では端末編集機能が使用できます。また、\fBmdb\fR は、マクロファイルからのコマンドや dcmd パイプラインからのコマンドも処理できます。これについては後述します。言語構文は、ターゲット内のメモリーアドレスに代表されるような、式の値を計算し、次に dcmd をそのアドレスに適用するという構想に基づいて設計されています。現在のアドレス位置はドットとして参照され、その値は「.」を使って参照されます。\fI\fR
.sp
.LP
メタキャラクタには、次のような文字があります。\fI\fR
.sp
.in +2
.nf
[   ]   |   !   /   \e   ?   =   >   $   :   ;   
            \fINEWLINE\fR   \fISPACE\fR   \fITAB\fR
.fi
.in -2
.sp

.sp
.LP
ブランク (\fIblank\fR) はタブ (\fITAB\fR) またはスペース文字 (\fISPACE\fR) です。ワード (\fIword\fR) とは、1 つまたは複数の引用符なしのメタキャラクタで区切られた文字列のことです。ただし、コンテキストによっては単に区切り記号として機能するメタキャラクタもあるので、これについては後述します。識別子とは、文字、下線、またはピリオドで始まる、一連の文字列、数字、下線、ピリオド、逆引用符のことです。\fI\fR識別子は、シンボル名、変数、dcmd、 walker として使用されます。コマンドは、復帰改行文字やセミコロン (\fB;\fR) で区切ります。\fI\fR
.sp
.LP
dcmd は、次のようなワードまたはメタキャラクタで表されます。
.sp
.in +2
.nf
/   \e   ?   =   >   $character   :character  ::identifier
.fi
.in -2
.sp

.sp
.LP
メタキャラクタで設定された dcmd や、\fB$\fR か \fB:\fR を接頭辞として 1 つ持つ dcmd は、組み込み演算子として提供され、レガシー \fBadb\fR(1) ユーティリティーのコマンドセットとの互換性を備えています。dcmd が解析されると、\fB/\fR、\fB\e\fR、\fB?\fR、\fB=\fR、\fB>\fR、\fB$\fR、\fB:\fR の各文字は、引数リストが終了するまでメタキャラクタとして認識されなくなります。
.sp
.LP
単純コマンドとは、空白文字で区切られた、0 個以上の一連のワードが後ろに続く dcmd のことです。\fI\fRこれらのワードは、呼び出される dcmd に引数として渡されます。ただし、後述の「クォート」と「算術展開」で特に指定されているワードは例外です。\fB\fR各 dcmd は、処理の成功、失敗、または無効な引数を受け取ったことを示す終了ステータスを返します。
.sp
.LP
パイプライン (\fIpipeline\fR) は、パイプ (\fB|\fR) で区切られた 1 つ以上の単純コマンドの並びです。シェルの場合とは異なり、\fBmdb\fR のパイプラインの dcmd は、別々のプロセスとしては実行されません。mdb では、パイプラインが構文解析されたあとに、それぞれの dcmd が左から右へと順に呼び出されます。各 dcmd の出力は、処理されたあとに格納されます (後述の「dcmd パイプライン」を参照)。\fB\fR左側の dcmd 処理が終了すると、その出力はパイプライン内の次の dcmd への入力として使用されます。いずれかの dcmd が終了ステータスとして正常終了を返さない場合、そのパイプラインは強制終了します。
.sp
.LP
式 (\fIexpression\fR) は一連のワードで表され、64 ビットの符号なし整数を計算するために評価されます。ワードは、後述の「算術展開」に示す規則を使用して評価されます。\fB\fR
.SS "コマンド (Commands)"
.sp
.LP
コマンドは、次のいずれかです。\fI\fR
.sp
.ne 2
.mk
.na
\fB\fIpipeline\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
単純コマンドまたはパイプラインは、接尾辞として感嘆符 (\fB!\fR) を付けることもできます。この場合、デバッガは \fBpipe\fR(2) を開いたあと、\fBmdb\fR パイプライン内の最後の dcmd の標準出力を、\fB$SHELL\fR \fB-c\fR の実行により作成された外部プロセスへ送ります。c オプションのあとには、感嘆符 (\fB!\fR) の後ろのワードを結合して生成される文字列が続きます。詳細については、後述の「シェルエスケープ」を参照してください。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fIexpression\fR \fIpipeline\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
単純コマンドまたはパイプラインは、接頭辞として式を付けることもできます。この場合、パイプラインが実行される前に、ドットの値 (「\fB\&.\fR」で表される変数) が式の値に設定されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fIexpression\fR \fB,\fR \fIexpression\fR \fIpipeline\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
単純コマンドまたはパイプラインは、接頭辞として式を 2 つ付けることもできます。最初の式は新しいドット値を判定するために評価され、2 番目の式はパイプライン内の最初の dcmd の繰り返し回数を判定するために評価されます。この場合、dcmd は、判定された回数繰り返し実行し、そのあとにパイプライン内の次の dcmd を実行します。\fI\fR繰り返し回数は、パイプライン内の最初の dcmd にだけ適用されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB,\fR \fIexpression\fR \fIpipeline\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
式の値に応じて、パイプライン内の最初の dcmd が繰り返されます。ただし、先頭の式が省略されている場合、ドットは変更されません。
.RE

.sp
.ne 2
.mk
.na
\fB\fIexpression\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
コマンドは、算術式だけで構成される場合があります。この場合、式が評価されたあと、その値にドット変数が設定されます。次に、直前の dcmd と引数が新しいドット値を使用して実行されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fIexpression\fR\fB,\fR \fIexpression\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
コマンドは、ドット式と繰り返し回数式だけで構成される場合があります。この場合、最初の式の値がドットに設定されたあと、2 番目の式で指定された回数、直前の dcmd と引数が繰り返し実行されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB,\fR \fIexpression\fR [\fB!\fR \fIword\fR .\|.\|.] [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
直前の dcmd と引数が、繰り返し回数式の値で指定された回数、繰り返し実行されます。ただし、先頭の式が省略されている場合は、ドットは変更されません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!\fR \fIword\fR .\|.\|. [ \fB;\fR ]\fR
.ad
.sp .6
.RS 4n
コマンドが感嘆符 (\fB!\fR) で始まっている場合、どの dcmd も実行されません。つまり、デバッガは感嘆符 (\fB!\fR) の後ろに指定されたワードを結合して、その文字列を \fB$SHELL\fR \fB-c\fR の後ろに指定して実行するだけです。
.RE

.SS "コメント"
.sp
.LP
\fB//\fR を付けると、その後の復帰改行文字まで、ワードや文字列がすべて無視されます。\fI\fR
.SS "演算機能の拡張"
.sp
.LP
\fBmdb\fR コマンドの前に、開始アドレスを表すオプション式や、開始アドレスと繰り返し回数を表すオプション式がある場合は、演算機能が拡張されます。また、dcmd に使用する数値引数を計算する場合にも、演算機能が拡張されます。演算式は、ドル記号の後ろに角括弧で囲んだ引数リスト (\fB$[ expression ]\fR) で表され、その式の値に置き換えられます。
.sp
.LP
式には、次の特殊ワードのどれかを使用できます。
.sp
.ne 2
.mk
.na
\fB\fIinteger\fR\fR
.ad
.sp .6
.RS 4n
特定の整数値。整数値は、接頭辞として \fB0i\fR または \fB0I\fR を付けると 2 進数値、\fB0o\fR または \fB0O\fR を付けると 8 進数値、\fB0t\fR または \fB0T\fR を付けると 10 進数値、\fB0x\fR または \fB0X\fR を付けると 16 進数値 (デフォルト) を表します。
.RE

.sp
.ne 2
.mk
.na
\fB0[tT][0-9]+.[0-9]+\fR
.ad
.sp .6
.RS 4n
指定された 10 進数の浮動小数点値。\fBIEEE\fR 倍精度浮動小数点表示に変換されます.
.RE

.sp
.ne 2
.mk
.na
\fB\&'\fIcccccccc\fR'\fR
.ad
.sp .6
.RS 4n
各文字を \fBASCII\fR 値に等しいバイトに変換することによって計算された整数値。最大 8 文字までを文字定数に指定できます。文字列は、最下位のバイトから始まって、右から左へと逆方向に整数の中へ格納されます。
.RE

.sp
.ne 2
.mk
.na
\fB<\fIidentifier\fR\fR
.ad
.sp .6
.RS 4n
識別子 (\fIidentifier\fR) によって指定される変数値。
.RE

.sp
.ne 2
.mk
.na
\fB\fIidentifier\fR\fR
.ad
.sp .6
.RS 4n
識別子 (\fIidentifier\fR) によって指定されるシンボル値。
.RE

.sp
.ne 2
.mk
.na
\fB(\fIexpression\fR)\fR
.ad
.sp .6
.RS 4n
式 (\fIexpression\fR) の値。
.RE

.sp
.ne 2
.mk
.na
\fB\&.\fR
.ad
.sp .6
.RS 4n
ドット値.
.RE

.sp
.ne 2
.mk
.na
\fB&\fR
.ad
.sp .6
.RS 4n
dcmd を実行するために使用される最新のドット値.
.RE

.sp
.ne 2
.mk
.na
\fB+\fR
.ad
.sp .6
.RS 4n
現在のインクリメントによって増分されるドット値.
.RE

.sp
.ne 2
.mk
.na
\fB^\fR
.ad
.sp .6
.RS 4n
現在のインクリメントによって減分されるドット値.
.RE

.sp
.LP
インクリメントとは、最後にフォーマット dcmd によって読み込まれる合計バイトを格納する大域変数のことです。インクリメントの詳細については、後述の「フォーマット dcmd」を参照してください。\fB\fR
.sp
.LP
単項演算子は右結合で、2 項演算子よりも優先順位は高くなります。単項演算子を次に示します。
.sp
.ne 2
.mk
.na
\fB#\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
論理否定.
.RE

.sp
.ne 2
.mk
.na
\fB~\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ビット単位の補数.
.RE

.sp
.ne 2
.mk
.na
\fB-\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
整数否定.
.RE

.sp
.ne 2
.mk
.na
\fB%\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の仮想アドレス式に対応するオブジェクトファイル位置でのポインタサイズの数量値。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB%/[csil]/\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の仮想アドレス式に対応するオブジェクトファイル位置での char サイズ、short サイズ、int サイズ、または long サイズの数量値。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB%/[1248]/\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の仮想アドレス式に対応するオブジェクトファイル位置での 1 バイト、2 バイト、4 バイト、または 8 バイトの数量値。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB*\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の仮想アドレス式でのポインタサイズの数量値。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB*/[csil]/\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の仮想アドレス式での char サイズ、short サイズ、int サイズ、または long サイズの数量値。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB*/[1248]/\fIexpression\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の仮想アドレス式での 1 バイト、2 バイト、4 バイト、または 8 バイトの数量値。\fI\fR
.RE

.sp
.LP
2 項演算子は左結合で、単項演算子よりも優先順位は低くなります。次に 2 項演算子を、優先度の高いものから順に示します。
.sp
.ne 2
.mk
.na
\fB\fB*\fR\fR
.ad
.sp .6
.RS 4n
整数の乗算.
.RE

.sp
.ne 2
.mk
.na
\fB\fB%\fR\fR
.ad
.sp .6
.RS 4n
整数の除算.
.RE

.sp
.ne 2
.mk
.na
\fB\fB#\fR\fR
.ad
.sp .6
.RS 4n
左辺を右辺の最小の倍数に切り上げる.
.RE

.sp
.ne 2
.mk
.na
\fB\fB+\fR\fR
.ad
.sp .6
.RS 4n
整数の加算.
.RE

.sp
.ne 2
.mk
.na
\fB\fB-\fR\fR
.ad
.sp .6
.RS 4n
整数の減算.
.RE

.sp
.ne 2
.mk
.na
\fB\fB<<\fR\fR
.ad
.sp .6
.RS 4n
ビット単位で左へシフト.
.RE

.sp
.ne 2
.mk
.na
\fB\fB>>\fR\fR
.ad
.sp .6
.RS 4n
ビット単位で右へシフト.
.RE

.sp
.ne 2
.mk
.na
\fB\fB==\fR\fR
.ad
.sp .6
.RS 4n
等しい.
.RE

.sp
.ne 2
.mk
.na
\fB\fB!=\fR\fR
.ad
.sp .6
.RS 4n
異なる.
.RE

.sp
.ne 2
.mk
.na
\fB\fB&\fR\fR
.ad
.sp .6
.RS 4n
ビット単位の論理積.
.RE

.sp
.ne 2
.mk
.na
\fB\fB\fR^\fR
.ad
.sp .6
.RS 4n
ビット単位の排他的論理和.
.RE

.sp
.ne 2
.mk
.na
\fB\fB|\fR\fR
.ad
.sp .6
.RS 4n
ビット単位の論理和.
.RE

.SS "クォート"
.sp
.LP
「構文」で説明したように、各メタキャラクタは引用符で囲まないとワードを終了します。\fB\fR\fBmdb\fR を使用して各文字を特別な意味のない文字そのものとして解釈させるには、それらを単一引用符 (\fB\&' '\fR) または二重引用符 (\fB" "\fR) で囲めば、文字列として引用できます。単一引用符を、単一引用符で囲んで表示させることはできません。二重引用符内では、\fBmdb\fR は C プログラミング言語の文字エスケープシーケンスを認識します。
.SS "シェルエスケープ"
.sp
.LP
\fB!\fR 文字を使用して、\fBmdb\fR コマンドとユーザーのシェル間のパイプラインを作成できます。$\fBSHELL\fR 環境変数が設定されている場合、\fBmdb\fR はそのプログラムをシェルエスケープのためにフォーク (fork) したり、実行 (exec) したりします。変数が設定されていない場合は、\fB/bin/sh\fR コマンドが使用されます。シェルは、\fB-c\fR オプション付きで呼び出されます。\fBc\fR オプションのあとには、感嘆符 (!) の後ろのワードを結合して生成される文字列が続きます。\fB!\fR 文字は、ほかのどのメタキャラクタよりも高い優先度を持っています。 ただし、セミコロン (\fB;\fR) と復帰改行文字は例外です。\fI\fRシェルエスケープが検出されたら、次のセミコロンまたは復帰改行文字までの残りの文字列は、そのままシェルへ渡されます。\fI\fRシェルの出力コマンドを \fBmdb\fR dcmd へパイプすることはできません。シェルエスケープによって実行されたコマンドは、その出力を \fBmdb\fR へは送らずに、直接端末へ送ります。
.SS "変数"
.sp
.LP
変数は、変数名、対応する整数値、および一連の属性を持ちます。\fI\fR変数名は、一連の文字列、数字、下線、ピリオドなどで表されます。変数には、\fB>\fR dcmd や \fB::typeset\fR dcmd を使用して値を割り当てることができます。また、その属性は、\fB::typeset\fR dcmd を使用して変更できます。各変数の値は、64 ビットの符号なし整数として表されます。変数は、1 つまたは複数の属性を持つことができます。 たとえば、読み取り専用 (ユーザーによって変更されない)、固定表示 (ユーザーによって設定解除されない)、タグ (ユーザー定義のインジケータ) などです。
.sp
.LP
次の変数の属性は固定表示として定義されています。
.sp
.ne 2
.mk
.na
\fB0\fR
.ad
.sp .6
.RS 4n
\fB/\fR、\fB\e\fR、\fB?\fR、\fB=\fR の dcmd を使用して出力された最新の値。
.RE

.sp
.ne 2
.mk
.na
\fB9\fR
.ad
.sp .6
.RS 4n
\fB$<\fR dcmd とともに使用された最新のカウント。
.RE

.sp
.ne 2
.mk
.na
\fBb\fR
.ad
.sp .6
.RS 4n
データセクションの基底仮想アドレス。
.RE

.sp
.ne 2
.mk
.na
\fBd\fR
.ad
.sp .6
.RS 4n
データセクションのバイトサイズ。
.RE

.sp
.ne 2
.mk
.na
\fBe\fR
.ad
.sp .6
.RS 4n
エントリポイントの仮想アドレス。
.RE

.sp
.ne 2
.mk
.na
\fBm\fR
.ad
.sp .6
.RS 4n
ターゲットの一次オブジェクトファイルの初期バイト (マジックナンバー)。オブジェクトファイルがまだ読み出されていない場合はゼロ。
.RE

.sp
.ne 2
.mk
.na
\fBt\fR
.ad
.sp .6
.RS 4n
テキストセクションのバイトサイズ。
.RE

.sp
.ne 2
.mk
.na
\fBhits\fR
.ad
.sp .6
.RS 4n
一致したソフトウェアイベント指定子が一致した回数。後述の「イベントコールバック」を参照してください。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fBthread\fR
.ad
.sp .6
.RS 4n
現在の代表スレッドのスレッド識別子。この識別子の値は、現在のターゲットが使用しているスレッド化モデルによって変わります。後述の「スレッドのサポート」を参照してください。\fB\fR
.RE

.sp
.LP
さらに、\fBmdb\fR カーネルとプロセスターゲットは、代表スレッドのレジスタセットの現在値を設定変数としてエクスポートします。これらの変数の名前は、ターゲットのプラットフォームや命令セットのアーキテクチャーによって決まります。
.SS "シンボルの名前解決"
.sp
.LP
前述の「構文」で説明しているように、式コンテキスト内にあるシンボル識別子は該当するシンボルの値を求めるために評価します。\fB\fR一般的に、この値は、ターゲットの仮想アドレス空間内のシンボルと関連付けられる、記憶領域の仮想アドレスを表します。ターゲットは、一次実行可能シンボルテーブル、一次動的シンボルテーブル、実行時リンクエディタシンボルテーブル、およびロードオブジェクト (ユーザープロセスの共有ライブラリや Solaris カーネルのカーネルモジュールなど) の各番号の標準シンボルテーブルと動的シンボルテーブルを含む (ただし、これらに限定されません) 複数のシンボルテーブルをサポートできます。一般的に、ターゲットは、最初に一次実行可能シンボルテーブルを検索し、次にほかの 1 つまたは複数のシンボルテーブルを検索します。\fBELF\fR シンボルテーブルには、外部シンボル、大域シンボル、静的シンボルなどへのエントリだけが含まれます。自動シンボルは、\fBmdb\fR によって処理されるシンボルテーブルにはありません。
.sp
.LP
さらに、\fBmdb\fR が提供する専用のユーザー定義シンボルテーブルは、ほかのどのターゲットシンボルテーブルよりも先に検索されます。専用シンボルテーブルは、最初は空の状態ですが、\fB::nmadd\fR dcmd や \fB::nmdel\fR dcmd を使用して操作できます。\fB::nm\fR \fB-P\fR オプションは、専用のシンボルテーブルの内容を表示するために使用されます。専用のシンボルテーブルによって、元のプログラムでは抜け落ちていたプログラム機能やデータのシンボル定義を作成できます。次からは、\fBmdb\fR がシンボル名をアドレスに変換したり、アドレスをもっとも近くのシンボルへ変換したりするときにはいつでも、これらの定義が使用可能となります。
.sp
.LP
ターゲットには複数のシンボルテーブルが含まれていて、各シンボルテーブルには複数のオブジェクトファイルからシンボルを入れることができるので、同じ名前で異なるシンボルが存在することもあります。このような場合に、プログラマが希望するシンボル値を得られるように、\fBmdb\fR はシンボル名適用範囲演算子として、逆引用符 (\fB`\fR) を使用します。プログラマは、シンボル名の解釈に使用する範囲を次のように指定できます。つまり、\fIobject\fR\fB`\fR\fIname\fR、\fIfile\fR\fB`\fR\fIname\fR、または \fIobject\fR\fB`\fR\fIfile\fR\fB`\fR\fIname\fR です。オブジェクトの識別子は、ロードオブジェクトの名前を参照します。ファイル識別子は、ソースファイルのベース名を参照します。ソースファイルは、指定されたオブジェクトのシンボルテーブル内に \fBSTT_FILE\fR 型のシンボルを持っています。オブジェクト識別子の解釈は、ターゲットタイプによって決まります。
.sp
.LP
\fBmdb\fR カーネルターゲットでは、オブジェクトが、読み込まれたカーネルモジュールのベース名を指定すると考えられます。\fI\fRたとえば、次のシンボル名を考えてみましょう。
.sp
.in +2
.nf
specfs`_init
.fi
.in -2
.sp

.sp
.LP
これは、 \fBspecfs\fR カーネルモジュール内の \fB_init\fR シンボルの値を求めるために評価します。
.sp
.LP
\fBmdb\fR プロセスターゲットでは、オブジェクトが、実行可能な名前、または読み込まれた共用ライブラリの名前を指定すると考えられます。\fI\fRこの場合、次の形式のどれかが使用されます。
.RS +4
.TP
1.
完全一致 (つまり、フルパス名): \fB/usr/lib/libc.so.1\fR
.RE
.RS +4
.TP
2.
ベース名に完全に一致: \fBlibc.so.1\fR
.RE
.RS +4
.TP
3.
ベース名の冒頭から接尾辞の「\fB\&.\fR」まで一致: \fBlibc.so\fR または \fBlibc\fR
.RE
.RS +4
.TP
4.
リテラル文字列 \fBa.out\fR は、実行可能な名前の別名として受け入れられます。
.RE
.sp
.LP
プロセスターゲットも前述の 4 つの形式を受け入れることができますが、この場合、接頭辞としてオプションのリンクマップ ID (lmid) が付きます。lmid 接頭辞は、\fBLM\fR、リンクマップ ID (16 進数)、および逆引用符の順番で構成されます。たとえば、次のシンボル名を考えてみましょう。
.sp
.in +2
.nf
LM0`libc.so.1`_init
.fi
.in -2
.sp

.sp
.LP
これは、\fBlibc.so.1\fR ライブラリにある \fB_init\fR シンボルの値として評価して、この値がリンクマップ 0 (\fBLM_ID_BASE\fR) 上に読み込まれます。同じライブラリが複数のリンクマップ上に読み込まれている場合、シンボル名の重複を解決するためにリンクマップ指定子が必要になることもあります。リンクマップの詳細については、\fI『Linker and Libraries Guide』\fRおよび \fBdlopen\fR(3C) を参照してください。リンクマップ識別子を表示するには、\fBshowlmid\fR オプションの設定に従ってシンボルを出力します (「オプション」を参照)。
.sp
.LP
シンボルと 16 進整数値で名前が重複した場合、\fBmdb\fR は、最初にあいまいなトークンをシンボルとして評価し、次に整数値として評価しようとします。たとえば、\fBf\fR というトークンが、デフォルトの 16 進数では 10 進整数の \fB15\fR を表し、同時にターゲットのシンボルテーブル内の \fBf\fR という名前の大域変数を表す場合もあります。あいまいな名前を持つシンボルが存在するときには、明示的な \fB0x\fR または \fB0X\fR の接頭辞を用いることによって、整数値を明確に指定できます。
.SS "dcmd と walker の名前解決"
.sp
.LP
前述のように、\fBmdb\fR の各 dmod は、一連の dcmd と walker を提供します。dcmd と walker は、2 つの異なる大域名前空間でトラックされます。また、\fBmdb\fR も、各 dmod に関連付けられた dcmd と walker の名前空間をトラックし続けます。1 つの dmod 内で、dcmd や walker に同じ名前を付けることはできません。このような名前の重複がある dmod は、読み込みに失敗します。異なる dmod から提供された dcmd や walker 間での名前の重複は、大域名前空間では許されます。名前の重複がある場合、その特定の読み込まれる名前を持つ dcmd または walker のうち、最初のものが大域名前空間で優先権を与えられます。ほかの定義は、読み取り順にリストに保存されます。逆引用符 (\fB`\fR) は、ほかの定義を選択するための参照範囲演算子として、dcmd や walker の名前に使用されます。たとえば、dmod \fBm1\fR と \fBm2\fR が、それぞれ dcmd \fBd\fR を提供する場合に、\fBm1\fR の方が \fBm2\fR よりも先に読み込まれたときには、次のようになります。
.sp
.ne 2
.mk
.na
\fB\fB::d\fR\fR
.ad
.sp .6
.RS 4n
\fBm1\fR の \fBd\fR 定義を実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::m1`d\fR\fR
.ad
.sp .6
.RS 4n
\fBm1\fR の \fBd\fR 定義を実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::m2`d\fR\fR
.ad
.sp .6
.RS 4n
\fBm2\fR の \fBd\fR 定義を実行します。
.RE

.sp
.LP
現時点で \fBm1\fR モジュールが読み込まれていない場合は、大域定義リスト上の次の dcmd である \fBm2`d\fR が、大域定義として使用されます。dcmd や walker の現在の定義は、次に示すように、\fB::which\fR dcmd を使用して定義できます。大域定義リストは、\fB::which\fR \fB-v\fR を使用して表示できます。
.SS "dcmd パイプライン"
.sp
.LP
dcmd は、縦棒演算子 (\fB|\fR) を使ってパイプラインの中へ入れることができます。パイプラインの目的は、一般的に仮想アドレスのような値のリストを、1 つの dcmd や walker から次の dcmd や walker へと渡していくことです。パイプラインステージは、あるデータ構造体タイプのポインタを、それに対応するデータ構造体のポインタへと対応付けるために使用します。その目的は、アドレスリストをソートしたり、あるプロパティーを持つ構造体のアドレスを選択したりすることです。
.sp
.LP
\fBmdb\fR は、パイプライン内の各 dcmd を左から右へと順番に実行します。現在のドット値、またはコマンドの開始時に明示的な式によって指定された値を使って、もっとも左にある dcmd が実行されます。縦棒演算子 (\fB|\fR) を見つけると、\fBmdb\fR は、その左側までの dcmd 出力、\fBmdb\fR 構文解析部、および空の値リストとの間に、パイプすなわち共用バッファーを作成します。dcmd を実行するにしたがって、その標準出力はパイプの中に配置され、次に構文解析部によって使用され、評価されます。それは、あたかも \fBmdb\fR が標準出力からデータを読み込んでいるように見えます。各行には、終端に復帰改行文字またはセミコロン (\fB;\fR) を持つ算術式が含まれます。\fI\fRその算術式の値は、パイプに関連付けられた値のリストに追加されます。構文エラーが発見されると、そのパイプラインは異常終了します。
.sp
.LP
縦棒演算子 (\fB|\fR) の左側までの dcmd が完了すると、そのパイプに関連付けられた値のリストは、縦棒演算子 (\fB|\fR) の右側の dcmd を呼び出すために使用されます。リストの各値については、ドットにその値が設定されたあと、右側の dcmd が実行されます。パイプラインのもっとも右にある dcmd だけが、その出力を標準出力に表示します。パイプライン内のいずれかの dcmd が標準エラー出力を生じた場合は、それらのメッセージを直接標準エラーに出力するので、パイプラインの一部としては処理されません。
.SS "シグナル処理"
.sp
.LP
デバッガは、\fBPIPE\fR および \fBQUIT\fR シグナルを無視します。\fBINT\fR シグナルの場合、現在実行中のコマンドが中止されます。\fBILL\fR、\fBTRAP\fR、\fBEMT\fR、\fBFPE\fR、\fBBUS\fR、および \fBSEGV\fR のシグナルの場合、デバッガは中断され、特別な処理を行います。これらのシグナルが非同期的に生成された場合 (つまり、\fBkill\fR(2) を使用して別のプロセスから配信された場合)、\fBmdb\fR はシグナルをそのデフォルトの設定に復元して、コアダンプを生成します。しかし、これらのシグナルがデバッガプロセス自身によって同期的に生成され、外部的に読み込まれた dmod から dcmd が現在実行されており、さらに、標準入力が端末である場合、ユーザーは \fBmdb\fR が提供するメニューを使用して、強制的にコアダンプを生成するか、コアダンプを生成せずに終了するか、停止してデバッガに接続するか、あるいは、そのまま再開するかを選択できます。再開オプションを選択した場合、すべてのアクティブなコマンドは中止され、障害が発生したときに dcmd がアクティブであった dmod を読み込み解除します。この後、ユーザーは dmod を読み込み直すことができます。dcmd にバグがある場合に対して、再開オプションは制限付きの保護機能を提供します。再開オプションの危険性については、後述の「警告」にある「エラー回復メカニズムの使用」を参照してください。\fB\fR
.SS "コマンド行の再入力"
.sp
.LP
端末デバイスから入力した最後の \fBHISTSIZE\fR (デフォルトは 128) 個のコマンドのテキストはメモリーに保存されます。次に説明するインライン編集機能が提供するキーマッピングを使用すると、この履歴リストから以前入力したコマンドを検索および取得できます。
.SS "インライン編集機能"
.sp
.LP
標準入力が端末デバイスである場合、コマンド行を編集するために、\fBmdb\fR が提供するいくつかのシンプルな emacs スタイルの機能を使用できます。編集モードの \fBsearch\fR、\fBprevious\fR、および \fBnext\fR コマンドを使用すると、履歴リストにアクセスできます。検索するときに一致するのは、パターンではなく、文字列だけです。次に示すリストにおいて、制御記号はキャレット文字 (\fB^\fR) とそれに続く大文字の英字で表記されます。エスケープシーケンスは \fBM-\fR とそれに続く文字で表記されます。たとえば、\fBM-f\fR (「メタエフ」と呼ぶ) を入力するには、まず <ESC> を押して、次に「\fBf\fR」を押すか、あるいは \fBMeta\fR キーをサポートしているキーボード上では、まず Meta キーを押して、次に「\fBf\fR」を押します。コマンド行を発行および実行するには、復帰改行文字 (\fIRETURN\fR または \fINEWLINE\fR) を使用します。編集コマンドは次のとおりです。
.sp
.ne 2
.mk
.na
\fB^F\fR
.ad
.sp .6
.RS 4n
カーソルを 1 文字だけ前方 (右) に移動します。
.RE

.sp
.ne 2
.mk
.na
\fBM-f\fR
.ad
.sp .6
.RS 4n
カーソルを 1 単語だけ前方に移動します。
.RE

.sp
.ne 2
.mk
.na
\fB^B\fR
.ad
.sp .6
.RS 4n
カーソルを 1 文字だけ後方 (左) に移動します。
.RE

.sp
.ne 2
.mk
.na
\fBM-b\fR
.ad
.sp .6
.RS 4n
カーソルを 1 単語だけ後方に移動します。
.RE

.sp
.ne 2
.mk
.na
\fB^A\fR
.ad
.sp .6
.RS 4n
カーソルを行の先頭に移動します。
.RE

.sp
.ne 2
.mk
.na
\fB^E\fR
.ad
.sp .6
.RS 4n
カーソルを行の末尾に移動します。
.RE

.sp
.ne 2
.mk
.na
\fB^D\fR
.ad
.sp .6
.RS 4n
カーソルのある行が空でない場合、カーソル位置の文字を削除します。カーソルのある行が空である場合、\fB^D\fR は \fBEOF\fR を意味し、デバッガは終了します。
.RE

.sp
.ne 2
.mk
.na
\fBM-^H\fR
.ad
.sp .6
.RS 4n
(メタ - バックスペース) 直前の単語を削除します。
.RE

.sp
.ne 2
.mk
.na
\fB^K\fR
.ad
.sp .6
.RS 4n
カーソルから行の末尾までを削除します。
.RE

.sp
.ne 2
.mk
.na
\fB^L\fR
.ad
.sp .6
.RS 4n
画面を消去して、現在の行を出力し直します。
.RE

.sp
.ne 2
.mk
.na
\fB^T\fR
.ad
.sp .6
.RS 4n
現在の文字と次の文字を入れ換えます。
.RE

.sp
.ne 2
.mk
.na
\fB^N\fR
.ad
.sp .6
.RS 4n
履歴リストから次のコマンドを取得します。\fB^N\fR を入力するたびに、さらに次のコマンドが取得されます。
.RE

.sp
.ne 2
.mk
.na
\fB^P\fR
.ad
.sp .6
.RS 4n
履歴リストから前のコマンドを取得します。\fB^P\fR を入力するたびに、さらに前のコマンドが取得されます。
.RE

.sp
.ne 2
.mk
.na
\fB^R[\fIstring\fR]\fR
.ad
.sp .6
.RS 4n
履歴リストから文字列を含むコマンドを後方に検索します。\fI\fR文字列は復帰改行文字 (\fIRETURN\fR または \fINEWLINE\fR) で終了する必要があります。文字列を省略した場合、前回入力した文字列を含むコマンドを検索します。\fI\fR
.RE

.sp
.LP
編集モードはまた、次のようなユーザー定義シーケンスも編集コマンドとして解釈します。ユーザー定義シーケンスを読み取ったり、変更したりするには、\fBstty\fR(1) コマンドを使用します。
.sp
.ne 2
.mk
.na
\fBerase\fR
.ad
.sp .6
.RS 4n
ユーザー定義の消去文字 (通常は \fB^H\fR または \fB^?\fR)。前の 1 文字を削除します。
.RE

.sp
.ne 2
.mk
.na
\fBintr\fR
.ad
.sp .6
.RS 4n
ユーザー定義の割り込み文字 (通常は \fB^C\fR)。現在のコマンドを中断して、新しいプロンプトを出力します。
.RE

.sp
.ne 2
.mk
.na
\fBkill\fR
.ad
.sp .6
.RS 4n
ユーザー定義の強制終了文字 (通常は \fB^U\fR)。現在のコマンド行全体を強制終了します。
.RE

.sp
.ne 2
.mk
.na
\fBquit\fR
.ad
.sp .6
.RS 4n
ユーザー定義の終了文字 (通常は \fB^\e\fR)。デバッガを終了します。
.RE

.sp
.ne 2
.mk
.na
\fBsuspend\fR
.ad
.sp .6
.RS 4n
ユーザー定義の中断文字 (通常は \fB^Z\fR)。デバッガを中断します。
.RE

.sp
.ne 2
.mk
.na
\fBwerase\fR
.ad
.sp .6
.RS 4n
ユーザー定義の単語消去文字 (通常は \fB^W\fR)。直前の単語を消去します。
.RE

.sp
.LP
矢印キーのある拡張キーパッドをサポートするキーボードでは、\fBmdb\fR は次のキーストロークを編集コマンドとして解釈します。
.sp
.ne 2
.mk
.na
\fBup-arrow\fR
.ad
.sp .6
.RS 4n
履歴リストから前のコマンドを取得します (\fB^P\fR と同じ)。
.RE

.sp
.ne 2
.mk
.na
\fBdown-arrow\fR
.ad
.sp .6
.RS 4n
履歴リストから次のコマンドを取得します (\fB^N\fR と同じ)。
.RE

.sp
.ne 2
.mk
.na
\fBleft-arrow\fR
.ad
.sp .6
.RS 4n
カーソルを 1 文字だけ後方に移動します (\fB^B\fR と同じ)。
.RE

.sp
.ne 2
.mk
.na
\fBright-arrow\fR
.ad
.sp .6
.RS 4n
カーソルを 1 文字だけ前方に移動します (\fB^F\fR と同じ)。
.RE

.SS "出力ページャー"
.sp
.LP
\fBmdb\fR は、組み込み出力ページャーを備えています。出力ページャーを使用できるのは、デバッガの標準出力が端末デバイスである場合だけです。コマンドを実行するたびに、\fBmdb\fR は 1 画面分の出力を生成してから中断し、次のようなページャーのプロンプトを表示します。
.sp
.in +2
.nf
 >> More [<space>, <cr>, q, n, c, a] ?
.fi
.in -2
.sp

.sp
.LP
出力ページャーは次のようなキーシーケンスを認識します。
.sp
.ne 2
.mk
.na
\fB\fIスペース文字\fR\fR
.ad
.sp .6
.RS 4n
次の 1 画面分の出力を表示します。
.RE

.sp
.ne 2
.mk
.na
\fBa、A\fR
.ad
.sp .6
.RS 4n
現在のトップレベルのコマンドを中止して、プロンプトに戻ります。
.RE

.sp
.ne 2
.mk
.na
\fBc、C\fR
.ad
.sp .6
.RS 4n
現在のトップレベルのコマンドが完了するまで、画面ごとに中断するのではなく、出力を表示し続けます。
.RE

.sp
.ne 2
.mk
.na
\fBn、N、復帰改行文字 (\fINEWLINE\fR または \fIRETURN\fR)\fR
.ad
.sp .6
.RS 4n
次の 1 行分の出力を表示します。
.RE

.sp
.ne 2
.mk
.na
\fBq、Q、^C、^\e\fR
.ad
.sp .6
.RS 4n
現在の dcmd を終了 (中止) します。
.RE

.SS "フォーマット dcmd"
.sp
.LP
\fB/\fR、\fB\e\fR、\fB?\fR、\fB=\fR などのメタキャラクタを使用して、特別な出力書式の dcmd を表します。各 dcmd では、1 つまたは複数の書式制御文字を含む引数リスト、繰り返し回数、または引用文字列を使用できます。書式制御文字は、次の表に示すように、\fBASCII\fR 文字の一種です。書式制御文字を使用して、ターゲットからデータを読み取り、フォーマットします。繰り返し回数は、書式制御文字の前に位置する正の整数で、基数は、常に 10 進数として解釈されます。また、繰り返し回数は、先頭にドル記号を付けた角括弧で囲まれた式 (\fB$[ ]\fR) として指定される場合もあります。文字列の引数は、二重引用符 (\fB" "\fR) で囲みます。フォーマット引数の間には、空白は不要です。
.sp
.LP
フォーマット dcmd は、次のとおりです。
.sp
.ne 2
.mk
.na
\fB\fB/\fR\fR
.ad
.sp .6
.RS 4n
ドットで指定される仮想アドレスで始まるターゲットの仮想アドレス空間からデータを表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\e\fR\fR
.ad
.sp .6
.RS 4n
ドットで指定される物理アドレスで始まるターゲットの物理アドレス空間からデータを表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB?\fR\fR
.ad
.sp .6
.RS 4n
ドットで指定される仮想アドレスに対応するオブジェクトファイル位置で始まるターゲットの一次オブジェクトファイルからデータを表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB=\fR\fR
.ad
.sp .6
.RS 4n
指定されたデータ書式のそれぞれにおいて、ドット値そのものを表示します。したがって、\fB=\fR dcmd は、基底間の変換と計算を行うときに便利です。
.RE

.sp
.LP
また、\fBmdb\fR は、ドットのほかに、インクリメントと呼ばれる大域値も絶えずトラックしています。\fI\fRインクリメントは、ドットと、最後のフォーマット dcmd によって読み込まれるすべてのデータが後に続くアドレスとの距離を表します。たとえば、フォーマット dcmd を、A というアドレスに等しいドットで実行した結果、4 バイトの整数が出力された場合、この dcmd が終了したあとには、ドットはまだ A ですが、インクリメントは \fB4\fR に設定されています。前述の「算術展開」で説明したように、ここでは、正符号 (\fB+\fR) は、\fBA + 4\fR の値を出すための評価をします。その後、正符号は、次に続く dcmd 用のデータオブジェクトのアドレスにドットを設定し直します。\fB\fR
.sp
.LP
次の表に示すように、ほとんどの書式制御文字は、データ書式のサイズに対応するバイトの数だけ、インクリメントの値を増分します。書式制御文字表は、\fB::formats\fR dcmd を使用して、\fBmdb\fR の内部から表示できます。書式制御文字は、次のとおりです。
.sp

.sp
.TS
tab();
lw(.69i) lw(4.81i) 
lw(.69i) lw(4.81i) 
.
\fB+\fRT{
カウントの数だけドットを増分する (変数サイズ)
T}
\fB-\fRT{
カウントの数だけドットを減分する (変数サイズ)
T}
B16 進数 int (1 バイト)
CT{
C の文字表記法を使う文字 (1 バイト)
T}
DT{
10 進数の符号付き int (4 バイト)
T}
ET{
10 進数の符号なし long long (8 バイト)
T}
Fdouble (8 バイト)
GT{
8 進数の符号なし long long (8 バイト)
T}
HT{
スワップバイトと short (4 バイト)
T}
IT{
アドレスと分解命令 (変数サイズ)
T}
J16 進数 long long (8 バイト)
KT{
16 進数 uintptr_t (4 または 8 バイト)
T}
N改行
OT{
8 進数の符号なし int (4 バイト)
T}
Pシンボル (4 または 8 バイト)
QT{
8 進数の符号付き int (4 バイト)
T}
R2 進数 int (8 バイト)
ST{
C の文字列表記法を使った文字列 (変数サイズ)
T}
T水平タブ
UT{
10 進数の符号なし int (4 バイト)
T}
VT{
10 進数の符号なし int (1 バイト)
T}
WT{
デフォルト基数の符号なし int (4 バイト)
T}
X16 進数 int (4 バイト)
YT{
復号化される time32_t (4 バイト)
T}
Z16 進数 long long (8 バイト)
^T{
インクリメント * カウントの数だけドットを減分する (変数サイズ)
T}
asymbol+offset としてのドット
bT{
8 進数の符号なし int (1 バイト)
T}
c文字 (1 バイト)
dT{
10 進数の符号付き short (2 バイト)
T}
eT{
10 進数の符号付き long long (8 バイト)
T}
ffloat (4 バイト)
gT{
8 進数の符号付き long long (8 バイト)
T}
hスワップバイト (2 バイト)
i命令の分解 (変数サイズ)
n改行
oT{
8 進数の符号なし short (2 バイト)
T}
pシンボル (4 または 8 バイト)
qT{
8 進数の符号付き short (2 バイト)
T}
r余白
sraw 文字列 (変数サイズ)
t水平タブ
uT{
10 進数の符号なし short (2 バイト)
T}
vT{
10 進数の符号付き int (1 バイト)
T}
wT{
符号なしのデフォルト基数 short (2 バイト)
T}
x16 進数 short (2 バイト)
yT{
復号化される time64_t (8 バイト)
T}
.TE

.sp
.LP
\fB/\fR、\fB\e\fR、および \fB?\fR のフォーマット dcmd を使用して、ターゲットの仮想アドレス空間、物理アドレス空間、またはオブジェクトファイルに書き込みを行うことができます。この場合には、次の修飾子の 1 つを最初の書式制御文字として指定し、次に、即値またはドル記号のあとの角括弧に囲まれた式 (\fB$[ ]\fR) で表されるワードのリストを指定します。
.sp
.LP
書き込み修飾子は、次のとおりです。
.sp
.ne 2
.mk
.na
\fB\fBv\fR\fR
.ad
.sp .6
.RS 4n
各式の値の最下位バイトを、ドットで指定された位置から始まるターゲットに書き込む.
.RE

.sp
.ne 2
.mk
.na
\fB\fBw\fR\fR
.ad
.sp .6
.RS 4n
各式の値の最下位 2 バイトを、ドットで指定された位置から始まるターゲットに書き込む。
.RE

.sp
.ne 2
.mk
.na
\fB\fBW\fR\fR
.ad
.sp .6
.RS 4n
各式の値の最下位 4 バイトを、ドットで指定された位置から始まるターゲットに書き込む.
.RE

.sp
.ne 2
.mk
.na
\fB\fBZ\fR\fR
.ad
.sp .6
.RS 4n
各式の値の 8 バイトすべてを、ドットで指定された位置から始まるターゲットに書き込む.
.RE

.sp
.LP
\fB/\fR、\fB\e\fR、および \fB?\fR のフォーマット dcmd を使用して、ターゲットの仮想アドレス空間、物理アドレス空間、およびオブジェクトファイル内の特定の整数値をそれぞれ検索できます。この場合には、次の修飾子の 1 つを最初の書式制御文字として指定し、次に、値とオプションマスクを指定します。各値とマスクは、即値またはドル記号の後の角括弧に囲まれた式として指定されます。値だけが指定されている場合、\fBmdb\fR は、適当なサイズの整数値を読み取り、一致する値が含まれるアドレスのところで終了します。また、\fBV\fR という値と、\fBM\fR というマスクが指定されている場合、\fBmdb\fR は、適当なサイズの整数値を読み取り、\fB(X & M) == V\fR となるような値 \fBX\fR が含まれるアドレスのところで終了します。dcmd が終了すると、ドットは、一致した値が含まれるアドレスに更新されます。一致する値が見つからなかった場合、ドットは、最後に読み込まれたアドレスに残されます。
.sp
.LP
検索修飾子は、次のとおりです。
.sp

.sp
.TS
tab();
lw(.69i) lw(4.81i) 
lw(.69i) lw(4.81i) 
.
lT{
指定された 2 バイトの値を検索する.
T}
LT{
指定された 4 バイトの値を検索する.
T}
MT{
指定された 8 バイトの値を検索する.
T}
.TE

.sp
.LP
ユーザーターゲットでも、カーネルターゲットでも、アドレス空間は、一般的に不連続セグメントセットで構成されています。対応するセグメントを持たないアドレスから読み込むことはできません。セグメント内で一致するものが検索されない場合には、検索は強制的に終了します。
.SS "実行制御"
.sp
.LP
\fBmdb\fR には、動作中のプログラムの実行を制御および追跡する機能があります。現在、ユーザープロセスターゲットだけが実行制御をサポートしています。\fBmdb\fR はシンプルな実行制御モデルを提供します。ターゲットプロセスを起動するには、\fB::run\fR を使用してデバッガ内から起動するか、\fB:A\fR、\fB::attach\fR、または \fB-p\fR コマンド行オプション (後述の説明を参照) を使用して \fBmdb\fR を既存のプロセスに接続します。ユーザーは追跡対象「ソフトウェアイベント」のリストを指定できます。追跡対象イベントがターゲットプロセス内で発生するごとに、ターゲット内のすべてのスレッドが停止して、そのイベントをトリガーしたスレッドが代表スレッドとして選択され、デバッガに制御が戻ります。ターゲットプログラムが「running (動作中)」と設定されると、ユーザー定義割り込み文字 (通常は \fB^C\fR) を入力して、非同期的にデバッガに制御を戻すことができます。
.sp
.LP
「\fBソフトウェアイベント\fR」とは、デバッガが監視しているターゲットプログラムにおける状態遷移のことです。たとえば、デバッガは、プログラムカウンタレジスタが特定の値 (ブレークポイント) に変更されたり、特定のシグナルが送られたりするのを監視できます。
.sp
.LP
「\fBソフトウェアイベント指定子\fR」とは、デバッガがどのようなイベントを監視するかをターゲットプログラムに指示するときに使用するソフトウェアイベントのクラスのことです。ソフトウェアイベント指定子のリストを表示するには、\fB::events\fR dcmd を使用します。各ソフトウェアイベント指定子には標準プロパティーセットが関連付けられています (後述の「\fB::events\fR」を参照)。
.sp
.LP
デバッガはさまざまなソフトウェアイベント (たとえば、ブレークポイント、ウォッチポイント、シグナル、マシン障害、およびシステムコールなど) を監視できます。\fB::bp\fR、\fB::fltbp\fR、\fB::sigbp\fR、\fB::sysbp\fR、または \fB::wp\fR を使用すると、新しいソフトウェアイベント指定子を作成できます。各指定子には、コールバック (コマンド行に入力された場合と同じように動作する \fBmdb\fR コマンド文字列) とプロパティーセットが関連付けられています (後述の説明を参照)。異なるコールバックとプロパティーを持つのであれば、任意の数の指定子を同じイベントに作成できます。追跡対象イベントの現在のリストや対応するイベント指定子のプロパティーを表示するには、\fB::events\fR dcmd を使用します。イベント指定子のプロパティーの定義については、後述の「\fB::events\fR dcmd」と「\fB::evset\fR dcmd」を参照してください。
.sp
.LP
実行制御組み込み dcmd (後述の説明を参照) はいつでも利用できますが、実行制御がサポートされないターゲットに適用しようとすると、「このターゲットはサポートされません」というエラーメッセージが表示されます。デバッガの実行制御による exec、attach、release、およびジョブ制御との対話の詳細については、後述の「注意事項」を参照してください。
.SS "イベントコールバック"
.sp
.LP
\fB::evset\fR dcmd とイベント追跡用の dcmd を使用すると、(\fB-c\fR オプションを使用して)、イベント指定子ごとにイベントコールバックを関連付けることができます。「イベントコールバック」とは、ターゲットにおいて対応するイベントが発生したときに実行される \fBmdb\fR コマンドを表す文字列のことです。このようなコマンドは、コマンドプロンプトに入力された場合と同じように実行されます。各コールバックが実行される前に、dot 変数には代表スレッドのプログラムカウンタの値が設定され、「\fBhits\fR」変数には該当する指定子が一致した回数 (現在の一致も含む) が設定されます。
.sp
.LP
ターゲットを継続するための 1 つまたは複数のコマンド (たとえば、\fB::cont\fR や \fB::step\fR) が、イベントコールバック自身に含まれる場合、このようなコマンドはターゲットをすぐに継続したり、ターゲットがもう一度停止するまで待機したりしません。その代わりに、このようなターゲットを継続する dcmd は「現在、継続操作が中断されている」ということをイベントコールバック内部に示して、すぐに戻ります。したがって、複数の dcmd がイベントコールバックに含まれている場合、ステップまたは継続用の dcmd は最後に指定する必要があります。「\fBすべて\fR」のイベントコールバックを実行したあと、一致した「\fBすべて\fR」のイベントコールバックが継続を要求している場合、ターゲットはすぐに実行を再開します。要求された継続操作が競合する場合、どの種類の操作を継続するかは、優先順位がもっとも高い継続操作が決定します。優先順位は (高いものから)、 「ステップ (step)」、「ステップオーバー (step-over) または次 (next)」、「ステップアウト(step-out)」、そして「継続 (continue)」の順番になります。
.SS "スレッドのサポート"
.sp
.LP
\fBmdb\fR は、ターゲットに関連する各スレッドのスタックとレジスタを調査する機能を提供します。永続的な「スレッド」変数には、現在の代表スレッド識別子が入っています。\fB\fRスレッド識別子の書式はターゲットによって異なります。\fB::regs\fR dcmd と \fB::fpregs\fR dcmd を使用すると、代表スレッドのレジスタセットや、別のスレッドのレジスタセットが現在利用できる場合はそのレジスタセットを調査できます。さらに、代表スレッドのレジスタセットは名前付き変数セットとしてエクスポートされます。1 つまたは複数のレジスタの値を変更するには、対応する名前付き変数に \fB>\fR dcmd を適用します。
.sp
.LP
\fBmdb\fR カーネルターゲットは、対応する内部スレッド構造体の仮想アドレスを指定されたスレッドの識別子としてエクスポートします。Solaris カーネル内のスレッドのデバッグに関するサポートの詳細は、\fI『Oracle Solaris Modular Debugger Guide』\fRを参照してください。\fBmdb\fR プロセスターゲットは、ネイティブな \fBlwp_*\fR インタフェース、\fB/usr/lib/libthread.so\fR、または \fB/usr/lib/lwp/libthread.so\fR を使用するマルチスレッド化されたユーザープロセスの検査に対する適切なサポートを提供します。動作中のユーザープロセスをデバッグするとき、\fBmdb\fR はシングルスレッド化されたプロセスが \fBlibthread\fR を \fBdlopen\fR または close するかどうかを検出して、動作中のユーザープロセスのスレッド化モデルのビューを自動的に調整します。プロセスターゲットスレッド識別子は、アプリケーションが使用するスレッド化モデルに基づいて、代表スレッドの \fBlwpid_t\fR、\fBthread_t\fR、または \fBpthread_t\fR に対応付けられます。
.sp
.LP
\fBmdb\fR がユーザープロセスターゲットをデバッグしているとき、コンパイラによってサポートされるスレッドに局所的な記憶領域をターゲットが利用している場合、\fBmdb\fR は自動的に、スレッドに局所的な記憶領域を参照するシンボル名を、現在の代表スレッドに対応する記憶領域のアドレスで評価します。\fB::tls\fR 組み込み dcmd を使用すると、代表スレッド以外のスレッドのシンボルの値も表示できます。
.SS "組み込み dcmd"
.sp
.LP
\fBmdb\fR は、常に定義されている組み込み dcmd セットを備えています。これらの dcmd のなかには、特定のターゲットだけに適用されるものもあります。dcmd が現在のターゲットに適用できない場合、その dcmd は停止し、「コマンドが現在のターゲットに適用されません」という内容のメッセージが表示されます。\fBmdb\fR は、多くの場合、レガシー \fBadb\fR(1) dcmd の名前に対応するニーモニック (\fB::identifier\fR) を提供します。たとえば、\fB::quit\fR は、\fB$q\fR に相当します。\fBadb\fR(1) の使用経験を持つプログラマや、簡略符号あるいは難解なコマンドを認識するプログラマは、組み込みコマンドの \fB$\fR や \fB:\fR 形式の方を好むかもしれません。一方、\fBmdb\fR に慣れていないプログラマは、より詳細でわかりやすい \fB::\fR 形式を好むでしょう。次に組み込みコマンドを、アルファベット順に説明します。\fB$\fR または \fB:\fR の形式に \fB::identifier\fR に対応するものがある場合、\fB::identifier\fR 形式の下に $ または : の形式を示します。組み込み dcmd は、次のとおりです。
.sp
.ne 2
.mk
.na
\fB> \fIvariable-name\fR\fR
.ad
.br
.na
\fB\fB>\fR/\fImodifier\fR/\fIvariable-name\fR\fR
.ad
.sp .6
.RS 4n
指定された名前の変数にドット値を割り当てます。変数が読み取り専用の場合には、変更できません。\fB>\fR の後ろに \fB/ /\fR で囲まれた修飾子がある場合、ドット値は割り当ての一部として変更されます。修飾子は、次のとおりです。
.sp
.ne 2
.mk
.na
\fB\fBc\fR\fR
.ad
.sp .6
.RS 4n
符号なし char の量 (1 バイト)
.RE

.sp
.ne 2
.mk
.na
\fB\fBs\fR\fR
.ad
.sp .6
.RS 4n
符号なし short の量 (2 バイト)
.RE

.sp
.ne 2
.mk
.na
\fB\fBi\fR\fR
.ad
.sp .6
.RS 4n
符号なし int の量 (4 バイト)
.RE

.sp
.ne 2
.mk
.na
\fB\fBl\fR\fR
.ad
.sp .6
.RS 4n
符号なし long の量 (32 ビットでは 4 バイト、64 ビットでは 8 バイト)
.RE

これらの演算子はキャストを実行しません。代わりに、指定された数の下位バイト (リトルエンディアンアーキテクチャーの場合) または上位バイト (ビッグエンディアンアーキテクチャーの場合) を取得します。修飾子には下位互換性があります。ただし、\fBmdb\fR の */\fImodifier\fR/ および %/\fImodifier\fR/ 構文を使用する必要があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$<\fR \fImacro-name\fR\fR
.ad
.sp .6
.RS 4n
指定したマクロファイルからコマンドを読み取り、実行します。ファイル名は、絶対パスまたは相対パスとして与えられます。ファイル名に「\fB/\fR」が含まれない場合は単純名です。単純名の場合、\fBmdb\fR は、マクロファイル組み込みパス内でそのファイル名を検索します。現時点で別のマクロファイルが処理されている場合、そのファイルは閉じられ、代わりに新しいファイルが処理されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$<<\fR \fImacro-name\fR\fR
.ad
.sp .6
.RS 4n
\fB$<\fR と同様に、指定されたマクロファイルからコマンドを読み取って実行しますが、現在開いているマクロファイルは閉じません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$?\fR\fR
.ad
.sp .6
.RS 4n
ターゲットがユーザープロセスまたはコアファイルの場合、まず、ターゲットのプロセス \fBID\fR と現在のシグナルを出力して、次に、代表スレッドの汎用レジスタセットを出力します。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB$C\fR [ \fIcount\fR ]\fR
.ad
.sp .6
.RS 4n
C スタックのバックトレースを、スタックフレームポインタの情報も含めて出力します。この dcmd の前に明示的な \fIaddress\fR がある場合には、その仮想記憶アドレスから始まるバックトレースを表示します。その他の場合には、代表スレッドのスタックを表示します。オプションのカウント値が引数として指定されている場合には、出力の各スタックフレームに対して、\fIcount\fR 引数で指定された数の引数だけが表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIbase\fR ] \fB$d\fR\fR
.ad
.sp .6
.RS 4n
デフォルトの出力基数を取得または設定します。この dcmd の前に明示的な式がある場合には、デフォルトの出力基数は、指定された \fIbase\fR に設定されます。その他の場合には、現在の基数が 10 進数で出力されます。デフォルトの基数は 16 (16 進数) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$e\fR\fR
.ad
.sp .6
.RS 4n
既知の外部すなわち大域的なオブジェクト型シンボルや関数シンボルのリスト、そのシンボルの値、およびターゲットの仮想アドレス空間内の対応位置に格納される最初の 4 バイト (32 ビット \fBmdb\fR) または 8 バイト (64 ビット \fBmdb\fR) のリストを出力します。\fB::nm\fR dcmd には、シンボルテーブルの表示用にさらに柔軟なオプションが用意されています。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$P\fR \fIprompt-string\fR\fR
.ad
.sp .6
.RS 4n
指定された \fIprompt-string\fR にプロンプトを設定します。デフォルトのプロンプトは、「\fB>\fR」です。\fB::set\fR \fB-P\fR または \fB-P\fR コマンド行オプションを使用しても、プロンプトは設定できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fIdistance\fR \fB$s\fR\fR
.ad
.sp .6
.RS 4n
アドレスからシンボル名へ変換するための、シンボルマッチングディスタンスを取得または設定します。\fI\fRシンボルマッチングディスタンスのモードについては、「オプション」の \fB-s\fR コマンド行オプションで説明します。\fB::set\fR \fB-s\fR オプションを使用しても、シンボルマッチングディスタンスは変更できます。距離が指定されない場合には、現在の設定が表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$v\fR\fR
.ad
.sp .6
.RS 4n
指定された変数のうち、ゼロ以外の値を持つ変数のリストを出力します。\fB::vars\fR dcmd を使用すると、変数の一覧表示にほかのオプションを付けることができます。
.RE

.sp
.ne 2
.mk
.na
\fB\fIwidth\fR \fB$w\fR\fR
.ad
.sp .6
.RS 4n
出力のページ幅を指定された値に設定します。\fI\fR通常は、\fBmdb\fR が端末に幅の照会をしてサイズを変更するので、このコマンドは必要ありません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$W\fR\fR
.ad
.sp .6
.RS 4n
ターゲットを書き込み用にもう一度開きます (\fB-w\fR オプションをコマンド行に指定して \fBmdb\fR を実行する場合と同じ)。\fB::set\fR \fB-w\fR オプションを使用しても、書き込みモードを有効にできます。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIpid\fR ] \fB::attach\fR [ \fIcore\fR | \fIpid\fR ]\fR
.ad
.br
.na
\fB[ \fIpid\fR ] \fB:A\fR [ \fIcore\fR | \fIpid\fR ]\fR
.ad
.sp .6
.RS 4n
ユーザープロセスターゲットが動作中の場合には、指定されたプロセス \fBID\fR またはコアファイルに接続して、デバッグします。\fI\fRコアファイルのパス名は、文字列引数として指定されます。プロセス \fBID\fR は、この dcmd の前で、文字列引数として、または式の値として指定されます。デフォルトは 16 進数であることを忘れないでください。したがって、\fBpgrep\fR(1) や \fBps\fR(1) を使用して得た 10 進数のプロセス ID (\fBPID\fR) を式として指定する場合には、その先頭に「\fB0t\fR」を付けてください。
.RE

.sp
.ne 2
.mk
.na
\fB[\fIaddress\fR] \fB::bp\fR [\fB-/\fR\fB-dDesT\fR] [\fB-c\fR \fIcmd\fR] [\fB-n\fR \fIcount\fR] \fIsym\fR ...\fR
.ad
.br
.na
\fB\fIaddress\fR \fB :b\fR [\fIcmd\fR ...]\fR
.ad
.sp .6
.RS 4n
指定された場所にブレークポイントを設定します。\fB::bp\fR dcmd は、指定されたアドレスまたはシンボル (dcmd の前にある明示的な式で指定されたオプションのアドレスを含む) ごと、そして、dcmd の後ろにある文字列または即値ごとにブレークポイントを設定します。引数には、指定された特定の仮想アドレスを示すシンボル名または即値を指定できます。シンボル名を指定した場合、ターゲットプロセス内でまだ評価できないシンボルを参照できます。つまり、まだ読み込んでいないオブジェクト内のオブジェクト名や関数名を参照できます。この場合、ターゲット内のブレークポイントは延期され、指定された名前に一致するオブジェクトが読み込まれるまでアクティブ (有効) になりません。オブジェクトが読み込まれると、このブレークポイントは自動的に有効になります。共用ライブラリ内に定義されたシンボル上のブレークポイントを設定する場合、アドレスは実際のシンボル定義ではなく、対応する \fBPLT\fR (Procedure Linkage Table) エントリを参照する可能性があるので、必ず、アドレス式ではなく、シンボル名を使用する必要があります。\fBPLT\fR エントリ上で設定されたブレークポイントは、その \fBPLT\fR エントリがあとで実際のシンボル定義に解釈されると、実行時リンクエディタによって上書きされることがあります。\fB-d\fR、\fB-D\fR、\fB-e\fR、\fB-s\fR、\fB-t\fR、\fB-T\fR、\fB-c\fR、および \fB-n\fR オプションは、\fB::evset\fR dcmd で使用するのと同じです (後述の説明を参照)。dcmd の \fB:b\fR 形式を使用した場合、ブレークポイントは dcmd の前にある式で指定した仮想アドレスだけに設定されます。\fB:b\fR dcmd の後ろにある引数は連結され、コールバック文字列となります。この文字列にメタキャラクタが含まれる場合、文字列を引用符で囲む必要があります。 
.RE

.sp
.ne 2
.mk
.na
\fB\fB::cat\fR \fIfilename\fR ...\fR
.ad
.sp .6
.RS 4n
ファイルを連結および表示します。各ファイル名は、相対パス名または絶対パス名として指定できます。ファイルの内容は、標準出力に表示されますが、出力ページャーには渡されません。この dcmd は、\fB|\fR 演算子とともに使用するようになっています。したがって、プログラマは外部ファイルに格納されたアドレスリストを使用してパイプラインを処理できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::cont\fR [ \fISIG\fR ]\fR
.ad
.br
.na
\fB\fB:c\fR [ \fISIG\fR ]\fR
.ad
.sp .6
.RS 4n
デバッガを中断し、ターゲットプログラムを継続し、指定されたソフトウェアイベントが発生したあとにターゲットプログラムが終了または停止するまで待機します。\fB-o\fR \fBnostop\fR オプションを有効にしてデバッガを動作中のプログラムに接続しており、ターゲットがすでに動作している場合、この dcmd は単に、指定されたソフトウェアイベントが発生したあとにターゲットプログラムが終了または停止するまで待機します。オプションのシグナルの名前または番号 (\fBsignal.h\fR(3HEAD) を参照) が引数として指定された場合、このシグナルはターゲットの実行を再開するための一部として、すぐにターゲットに送られます。\fBSIGINT\fR シグナルを追跡している場合、ユーザー定義割り込み文字 (通常は \fB^C\fR) を入力すると、非同期的にデバッガに制御を戻すことができます。この \fBSIGINT\fR シグナルは自動的に消去され、次回ターゲットが継続される場合、ターゲットにはこのシグナルは送られません。現在、ターゲットプログラムが動作していない場合、\fB::cont\fR は、\fB::run\fR を実行した場合と同じように、新しいプログラムの実行を起動します。
.RE

.sp
.ne 2
.mk
.na
\fB\fIaddress\fR \fB::context\fR\fR
.ad
.br
.na
\fB\fIaddress\fR \fB$p\fR\fR
.ad
.sp .6
.RS 4n
指定されたプロセスへのコンテキストスイッチ。コンテキストスイッチの操作は、カーネルターゲットを使用している場合にだけ有効です。プロセスのコンテキストを指定するには、カーネルの仮想アドレス空間において、そのプロセスの proc 構造体の \fIaddress\fR を使用します。特別なコンテキストアドレス「\fB0\fR」は、カーネルそのもののコンテキストを表すときに使用されます。カーネルページだけの場合とは対照的に、指定されたユーザープロセスの物理メモリーページがクラッシュダンプに含まれる場合、クラッシュダンプを検査するときに \fBmdb\fR が実行できるのはコンテキストスイッチだけです。\fBdumpadm\fR(1M) を使用すると、すべてのページまたは現在のユーザープロセスのページをダンプできるようにカーネルクラッシュダンプ機能を構成できます。\fB::status\fR dcmd を使用すると、現在のクラッシュダンプの内容を表示できます。
.sp
ユーザーがカーネルターゲットからコンテキストスイッチを要求した場合には、\fBmdb\fR は指定されたユーザープロセスに相当する新しいターゲットを作成します。スイッチが発生すると、新しいターゲットは、自身の dcmd を大域レベルに置きます。したがって、このとき、\fB/\fR dcmd が、ユーザープロセスの仮想アドレス空間からデータをフォーマットして表示したり、\fB::mappings\fR dcmd が、ユーザープロセスのアドレス空間でマッピングを表示したりするようになります。\fB0::context\fR を実行すると、カーネルターゲットを復元できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::dcmds\fR\fR
.ad
.sp .6
.RS 4n
使用可能な dcmd を一覧表示し、各 dcmd の簡単な説明を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::delete\fR [ \fIid\fR | \fBall\fR ]\fR
.ad
.br
.na
\fB[ \fIaddress\fR ] \fB:d\fR [ \fIid\fR | \fBall\fR ]\fR
.ad
.sp .6
.RS 4n
指定された ID 番号のイベント指定子を削除します。id 番号引数はデフォルトで 10 進数として解釈されます。オプションのアドレスを dcmd の前に指定した場合、指定された仮想アドレスに関連するすべてのイベント指定子 (たとえば、そのアドレスに影響するすべてのブレークポイントまたはウォッチポイント) が削除されます。特別な引数「\fBall\fR」を指定した場合、すべてのイベントが削除されます。ただしスティッキー (\fBT\fR フラグ) がマークされたイベントは除きます。\fB::events\fR dcmd はイベント指定子の現在のリストを表示します。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::dis\fR [ \fB-fw\fR ] [ \fB-n\fR \fIcount\fR ] [ \fIaddress\fR ]\fR
.ad
.sp .6
.RS 4n
最後の引数または現在のドット値によって指定されたアドレス、またはそのアドレス周辺から、逆アセンブルします。\fI\fRアドレスが既知の関数の最初の部分に一致した場合は、関数全体が逆アセンブルされます。その他の場合は、指定されたアドレスの前後の命令の「ウィンドウ」が、コンテキストの理解のために出力されます。デフォルトでは、命令はターゲットの仮想アドレス空間から読み取られます。\fB-f\fR オプションを指定した場合は、命令はターゲットのオブジェクトファイルから読み取られます。デバッガが現在、動作中のプロセス、コアファイル、またはクラッシュダンプに接続されていない場合、\fB-f\fR オプションはデフォルトで有効になります。また、アドレスが既知の関数の最初の部分に一致した場合でも、\fB-w\fR オプションを指定すると、「ウィンドウ」を強制的に開くモードに設定できます。デフォルトでは、ウィンドウのサイズは命令 10 個分です。\fB-n\fR オプションを使用すれば、命令の数を明示的に指定できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::disasms\fR\fR
.ad
.sp .6
.RS 4n
使用可能な逆アセンブラのモードを一覧表示します。ターゲットが初期化されている場合には、\fBmdb\fR は適切な逆アセンブラモードを選択しようとします。また、\fB::dismode\fR dcmd を使用して、ユーザーは、初期モードを一覧表のどれかに変更できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::dismode\fR [ \fImode\fR ]\fR
.ad
.br
.na
\fB\fB$V\fR [ \fImode\fR ]\fR
.ad
.sp .6
.RS 4n
逆アセンブラモードを受け取るか、設定します。引数が指定されていないと、現在の逆アセンブラモードを出力します。\fImode\fR 引数が指定されている場合には、逆アセンブラを指定されたモードに切り替えます。また、\fB::disasms\fR dcmd を使用して、逆アセンブラのリストを表示できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::dmods\fR [ \fB-l\fR ] [ \fImodule-name\fR ]\fR
.ad
.sp .6
.RS 4n
読み込まれたデバッガモジュールを一覧表示します。\fB-l\fR オプションが指定されていると、各 dmod に関連付けられた dcmd や walker の一覧がその dmod 名の下に出力されます。特定の dmod の名前を追加の引数として指定すれば、出力はその dmod に限定されます。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::dump\fR [ \fB-eqrstu\fR ] [ \fB-f\fR|\fB-p\fR ]\fR
.ad
.br
.na
\fB[ \fB-g\fR \fIbytes\fR ] [ \fB-w\fR \fIparagraphs\fR ]\fR
.ad
.sp .6
.RS 4n
ドットによって指定されたアドレスを含む、16 バイトで割り当てられた記憶領域のメモリーダンプを 16 進数の ASCII 形式で出力します。\fB::dump\fR に繰り返し回数を指定すると、ダンプする繰り返し数としてではなく、ダンプするバイト数として解釈されます。また、\fB::dump\fR dcmd は、次のオプションも認識します。
.sp
.ne 2
.mk
.na
\fB\fB-e\fR\fR
.ad
.sp .6
.RS 4n
エンディアンに合わせて調整します。\fB-e\fR オプションでは、4 バイトのワードを使用できます。\fB-g\fR オプションを使用して、デフォルトのワードサイズを変更できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間からではなく、指定された仮想アドレスに対応するオブジェクトファイルの位置からデータを読み取ります。デバッガが現在、動作中のプロセス、コアファイル、またはクラッシュダンプに接続されていない場合、\fB-f\fR オプションはデフォルトで有効になります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-g\fR \fIbytes\fR\fR
.ad
.sp .6
.RS 4n
バイトをバイトのグループで表示します。\fI\fRデフォルトの group サイズは 4 バイトです。group サイズは行幅を分割する 2 のべき乗にする必要があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR\fR
.ad
.sp .6
.RS 4n
\fIaddress\fR を、仮想アドレスではなく、ターゲットのアドレス空間内の物理的なアドレス位置として解釈します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-q\fR\fR
.ad
.sp .6
.RS 4n
データの ASCII 形式の復号化を出力しません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-r\fR\fR
.ad
.sp .6
.RS 4n
各行に、絶対的なアドレスではなく、開始アドレスからの相対的な行数を与えます。このオプションを指定すると、\fB-u\fR オプションも暗黙的に指定されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.sp .6
.RS 4n
繰り返しの行を省略します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR\fR
.ad
.sp .6
.RS 4n
行全体を読み取って出力するのではなく、指定されたアドレスの内容だけを読み取って表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-u\fR\fR
.ad
.sp .6
.RS 4n
段落の境界に配列するのではなく、配列せずに出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR \fIparagraphs\fR\fR
.ad
.sp .6
.RS 4n
1 行あたり 16 バイトの段落で段落を表示します。デフォルトの段落数は 1 です。\fI\fR\fB-w\fR の最大値は \fB16\fR です。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fB::echo\fR [ \fIstring\fR | \fIvalue\fR ...]\fR
.ad
.sp .6
.RS 4n
空白文字で区切られ、復帰改行文字で終わる引数を標準出力に出力します。\fI\fR\fB$[ ]\fR で囲まれた式は値に評価されて、デフォルトで出力されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::eval\fR \fIcommand\fR\fR
.ad
.sp .6
.RS 4n
指定された文字列をコマンドとして評価し、実行します。コマンドがメタキャラクタやスペースを含む場合は、引用符や二重引用符で囲みます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::events\fR [ \fB-av\fR ]\fR
.ad
.br
.na
\fB\fB$b\fR [ \fB-av\fR ]\fR
.ad
.sp .6
.RS 4n
ソフトウェアイベント指定子のリストを表示します。各イベント指定子には一意の ID 番号が割り当てられ、この ID 番号を使用すると、あとでイベント指定子を削除または変更できます。\fB\fRデバッガは、それ自体の内部イベントで追跡を有効にすることもできます。それらのイベントは、\fB-a\fR オプションが指定されている場合にのみ表示されます。\fB-v\fR オプションを指定した場合、たとえば、指定子がアクティブになっていない理由などの、より詳細な情報が表示されます。次に、一部の出力例を示します。
.sp
.in +2
.nf
> ::events
   ID S TA HT LM Description                      Action
----- - -- -- -- -------------------------------- ------
[ 1 ] - T   1  0 stop on SIGINT                   -                    
[ 2 ] - T   0  0 stop on SIGQUIT                  -                    
[ 3 ] - T   0  0 stop on SIGILL                   -                    
 ...
[ 11] - T   0  0 stop on SIGXCPU                  -                    
[ 12] - T   0  0 stop on SIGXFSZ                  -                    
[ 13] -     2  0 stop at libc`printf              ::echo printf        
>
.fi
.in -2
.sp

次に、各カラムの意味を説明します。\fB::help\fR \fBevents\fR を使用しても、この情報の要約を表示できます。
.sp
.ne 2
.mk
.na
\fB\fBID\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子の識別子。この識別子は、指定子が有効である場合は角括弧「\fB[ ]\fR」で囲まれ、指定子が無効である場合は丸括弧「\fB( )\fR」で囲まれ、指定された指定子に一致するイベントが発生したあとにターゲットプログラムが現在停止している場合は山括弧「\fB< >\fR」で囲まれます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBS\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子の状態。この状態は次のシンボルのうちの 1 つです。
.sp
.ne 2
.mk
.na
\fB\fB-\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子はアイドル状態です。どのターゲットプログラムも動作していないとき、すべての指定子はアイドル状態になります。ターゲットプログラムが動作しているとき、評価できない指定子はアイドル状態になることがあります。(たとえば、共用オブジェクトがまだ読み込まれておらず、共用オブジェクト内のブレークポイントが延期されている場合)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB+\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子はアクティブです。ターゲットが継続されると、この種類のイベントがデバッガによって検出されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB*\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子は作動準備されてます。この状態は、ターゲットが現在動作しており、この種類のイベントが監視されていることを意味します。この状態を表示できるのは、\fB-o\fR \fB nostop\fR オプションを使用してデバッガを動作中のプログラムに接続している場合だけです。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!\fR\fR
.ad
.sp .6
.RS 4n
オペレーティングシステムのエラーのために、イベント指定子は作動準備されていません。\fB::events\fR \fB-v\fR オプションを使用すると、監視が失敗した理由についてより詳細な情報が表示されます。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBTA\fR\fR
.ad
.sp .6
.RS 4n
Temporary、Sticky、および Automatic というイベント指定子のプロパティー。次のシンボルのうちの 1 つまたは複数が表示されます。
.sp
.ne 2
.mk
.na
\fB\fBt\fR\fR
.ad
.sp .6
.RS 4n
このイベント指定子は一時的であり、次回ターゲットが停止すると、一致するかどうかにかかわらず削除されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBT\fR\fR
.ad
.sp .6
.RS 4n
このイベント指定子はスティッキーであり、\fB::delete\fR \fBall\fR または \fB:z\fR では削除されません。このイベント指定子を削除するには、その ID を明示的に \fB::delete\fR に指定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBd\fR\fR
.ad
.sp .6
.RS 4n
このイベント識別子は、ヒット回数がヒット制限に到達すると自動的に無効になります。
.RE

.sp
.ne 2
.mk
.na
\fB\fBD\fR\fR
.ad
.sp .6
.RS 4n
このイベント識別子は、ヒット回数がヒット制限に到達すると自動的に削除されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBs\fR\fR
.ad
.sp .6
.RS 4n
このターゲットは、ヒット回数がヒット制限に到達すると自動的に停止します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBHT\fR\fR
.ad
.sp .6
.RS 4n
現在のヒット回数。このカラムには、当該イベント指定子が作成されたあとに、対応するソフトウェアイベントがターゲット内で発生した回数が表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBLM\fR\fR
.ad
.sp .6
.RS 4n
現在のヒット制限。このカラムには、自動無効、自動削除または自動停止が発生するときのヒット回数の制限が表示されます。このような動作を設定するには、\fB::evset\fR dcmd を使用します (後述の説明を参照)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB機能説明\fR\fR
.ad
.sp .6
.RS 4n
指定された指定子に一致するソフトウェアイベントの種類の説明。
.RE

.sp
.ne 2
.mk
.na
\fB\fB処置\fR\fR
.ad
.sp .6
.RS 4n
対応するソフトウェアイベントが発生したときに実行されるコールバック文字列。このコールバックは、コマンドプロンプトに入力された場合と同じように実行されます。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB[\fIid\fR] \fB::evset\fR [\fB-/\fR\fB-dDestT\fR] [\fB-c\fR \fIcmd\fR] [\fB-n\fR \fIcount\fR] \fIid\fR ...\fR
.ad
.sp .6
.RS 4n
1 つまたは複数のソフトウェアイベント指定子のプロパティーを変更します。プロパティーは、dcmd の前にあるオプションの式と dcmd の後ろにあるオプションの引数リストによって識別される指定子ごとに設定されます。基数が明示的に指定されない限り、引数リストは 10 進数の整数のリストとして解釈されます。\fB::evset\fR dcmd は次のオプションを認識します。
.sp
.ne 2
.mk
.na
\fB\fB-d\fR\fR
.ad
.sp .6
.RS 4n
ヒット回数がヒット制限に到達すると、イベント識別子を無効にします。\fB-d\fR 形式のオプションを指定した場合、この動作は無効になります。イベント指定子が無効になると、もう一度有効になるまで、デバッガは対応する監視をすべて削除し、対応するソフトウェアイベントを無視します。\fB-n\fR オプションを指定しない場合、指定子はすぐに無効になります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-D\fR\fR
.ad
.sp .6
.RS 4n
ヒット回数がヒット制限に到達すると、イベント識別子を削除します。\fB-D\fR 形式のオプションを指定した場合、この動作は無効になります。\fB-D\fR オプションは \fB-d\fR オプションよりも優先されます。ヒット制限を設定するには、\fB-n\fR オプションを使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子を有効にします。\fB-e\fR 形式のオプションを指定した場合、この動作は無効になります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.sp .6
.RS 4n
ヒット回数がヒット制限に到達すると、ターゲットプログラムを停止します。\fB-s\fR 形式のオプションを指定した場合、この動作は無効になります。\fB-s\fR オプションを指定すると、デバッガは指定子のコールバックが実行されるたびに (ただし、\fIN\fR 回目の実行を除く (\fIN\fR は指定子のヒット制限の現在の値))、\fB::cont\fR が発行されたかのように動作します。\fB-s\fR オプションは \fB-D\fR オプションと \fB-d\fR オプションよりも優先されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子を「一時的」であるとマークします。一時的な指定子は、次回ターゲットが停止すると、指定した指定子に対応するソフトウェアイベントの結果によって停止したかどうかに関わらず、自動的に削除されます。\fB-t\fR 形式のオプションを指定した場合、「一時的」マーカーは削除されます。\fB-t\fR オプションは \fB-T\fR オプションよりも優先されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-T\fR\fR
.ad
.sp .6
.RS 4n
イベント指定子を「スティッキー」であるとマークします。スティッキー指定子は、\fB::delete\fR \fBall\fR または \fB:z\fR では削除されません。スティッキー指定子を削除するには、対応する指定子 \fBID\fR を \fB::delete\fR の明示的引数として指定します。\fB-T\fR 形式のオプションを指定した場合、「スティッキー」プロパティー は削除されます。イベント指定子のデフォルトセットには初めから「スティッキー」のマークが付いています。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR\fR
.ad
.sp .6
.RS 4n
対応するソフトウェアイベントがターゲットプログラム内で発生するたびに、指定された \fIcmd\fR 文字列を実行します。現在のコールバック文字列を表示するには、\fB::events\fR を使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR\fR
.ad
.sp .6
.RS 4n
ヒット制限の現在の値を \fIcount\fR に設定します。ヒット制限を現在設定せずに、\fB-n\fR オプションと一緒に \fB-s\fR または D オプションを指定していない場合、ヒット制限は 1 に設定されます。
.RE

\fB::help\fR \fBevset\fR を使用しても、この情報の要約を表示できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::files\fR\fR
.ad
.br
.na
\fB\fB$f\fR\fR
.ad
.sp .6
.RS 4n
既知のソースファイルの一覧、すなわち、種々のターゲットシンボルテーブルの中にある \fISTT_FILE\fR 型のシンボルを出力します。
.RE

.sp
.ne 2
.mk
.na
\fB[\fIflt\fR] \fB::fltbp\fR [\fB-/\fR\fB-dDestT\fR] [\fB-c\fR \fIcmd\fR] [\fB-n\fR \fIcount\fR] \fIflt\fR ...\fR
.ad
.sp .6
.RS 4n
指定されたマシン障害を追跡します。障害を特定するには、dcmd の前にオプションの障害番号を指定するか、dcmd の後ろに障害の名前または番号のリストを指定します (\fB<sys/fault.h>\fR を参照)。\fB-d\fR、\fB-D\fR、\fB-e\fR、\fB-s\fR、\fB-t\fR、\fB-T\fR、\fB-c\fR、および \fB-n\fR オプションは、\fB::evset\fR dcmd で使用するのと同じです。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fB\fIthread\fR\fR ] \fB::fpregs\fR\fR
.ad
.br
.na
\fB[ \fB\fIthread\fR\fR ] \fB$x\fR, \fB$X\fR, \fB$y\fR, \fB$Y\fR\fR
.ad
.sp .6
.RS 4n
代表スレッドの浮動小数点レジスタセットを出力します。スレッドを指定すると、そのスレッドの浮動小数点レジスタが表示されます。スレッド式は、前述の「スレッドのサポート」で説明したスレッド識別子の 1 つである必要があります。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::formats\fR\fR
.ad
.sp .6
.RS 4n
\fB/\fR、\fB\e\fR、\fB?\fR、\fB=\fR などのフォーマット dcmd とともに使用する、利用可能な出力書式制御文字の一覧を表示します。フォーマットとその使用法については、前述の「フォーマット dcmd」で説明しています。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::grep\fR \fIcommand\fR\fR
.ad
.sp .6
.RS 4n
指定されたコマンド文字列を評価したあと、新しいドット値がゼロ以外の場合には、古いドット値を出力します。\fIcommand\fR にスペースやメタキャラクタが含まれる場合は、必ず引用符で囲んでください。パイプライン内で \fB::grep\fR dcmd を使用すると、アドレスリストをフィルタ処理できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::help\fR [ \fIdcmd-name\fR ]\fR
.ad
.sp .6
.RS 4n
引数がない場合には、\fB::help\fR dcmd は、\fBmdb\fR で使用可能なヘルプ機能の概要を簡潔に出力します。\fIdcmd-name\fR が指定されている場合には、\fBmdb\fR は、その dcmd の使用法の概略を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fIsignal\fR \fB:i\fR\fR
.ad
.sp .6
.RS 4n
ターゲットが動作中のユーザープロセスである場合、指定されたシグナルを無視して、透過的にターゲットにそのシグナルを送ります。指定されたシグナルの送り先を追跡しているイベント指定子はすべて、追跡対象イベントのリストから削除されます。デフォルトでは、無視されるシグナルは、デフォルトでプロセスがコアをダンプする原因となるシグナルセット (\fBsignal.h\fR(3HEAD) を参照) の補集合に初期化されます (ただし、デフォルトで追跡される \fBSIGINT\fR を除く)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$i\fR\fR
.ad
.sp .6
.RS 4n
デバッガが無視して、ターゲットが直接処理するシグナルのリストを表示します。追跡対象シグナルについてのより詳細な情報を取得するには、\fB::events\fR dcmd を使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::kill\fR\fR
.ad
.br
.na
\fB\fB:k\fR\fR
.ad
.sp .6
.RS 4n
ターゲットが動作中のユーザープロセスである場合、強制的にターゲットを終了します。また、ターゲットが本来デバッガで \fB::run\fR を使用して作成されていた場合、デバッガを終了すると、ターゲットは強制的に終了されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$l\fR\fR
.ad
.sp .6
.RS 4n
ターゲットがユーザープロセスである場合、代表スレッドの \fBLWPID\fR を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$L\fR\fR
.ad
.sp .6
.RS 4n
ターゲットがユーザープロセスである場合、ターゲット内にある各 \fBLWP\fR の \fBLWPID\fR を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::list\fR \fItype\fR \fImember\fR [ \fIvariable-name\fR ]\fR
.ad
.sp .6
.RS 4n
リンクリストデータ構造体の要素を調べて、リスト内の各要素のアドレスを出力します。リスト内の最初の要素のアドレスは、オプションのアドレスを使用して指定できます。その他の場合には、リストは現在のドット値から始まるものとみなされます。\fBmdb\fR が適切なサイズのオブジェクトから読み取ることができるように、type パラメータは C 言語の構造体または共用体を指定する必要があり、リスト内の要素の型を記述するのに使用されます。member パラメータは、リスト内の次の要素へのポインタを含む、\fItype\fR のメンバーを指定するのに使用されます。\fI\fR\fB::list\fR dcmd は、要素を読み取っている間、\fBNULL\fR ポインタを見つけるか、もう一度最初の要素に到達するまで (つまり、循環リスト)、あるいは、エラーが発生するまで、繰り返します。オプションの \fIvariable-name\fR が指定されている場合には、\fBmdb\fR がパイプラインの次のステージを呼び出すときに walk の各ステップが返す値に、指定変数が割り当てられます。\fB::list\fR dcmd は、mdb で使用されるように設計されたシンボルデバッグ情報を含むオブジェクトだけに使用できます。詳細は、後述の「注意事項」の「シンボルデバッグ情報」を参照してください。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::load\fR [ \fB-s\fR ] \fImodule-name\fR\fR
.ad
.sp .6
.RS 4n
指定された dmod をロードします。モジュール名は、絶対パスまたは相対パスとして指定します。\fImodule-name\fR が単純名、つまり「\fB/\fR」を含んでいない場合には、\fBmdb\fR はモジュールライブラリパス内で検索します。モジュールの名前に重複があった場合には、そのモジュールは読み込まれません。その場合は、まず既存のモジュール名を読み込み解除する必要があります。\fB-s\fR オプションを指定すると、\fBmdb\fR はモジュールを発見または読み込めなくても何も出力せず、エラーメッセージも表示しません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::log\fR [ \fB-d\fR | [ \fB-e\fR ] \fIfilename\fR ]\fR
.ad
.br
.na
\fB\fB$>\fR [ \fIfilename\fR ]\fR
.ad
.sp .6
.RS 4n
出力ログを有効にしたり、無効にしたりします。\fBmdb\fR は、相互ログ機能を提供しているので、まだユーザーとの対話処理が行われているときにも、入力コマンドと標準出力の両方が同じファイルに記録できます。\fB-e\fR オプションでファイルを指定すると、指定したファイルへのログの書き込みが有効になり、ファイル名を指定しない場合、前回のログファイルへの書き込みが再度有効になります。\fB-d\fR オプションは、ログを無効にします。また、\fB$>\fR dcmd を使用する場合、ファイル名引数が指定されているときには、ログが有効になります。その他の場合、ログは無効になります。指定されたログファイルがすでに存在する場合、\fBmdb\fR は新しいログ出力をそのファイルに追加します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::map\fR \fIcommand\fR\fR
.ad
.sp .6
.RS 4n
文字列引数として指定される \fIcommand\fR を使用して、ドット値を対応する値へ割り当ててから新しい値を出力します。command にスペースやメタキャラクタが含まれる場合は、必ず引用符で囲んでください。\fB::map\fR dcmd をパイプライン内で使用すると、アドレスのリストを新しいアドレスリストに変換できます。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::mappings\fR [ \fIname\fR ]\fR
.ad
.br
.na
\fB[ \fIaddress\fR ] \fB$m\fR [ \fIname\fR ]\fR
.ad
.sp .6
.RS 4n
ターゲットの仮想アドレス空間内の各割り当てを、アドレス、サイズ、それぞれの割り当て記述などを含めて一覧表示します。\fIaddress\fR が dcmd の前にある場合、\fBmdb\fR は指定されたアドレスを含む割り当てだけを表示します。文字列 \fIname\fR の引数を指定した場合、\fBmdb\fR はその説明と一致する割り当てだけを表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::next\fR [ \fISIG\fR ]\fR
.ad
.br
.na
\fB\fB:e\fR [ \fISIG\fR ]\fR
.ad
.sp .6
.RS 4n
ターゲットプログラムを 1 命令だけ実行しますが、サブルーチンの呼び出しまでは進めます。オプションのシグナルの名前または番号 (\fBsignal.h\fR(3HEAD) を参照) が引数として指定された場合、このシグナルはターゲットの実行を再開するための一部として、すぐにターゲットに送られます。どのターゲットプログラムも動作していない場合、\fB::next\fR は、\fB::run\fR を実行したかのように新しいプログラムを起動し、最初の命令で停止します。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::nm\fR [ \fB-DPdghnopuvx\fR ] [ \fB-t\fR \fItypes\fR ]\fR
.ad
.br
.na
\fB[ \fB-f\fR \fIformat\fR ] [ \fIobject\fR ]\fR
.ad
.sp .6
.RS 4n
現在のターゲットに関連付けられたシンボルテーブルを出力します。オプションの address を dcmd の前に指定した場合、\fIaddress\fR に対応するシンボル用のシンボルテーブルエントリだけが表示されます。\fIobject\fR を指定すると、この読み込みオブジェクト用のシンボルテーブルだけが表示されます。また、\fB::nm\fR dcmd は、次のオプションも認識します。
.sp
.ne 2
.mk
.na
\fB\fB-D\fR\fR
.ad
.sp .6
.RS 4n
\fB\&.symtab\fR の代わりに \fB\&.dynsym\fR (動的シンボルテーブル) を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-P\fR\fR
.ad
.sp .6
.RS 4n
\fB\&.symtab\fR の代わりに専用シンボルテーブルを出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-d\fR\fR
.ad
.sp .6
.RS 4n
値とサイズフィールドを 10 進数で出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-g\fR\fR
.ad
.sp .6
.RS 4n
大域シンボルだけを出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-h\fR\fR
.ad
.sp .6
.RS 4n
ヘッダー行を抑制します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR\fR
.ad
.sp .6
.RS 4n
名前順にシンボルをソートします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR\fR
.ad
.sp .6
.RS 4n
値とサイズフィールドを 8 進数で出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR\fR
.ad
.sp .6
.RS 4n
シンボルを、一連の \fB::nmadd\fR コマンドとして出力します。このオプションは \fB-P\fR とともに使用して、マクロファイルを作成できます。その後、\fB$<\fR コマンドを用いて、このマクロファイルをデバッガに読み込みます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-u\fR\fR
.ad
.sp .6
.RS 4n
未定義のシンボルだけを出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-v\fR\fR
.ad
.sp .6
.RS 4n
値順にシンボルをソートします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR\fR
.ad
.sp .6
.RS 4n
値とサイズフィールドを 16 進数で出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR \fItype\fR[,\fItype\fR ... ]\fR
.ad
.sp .6
.RS 4n
指定された型のシンボルだけを出力します。有効な型引数文字列は次のとおりです。\fI\fR
.sp
.ne 2
.mk
.na
\fB\fBnoty\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_NOTYPE\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBobjt\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_OBJECT\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBfunc\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_FUNC\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBsect\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_SECTION\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBfile\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_FILE\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBcomm\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_COMMON\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBtls\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_TLS\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBregi\fR\fR
.ad
.sp .6
.RS 4n
\fISTT_SPARC_REGISTER\fR
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR \fIformat\fR[,\fIformat\fR ... ]\fR
.ad
.sp .6
.RS 4n
指定されたシンボル情報だけを出力します。有効な書式化引数文字列は次のとおりです。\fI\fR
.sp
.ne 2
.mk
.na
\fB\fBndx\fR\fR
.ad
.sp .6
.RS 4n
シンボルテーブルのインデックス
.RE

.sp
.ne 2
.mk
.na
\fB\fBval\fR\fR
.ad
.sp .6
.RS 4n
シンボル値
.RE

.sp
.ne 2
.mk
.na
\fB\fBsize\fR\fR
.ad
.sp .6
.RS 4n
サイズ (単位はバイト)
.RE

.sp
.ne 2
.mk
.na
\fB\fBtype\fR\fR
.ad
.sp .6
.RS 4n
シンボルの型
.RE

.sp
.ne 2
.mk
.na
\fB\fBbind\fR\fR
.ad
.sp .6
.RS 4n
結合
.RE

.sp
.ne 2
.mk
.na
\fB\fBoth\fR\fR
.ad
.sp .6
.RS 4n
その他
.RE

.sp
.ne 2
.mk
.na
\fB\fBshndx\fR\fR
.ad
.sp .6
.RS 4n
セクションのインデックス
.RE

.sp
.ne 2
.mk
.na
\fB\fBname\fR\fR
.ad
.sp .6
.RS 4n
シンボル名
.RE

.sp
.ne 2
.mk
.na
\fB\fBctype\fR\fR
.ad
.sp .6
.RS 4n
シンボルの C 言語の型 (既知の場合)
.RE

.sp
.ne 2
.mk
.na
\fB\fBobj\fR\fR
.ad
.sp .6
.RS 4n
シンボルを定義するオブジェクト
.RE

.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fIvalue\fR \fB::nmadd\fR [ \fB-fo\fR ] [ \fB-e\fR \fIend\fR ] [ \fB-s\fR \fIsize\fR ] \fIname\fR\fR
.ad
.sp .6
.RS 4n
指定されたシンボルの名前を、専用シンボルテーブルへ追加します。\fI\fR\fBmdb\fR は、構成可能な専用シンボルテーブルを用意しています。前述の「シンボルの名前解決」で説明したように、この専用テーブルは、ターゲットのシンボルテーブル内に置くことができます。\fB\fRまた、\fB::nmadd\fR dcmd は、次のオプションも認識します。
.sp
.ne 2
.mk
.na
\fB\fB-e\fR\fR
.ad
.sp .6
.RS 4n
シンボルのサイズを \fIend\fR - \fIvalue\fR に設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR\fR
.ad
.sp .6
.RS 4n
シンボルのタイプを \fBSTT_FUNC\fR に設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR\fR
.ad
.sp .6
.RS 4n
シンボルのタイプを \fBSTT_OBJECT\fR に設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.sp .6
.RS 4n
シンボルのサイズを \fIsize\fR に設定します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fB::nmdel\fR \fIname\fR\fR
.ad
.sp .6
.RS 4n
指定されたシンボルの名前を専用シンボルテーブルから削除します。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::objects\fR [ \fB-v\fR ]\fR
.ad
.sp .6
.RS 4n
既知の読み込みオブジェクトの一次割り当て (通常はテキストセクション) に対応するマッピングだけを表示して、そのターゲットの仮想アドレス空間の割り当てを出力します。\fB-v\fR オプションは、各ロードオブジェクトのバージョンを表示します。すべてのロードオブジェクトのバージョン情報が得られるわけではありません。バージョン情報のないロードオブジェクトは、バージョンが「不明」のオブジェクトとして \fB-v\fR オプションの出力に表示されます。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::offsetof\fR \fItype member\fR\fR
.ad
.sp .6
.RS 4n
指定された型のメンバーのオフセットを出力します。\fI\fR\fI\fR型は C 言語の構造体の名前である必要があります。\fI\fRオフセットはバイトで出力されます。ただし、メンバーがビットフィールドの場合、オフセットはビットで出力されます。分かりやすくするために、出力の末尾には常に適切な単位が付きます。型名には、前述の「シンボルの名前解決」で説明した逆引用符 (\fB`\fR) 有効範囲規則を使用できます。\fB\fR\fB::offsetof\fR dcmd は、\fBmdb\fR で使用されるように設計されたシンボルデバッグ情報を含むオブジェクトだけに使用できます。詳細は、後述の「注意事項」の「シンボルデバッグ情報」を参照してください。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fIaddress\fR \fB::print\fR [ \fB-aCdiLptx\fR ] [ \fB-c\fR \fIlim\fR ]\fR
.ad
.br
.na
\fB[ \fB-l\fR \fIlim\fR ] [ \fItype\fR [ \fImember\fR ... ] ]\fR
.ad
.sp .6
.RS 4n
指定された仮想 \fIaddress\fR にあるデータ構造体を、指定された \fItype\fR 情報を使用して出力します。\fItype\fR パラメータは C 言語の構造体、共用体、列挙型、基本的な整数型、あるいは、これらの型へのポインタを指定できます。型名にスペース文字が含まれる場合 (たとえば、「\fBstruct foo\fR」)、単一引用符または二重引用符で囲む必要があります。型名には、前述の「シンボルの名前解決」で説明した逆引用符 (\fB`\fR) 有効範囲規則を使用できます。\fB\fRtype が構造化された型である場合、\fB::print\fR dcmd は構造体または共用体の各メンバーを再帰的に出力します。\fItype\fR 引数を指定せず、かつ、静的または大域的な \fISTT_OBJECT\fR シンボルがアドレスに一致する場合、\fB::print\fR は自動的に適切な型を推測します。\fItype\fR 引数を指定した場合は、その後ろに \fImember\fR 式のリストをオプションで指定できます。その場合は、指定された \fItype\fR のメンバーまたはサブメンバーだけが表示されます。\fItype\fR にその他の構造化された型が含まれる場合、区切り記号のピリオド (「\fB\&.\fR」) で区切ったメンバー名のリストを生成することで、各メンバー文字列はサブ構造体要素を参照できます。\fB::print\fR dcmd は、\fBmdb\fR で使用されるように設計されたシンボルデバッグ情報を含むオブジェクトだけに使用できます。詳細は、後述の「注意事項」の「シンボルデバッグ情報」を参照してください。\fB\fRデータ構造体を表示したあと、\fB::print\fR はドットを \fItype\fR のサイズ分 (バイト) だけインクリメントします。
.sp
\fB-a\fR オプションを指定すると、各メンバーのアドレスが表示されます。\fB-p\fR オプションを指定すると、\fB::print\fR はアドレスを、仮想メモリーアドレスではなく、物理メモリーアドレスとして解釈します。\fI\fR\fB-t\fR オプションを指定すると、各メンバーの型が表示されます。\fB-d\fR または \fB-x\fR オプションを指定した場合は、すべての整数が 10 進数 (\fB-d\fR) または 16 進数 (\fB-x\fR) で表示されます。デフォルトでは、発見的方法を使用して、値が 10 進数で表示されるか 16 進数で表示されるかを判別します。文字列として読み取りまたは表示される文字配列内の文字数は \fB-c\fR オプションで制限できます。\fB-C\fR オプションを指定すると、文字数は制限されません。読み取りまたは表示される標準配列内の要素数は \fB-l\fR オプションで制限できます。\fB-L\fR オプションを指定すると、文字数は制限されず、配列内のすべての要素が表示されます。\fB-c\fR と \fB-l\fR オプションのデフォルト値を変更するには、「オプション」で説明する \fB::set\fR または \fB-o\fR コマンド行オプションを使用します。
.sp
\fB-i\fR オプションを指定した場合、アドレス値は出力する即値として解釈されます。値を解釈する型を指定する必要があります。型が 64 ビットより小さい場合、即値は型のサイズである場合と同じように解釈されます。\fB-i\fR オプションを \fB-p\fR オプションとともに使用することはできません。\fB-a\fR オプションを指定した場合、表示されるアドレスはゼロから始まるバイトオフセットです。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::quit\fR\fR
.ad
.br
.na
\fB\fB$q\fR\fR
.ad
.sp .6
.RS 4n
デバッガを終了します。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIthread\fR ] \fB::regs\fR\fR
.ad
.br
.na
\fB[ \fIthread\fR ] \fB$r\fR\fR
.ad
.sp .6
.RS 4n
代表スレッドの汎用レジスタセットを出力します。スレッドを指定すると、そのスレッドの汎用レジスタセットが表示されます。スレッド式は、前述の「スレッドのサポート」で説明したスレッド識別子の 1 つである必要があります。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::release\fR [ \fB-a\fR ]\fR
.ad
.br
.na
\fB\fB:R\fR [ \fB-a\fR ]\fR
.ad
.sp .6
.RS 4n
以前に接続されたプロセスまたはコアファイルを解放します。\fB-a\fR オプションを指定すると、プロセスは解放され、停止および中断されたままになります。このようなプロセスを継続するには \fBprun\fR(1) を使用し (\fBproc\fR(1) を参照)、再開するには \fBmdb\fR などのデバッガを適用します。デフォルトでは、解放されたプロセスは、\fBmdb\fR の \fB::run\fR で作成された場合には強制的に終了され、\fBmdb\fR の \fB-p\fR オプション、\fB::attach\fR または \fB:A\fR dcmd で接続されていた場合には解放および実行状態に設定されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::run\fR [ \fIargs\fR . . . ]\fR
.ad
.br
.na
\fB\fB:r\fR [ \fIargs\fR . . . ]\fR
.ad
.sp .6
.RS 4n
指定された引数を使用して、新しいターゲットプログラムの実行を起動し、接続します。引数はシェルによって解釈されません。デバッガがすでに動作中のプログラムを検査している場合、\fB::release\fR が実行された場合と同じように、最初にこのプログラムから切断します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::set\fR [ \fB-wF\fR ] [ \fB-/\fR\fB-o\fR \fIoption\fR ] [ \fB-s\fR \fIdistance\fR ] [ \fB-I\fR \fIpath\fR ]\fR
.ad
.br
.na
\fB[ \fB-L\fR \fI path\fR ] [ \fB-P\fR \fIprompt\fR ]\fR
.ad
.sp .6
.RS 4n
デバッガの種々のプロパティーを取得または設定します。いずれのオプションも指定されていない場合には、デバッガのプロパティーの現在の設定が表示されます。\fB::set\fR dcmd は次のオプションを認識します。
.sp
.ne 2
.mk
.na
\fB\fB-F\fR\fR
.ad
.sp .6
.RS 4n
その次のユーザープロセスで、\fB::attach\fR が適用されているプロセスを強制的に引き継ぎます (\fB-F\fR オプションをコマンド行に指定して \fBmdb\fR を実行する場合と同じ)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-I\fR\fR
.ad
.sp .6
.RS 4n
マクロファイルを検出するためのデフォルトパスを設定します。パス引数は特殊トークンを使用できます。「オプション」の \fB-I\fR コマンド行オプションの説明を参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-L\fR\fR
.ad
.sp .6
.RS 4n
デバッガモジュールを検出するためのデフォルトパスを設定します。パス引数は特殊トークンを使用できます。「オプション」の \fB-I\fR コマンド行オプションの説明を参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR\fR
.ad
.sp .6
.RS 4n
指定したデバッガオプションを有効にします。\fB-o\fR 書式が使用されている場合には、そのデバッガオプションを無効にします。オプションの文字列については、\fB-o\fR コマンド行オプションとともに「オプション」で説明されています。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-P\fR\fR
.ad
.sp .6
.RS 4n
コマンドプロンプトを、指定されたプロンプト文字列に設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.sp .6
.RS 4n
シンボルマッチングディスタンスを指定された距離に設定します。詳細は、「オプション」の \fB-s\fR コマンド行オプションの説明を参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR\fR
.ad
.sp .6
.RS 4n
ターゲットを書き込み用にもう一度開きます (\fB-w\fR オプションをコマンド行に指定して \fBmdb\fR を実行する場合と同じ)。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fB::showrev\fR [ \fB-pv\fR ]\fR
.ad
.sp .6
.RS 4n
ハードウェアおよびソフトウェアの変更情報を表示します。オプションを指定しないと、一般的なシステム情報が表示されます。\fB-v\fR オプションは、すべてのロードオブジェクトのバージョン情報を表示します。\fB-p\fR オプションは、パッチの一部としてシステムにインストールされたロードオブジェクトのバージョン情報だけを表示します。すべてのロードオブジェクトのバージョン情報が得られるわけではありません。バージョン情報のないロードオブジェクトは、\fB-p\fR オプションの出力から省略され、バージョンが「不明」のオブジェクトとして \fB-v\fR オプションの出力に表示されます。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB[\fIsignal\fR] \fB::sigbp\fR [\fB-/\fR\fB-dDestT\fR] [\fB-c\fR \fIcmd\fR] [\fB-n\fR \fIcount\fR] \fISIG\fR ...\fR
.ad
.br
.na
\fB[\fIsignal\fR] \fB :t\fR [\fB-/\fR\fB-dDestT\fR] [\fB-c\fR \fIcmd\fR] [\fB-n\fR \fIcount\fR] \fISIG\fR ...\fR
.ad
.sp .6
.RS 4n
指定されたシグナルの送り先を追跡します。シグナルを特定するには、dcmd の前にオプションのシグナル番号を指定するか、dcmd の後ろにシグナルの名前または番号のリストを指定します (\fBsignal.h\fR(3HEAD) を参照)。\fB-d\fR、\fB-D\fR、\fB-e\fR、\fB-s\fR、\fB-t\fR、\fB-T\fR、\fB-c\fR、および \fB-n\fR オプションは、\fB::evset\fR dcmd で使用するのと同じです。最初に、デフォルトでプロセスがコアをダンプする原因となるシグナルセット (\fBsignal.h\fR(3HEAD) を参照) と \fBSIGINT\fR が追跡されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::sizeof\fR \fItype\fR\fR
.ad
.sp .6
.RS 4n
指定された型のサイズをバイトで表示します。\fI\fR\fItype\fR パラメータは C 言語の構造体、共用体、列挙型、基本的な整数型、あるいは、これらの型へのポインタを指定できます。型名には、前述の「シンボルの名前解決」で説明した逆引用符 (\fB`\fR) 有効範囲規則を使用できます。\fB\fR\fB::sizeof\fR dcmd は、\fBmdb\fR で使用されるように設計されたシンボルデバッグ情報を含むオブジェクトだけに使用できます。詳細は、後述の「注意事項」の「シンボルデバッグ情報」を参照してください。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::stack\fR [ \fIcount\fR ]\fR
.ad
.br
.na
\fB[ \fIaddress\fR ] \fB$c\fR [ \fIcount\fR ]\fR
.ad
.sp .6
.RS 4n
C スタックのバックトレースを出力します。この dcmd の前に明示的な \fIaddress\fR がある場合には、その仮想記憶アドレスから始まるバックトレースを表示します。その他の場合には、代表スレッドのスタックを表示します。オプションのカウント値が引数として指定されている場合には、出力の各スタックフレームに対して、\fIcount\fR 引数で指定された数の引数だけが表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::status\fR\fR
.ad
.sp .6
.RS 4n
現在のターゲットに関連した情報の要約を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::step\fR [ \fBover\fR | \fBout\fR ] [ \fISIG\fR ]\fR
.ad
.br
.na
\fB\fB:s\fR [ \fISIG\fR ]\fR
.ad
.br
.na
\fB\fB:u\fR [ \fISIG\fR ]\fR
.ad
.sp .6
.RS 4n
ターゲットプログラムを 1 命令だけ実行します。オプションのシグナルの名前または番号 (\fBsignal.h\fR(3HEAD) を参照) が引数として指定された場合、このシグナルはターゲットの実行を再開するための一部として、すぐにターゲットに送られます。\fBover\fR 引数を指定した場合、\fB::step\fR はサブルーチンの呼び出しまで進めます。\fB::step\fR \fBover\fR 引数は \fB::next\fR dcmd と同じです。オプションの \fBout\fR 引数を指定した場合、代表スレッドが現在の関数から戻ってくるまで、ターゲットプログラムは実行を継続します。どのターゲットプログラムも動作していない場合、\fB::step\fR \fBout\fR は、\fB::run\fR を実行したかのように新しいプログラムを起動し、最初の命令で停止します。\fB:s\fR dcmd は \fB::step\fR と同じです。\fB:u\fR dcmd は \fB::step\fR \fBout\fR と同じです。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIsyscall\fR ] \fB::sysbp\fR [ \fB-/\fR\fB-dDestT\fR ] [ \fB-io\fR ] [ \fB-c\fR \fIcmd\fR ]\fR
.ad
.br
.na
\fB[ \fB-n\fR \fIcount\fR ] \fIsyscall\fR... \fR
.ad
.sp .6
.RS 4n
エントリを追跡するか、指定されたシステムコールから終了します。システムコールを特定するには、dcmd の前にオプションのシステムコール番号を指定するか、dcmd の後ろにシステムコールの名前または番号のリストを指定します (\fB<sys/syscall.h>\fR を参照)。\fB-i\fR オプションを指定した場合 (デフォルト)、イベント指定子はシステムコールごとにカーネルに入るトリガーとなります。\fB-o\fR オプションを指定した場合、イベント指定子はカーネルから終了するトリガーとなります。\fB-d\fR、\fB-D\fR、\fB-e\fR、\fB-s\fR、\fB-t\fR、\fB-T\fR、\fB-c\fR、および \fB-n\fR オプションは、\fB::evset\fR dcmd で使用するのと同じです。
.RE

.sp
.ne 2
.mk
.na
\fB\fIthread\fR \fB::tls\fR \fIsymbol\fR\fR
.ad
.sp .6
.RS 4n
指定されたスレッドのコンテキストにおいて、指定された \fBTLS\fR (Thread-Local Storage) シンボル用の記憶領域のアドレスを出力します。スレッド式は、前述の「スレッドのサポート」で説明したスレッド識別子の 1 つである必要があります。\fB\fRシンボル名には、前述の「シンボルの名前解決」で説明している任意の有効範囲規則を使用できます。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB::typeset\fR [ \fB-/\fR\fB-t\fR] \fIvariable-name\fR . . .\fR
.ad
.sp .6
.RS 4n
指定された変数に属性を設定します。1 つまたは複数の名前が指定されている場合は、それらを定義して、ドット値に設定します。\fB-t\fR オプションを指定すると、各変数に関連付けられたユーザー定義のタグが設定されます。\fB-t\fR オプションを指定すると、そのタグは削除されます。変数名が何も指定されていない場合には、変数のリストとその値を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::unload\fR \fImodule-name\fR\fR
.ad
.sp .6
.RS 4n
指定された dmod を読み込み解除します。\fB::dmods\fR dcmd を使用すると、動作中の dmod のリストを出力できます。組み込みモジュールは、読み込み解除できません。使用中のモジュール、すなわち現在実行中の dcmd を提供しているモジュールは、解除できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::unset\fR \fIvariable-name\fR . . .\fR
.ad
.sp .6
.RS 4n
定義された変数リストから、指定された変数の設定を解除、すなわち削除します。\fBmdb\fR によってエクスポートされている変数の中には、固定表示と指定されていて、ユーザーが削除できないものがあります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::vars\fR [\fB-npt\fR]\fR
.ad
.sp .6
.RS 4n
指定された変数の一覧を表示します。\fB-n\fR オプションを指定すると、その出力は、ゼロ以外の変数に限定されます。\fB-p\fR を指定すると、変数は \fB$<\fR dcmd を使用して、デバッガの再処理に適切な形式で出力されます。このオプションを使用すると、変数をマクロファイルに記録しておき、あとでこれらの値を復元できます。\fB-t\fR を指定すると、タグ付き変数だけが出力されます。変数にタグを付けるには、\fB::typeset\fR dcmd の \fB-t\fR オプションを使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::version\fR\fR
.ad
.sp .6
.RS 4n
デバッガのバージョン番号を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fIaddress\fR \fB::vtop\fR [\fB-a\fR \fIas\fR]\fR
.ad
.sp .6
.RS 4n
可能な場合、指定された仮想アドレスに対する物理アドレスのマッピングを出力します。\fB::vtop\fR dcmd を利用できるのは、カーネルターゲットを検査しているとき、あるいは、\fB::context\fR dcmd を実行したあとで、カーネルクラッシュダンプ内のユーザープロセスを検査しているときだけです。
.sp
カーネルコンテキストからカーネルターゲットを検査しているとき、\fB-a\fR オプションを使用すると、仮想アドレスから物理アドレスへの変換で使用される代替アドレス空間構造体のアドレス (\fIas\fR) を指定できます。デフォルトでは、この変換にはカーネルのアドレス空間が使用されます。ダンプに含まれるのがカーネルページだけの場合でも、このオプションはアクティブなアドレス空間に対して利用できます。
.RE

.sp
.ne 2
.mk
.na
\fB[ \fIaddress\fR ] \fB::walk\fR \fIwalker-name\fR [ \fIvariable-name\fR ]\fR
.ad
.sp .6
.RS 4n
指定された walker を使用して、データ構造体の要素を調べます。\fB::walkers\fR dcmd を使用すると、使用可能な walker を一覧表示できます。walker は、大域的なデータ構造体について動作する場合もあり、開始アドレスを必要としないものがあります。たとえば、カーネル内の proc 構造体のリストを調べる場合などです。その他の walker は、アドレスが明示的に指定されている固有のデータ構造体上で動作します。たとえば、アドレス空間でポインタを指定して、セグメントのリストを調べる場合です。対話処理で使用される場合、\fB::walk\fR dcmd は、データ構造体内の各要素のアドレスをデフォルト形式で出力します。また、この dcmd は、パイプラインにアドレスリストを提供するときにも使用できます。walker 名には、前述の \fBdcmd and Walker Name Resolution\fR で説明した逆引用符 (\fB`\fR) 有効範囲規則を使用できます。オプションの \fIvariable-name\fR が指定されている場合には、\fBmdb\fR がパイプラインの次のステージを呼び出すときに walk の各ステップが返す値に、指定変数が割り当てられます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::walkers\fR\fR
.ad
.sp .6
.RS 4n
使用可能な walker の一覧と、各 walker の簡潔な説明を出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::whence\fR [ \fB-v\fR ] \fIname\fR . . .\fR
.ad
.br
.na
\fB\fB::which\fR [ \fB-v\fR ] \fIname\fR ...\fR
.ad
.sp .6
.RS 4n
指定された dcmd と walker をエクスポートする dmod を出力します。これらの dcmd を使用すると、指定された dcmd または walker の大域定義を現在提供しているのはどの dmod かを判断できます。大域的な名前解決の詳細については、前述の「dcmd と walker の名前解決」の節を参照してください。\fB\fR\fB-v\fR オプションを指定すると、各 dcmd や walker の代替定義を優先順に出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fIaddr\fR [ ,\fIlen\fR ]\fB::wp\fR [ \fB-/\fR\fB-dDestT\fR ] [ \fB-rwx\fR ] [ \fB-c\fR \fIcmd\fR ]\fR
.ad
.br
.na
\fB[ \fB-n\fR \fIcount\fR ] \fR
.ad
.br
.na
\fB\fIaddr\fR [ ,\fIlen\fR ] \fB:a\fR [ \fIcmd\fR . . . ]\fR
.ad
.br
.na
\fB\fIaddr\fR [ ,\fIlen\fR ] \fB:p\fR [ \fIcmd\fR . . . ]\fR
.ad
.br
.na
\fB\fI addr\fR [ ,\fIlen\fR ] \fB:w\fR [ \fIcmd\fR . . . ]\fR
.ad
.sp .6
.RS 4n
指定された場所にウォッチポイントを設定します。監視される領域の長さをバイト数で設定するには、dcmd の前に繰り返し回数を指定します。長さを明示的に設定しない場合、デフォルトは 1 バイトです。\fB::wp\fR dcmd を使用すると、読み取り (\fB-r\fR オプション)、書き込み (\fB-w\fR オプション)、または実行 (\fB-x\fR オプション) のアクセス権の任意の組み合わせでのトリガーが可能となるようにウォッチポイントを構成できます。\fB-d\fR、\fB-D\fR、\fB-e\fR、\fB-s\fR、\fB-t\fR、\fB-T\fR、\fB-c\fR、および \fB-n\fR オプションは、\fB::evset\fR dcmd で使用するのと同じです。\fB:a\fR dcmd は、指定されたアドレスに読み取り権のウォッチポイントを設定します。\fB:p\fR dcmd は、指定されたアドレスに実行権のウォッチポイントを設定します。\fB:w\fR dcmd は、指定されたアドレスに書き込み権のウォッチポイントを設定します。\fB:a\fR、\fB:p\fR、および \fB:w\fR dcmd の後ろにある引数は連結され、コールバック文字列となります。この文字列にメタキャラクタが含まれる場合、文字列を引用符で囲む必要があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB::xdata\fR\fR
.ad
.sp .6
.RS 4n
現在のターゲットによってエクスポートされた外部データバッファーを一覧表示します。外部データバッファーは、現在のターゲットに関連付けられた情報を示します。この情報は、標準ターゲット機能ではアクセスできないもので、アドレス空間、シンボルテーブル、レジスタセットなどが含まれています。これらのバッファーは、dcmd による使用が可能です。詳細については、\fI『Oracle Solaris Modular Debugger Guide』\fR を参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB:z\fR\fR
.ad
.sp .6
.RS 4n
すべてのイベント指定子を追跡対象ソフトウェアイベントのリストから削除します。\fB::delete\fR を使用しても、イベント指定子は削除できます。
.RE

.SH オプション
.sp
.LP
次のオプションがサポートされています。
.sp
.ne 2
.mk
.na
\fB\fB-A\fR\fR
.ad
.sp .6
.RS 4n
\fBmdb\fR モジュールの自動読み込みを無効にします。デフォルトでは、\fBmdb\fR は、ユーザープロセスまたはコアファイルのアクティブな共用ライブラリに対応しているデバッガモジュール、または稼働中のオペレーティングシステムかオペレーティングシステムのクラッシュダンプにある読み込み済みのカーネルモジュールに対応しているデバッガモジュールを読み込もうとします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR\fR
.ad
.sp .6
.RS 4n
強制的に raw ファイルデバッギングモードに入ります。デフォルトでは、\fBmdb\fR は、オブジェクトとコアファイルのオペランドがユーザーの実行可能ファイルとコアダンプを参照しているのか、または 1 組のオペレーティングシステムのクラッシュダンプファイルを参照しているのかを判断しようとします。ファイルのタイプを推測できない場合、デバッガはデフォルトでそのファイルをプレーンなバイナリデータとして調査します。\fB-f\fR オプションを使用すると、\fBmdb\fR は引数を調査すべき raw ファイルセットとして解釈します。 
.RE

.sp
.ne 2
.mk
.na
\fB\fB-F\fR\fR
.ad
.sp .6
.RS 4n
必要に応じて、指定されたユーザープロセスに強制的に接続します。デフォルトでは、\fBmdb\fR は、すでに \fBtruss\fR(1) など別のデバッグ用ツールの制御下にあるユーザープロセスへの接続を拒否します。\fB-F\fR オプションを指定すると、\fBmdb\fR はこれらのプロセスに接続します。これによって、\fBmdb\fR とプロセスを制御しようとしているほかのツールとの間で予期しない相互作用が発生する可能性があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-I\fR \fIpath\fR\fR
.ad
.sp .6
.RS 4n
マクロファイルを検出するためのデフォルトのパスを設定します。マクロファイルは、 \fB$<\fR または \fB$<<\fR dcmd を使用して読み取ります。このときのパスは、一連のディレクトリ名をコロン (\fB:\fR) 文字で区切ったものです。\fB-I\fR \fBinclude\fR パスと \fB-L\fR \fBlibrary\fR パス (以降を参照) には、次のトークンを含めることができます。
.sp
.ne 2
.mk
.na
\fB%i\fR
.ad
.sp .6
.RS 4n
現在の命令セットアーキテクチャー (\fBISA\fR) の名前 (「sparc」、「sparcv9」、または「i386」) に展開されます。
.RE

.sp
.ne 2
.mk
.na
\fB%o\fR
.ad
.sp .6
.RS 4n
変更対象のパスの古い値まで展開されます。これは、既存のパスの前または後ろにディレクトリを追加するときに有用です。
.RE

.sp
.ne 2
.mk
.na
\fB%p\fR
.ad
.sp .6
.RS 4n
現在のプラットフォーム文字列 (\fBuname\fR \fB-i\fR またはプロセスのコアファイルあるいはクラッシュダンプに格納されているプラットフォーム文字列) に展開されます。
.RE

.sp
.ne 2
.mk
.na
\fB%r\fR
.ad
.sp .6
.RS 4n
ルートディレクトリのパス名まで展開されます。\fB-R\fR オプションを使用すると、代替ルートディレクトリを指定できます。\fB-R\fR オプションを指定しないと、ルートディレクトリは \fBmdb\fR 実行可能ファイル自体へのパスから動的に決定されます。たとえば、\fB/bin/mdb\fR を実行した場合、ルートディレクトリは \fB/\fR です。\fB/net/hostname/bin/mdb\fR 実行した場合、ルートディレクトリは \fB/net/hostname\fR となります。
.RE

.sp
.ne 2
.mk
.na
\fB%t\fR
.ad
.sp .6
.RS 4n
現在のターゲット名まで展開されます。これはリテラル文字列「\fBproc\fR」(ユーザープロセスまたはユーザープロセスのコアファイル)、「\fBkvm\fR」(カーネルクラッシュダンプまたは稼働中のオペレーティングシステム)、または「\fBraw\fR」(raw ファイル) のいずれかです。
.RE

32 ビットの \fBmdb\fR に対するデフォルトのインクルードパスは、次のとおりです。
.sp
.in +2
.nf
%r/usr/platform/%p/lib/adb:%r/usr/lib/adb
.fi
.in -2
.sp

64 ビットの \fBmdb\fR に対するデフォルトのインクルードパスは、次のとおりです。
.sp
.in +2
.nf
%r/usr/platform/%p/lib/adb/%i:%r/usr/lib/adb/%i
.fi
.in -2
.sp

.RE

.sp
.ne 2
.mk
.na
\fB\fB-k\fR\fR
.ad
.sp .6
.RS 4n
強制的にカーネルデバッギングモードにします。デフォルトでは、\fBmdb\fR は、オブジェクトとコアファイルのオペランドがユーザーの実行可能ファイルとコアダンプを参照しているのか、または 1 組のオペレーティングシステムのクラッシュダンプファイルを参照しているのかを判断しようとします。\fB-k\fR オプションを指定すると、\fBmdb\fR は、これらのファイルがオペレーティングシステムのクラッシュダンプファイルであるとみなします。オブジェクトまたはコアオペランドを指定せずに \fB-k\fR オプションを指定すると、\fBmdb\fR は、オブジェクトファイルを \fB/dev/ksyms\fR に、コアファイルを \fB/dev/kmem\fR にデフォルト設定します。\fB/dev/kmem\fR に読み取りアクセスできるのはグループ sys だけです。書き込みアクセスにはすべての特権が必要です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-K\fR\fR
.ad
.sp .6
.RS 4n
\fBkmdb\fR をロードし、実行中のオペレーティングシステムカーネルを停止して、\fBkmdb\fR デバッガプロンプトを表示します。このオプションは、システムコンソールでしか使用してはいけません。それに続く \fBkmdb\fR プロンプトがシステムコンソールに表示されます。 
.RE

.sp
.ne 2
.mk
.na
\fB\fB-L\fR \fIpath\fR\fR
.ad
.sp .6
.RS 4n
デバッガモジュールを検索するためのデフォルトのパスを設定します。モジュールは起動時に自動的に読み込まれるか、または \fB::load\fR dcmd を使用して読み込まれます。このときのパスは、一連のディレクトリ名をコロン (\fB:\fR) 文字で区切ったものです。\fB-L\fR ライブラリパスには、前述の \fB-I\fR オプションで示したトークンも含めることができます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-m\fR\fR
.ad
.sp .6
.RS 4n
カーネルモジュールシンボルのデマンドローディングを無効にします。デフォルトでは、\fBmdb\fR は読み込まれたカーネルモジュールのリストを処理し、モジュールごとにシンボルテーブルのデマンドローディングを実行します。\fB-m\fR オプションを指定すると、\fBmdb\fR はカーネルモジュールのリストを処理したり、モジュールごとにシンボルテーブルを提供したりしなくなります。結果として、アクティブなカーネルモジュールに対応する \fBmdb\fR モジュールは起動時に読み込まれません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-M\fR\fR
.ad
.sp .6
.RS 4n
すべてのカーネルモジュールシンボルを事前に読み込みます。デフォルトでは、\fBmdb\fR はカーネルモジュールシンボルのデマンドローディングを実行します。 アドレスがそのモジュールのテキストであるとき、またはデータセクションが参照されているとき、モジュールのシンボルテーブルが完全に読み取られます。\fB-M\fR オプションを指定すると、\fBmdb\fR は起動時にすべてのカーネルモジュールのシンボルテーブルを完全に読み込みます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR \fIoption\fR\fR
.ad
.sp .6
.RS 4n
指定したデバッガオプションを有効にします。\fB-o\fR 形式のオプションを使用した場合は、指定したオプションが無効になります。\fI\fR次に掲載しているものを除いて、各オプションともデフォルトでは無効になっています。\fBmdb\fR は次のオプション引数を認識します。\fI\fR
.sp
.ne 2
.mk
.na
\fB\fBadb\fR\fR
.ad
.sp .6
.RS 4n
\fBadb\fR(1) の互換性をより厳密にします。プロンプトは空の文字列に設定され、出力ページャーなどの多数の \fBmdb\fR 機能が無効になる。
.RE

.sp
.ne 2
.mk
.na
\fB\fBarray_mem_limit=\fR\fIlimit\fR\fR
.ad
.sp .6
.RS 4n
\fB::print\fR が表示する配列のメンバー数に対してデフォルトの制限を設定します。\fIlimit\fR が特別なトークン \fBnone\fR である場合、デフォルトで配列のすべてのメンバーが表示される。
.RE

.sp
.ne 2
.mk
.na
\fB\fBarray_str_limit=\fR\fIlimit\fR\fR
.ad
.sp .6
.RS 4n
\fB::print\fR が char 型の配列を出力するときに ASCII 文字列として表示する文字数に対してデフォルトの制限を設定します。\fIlimit\fR が特別なトークン \fBnone\fR である場合、デフォルトで char 配列全体が string として表示される。
.RE

.sp
.ne 2
.mk
.na
\fB\fBfollow_exec_mode=\fR\fImode\fR\fR
.ad
.sp .6
.RS 4n
\fBexec\fR(2) システムコールに従って動作するようにデバッガを設定します。\fImode\fR は次の名前付き定数の 1 つである必要があります。
.sp
.ne 2
.mk
.na
\fB\fBask\fR\fR
.ad
.sp .6
.RS 4n
stdout が端末デバイスである場合、デバッガは \fBexec\fR(2) システムコールが返ったあとに停止して、exec または stop のどちらに従うかをユーザーに尋ねる。stdout が端末デバイスではない場合、\fBask\fR モードはデフォルトで \fBstop\fR になる。
.RE

.sp
.ne 2
.mk
.na
\fB\fBfollow\fR\fR
.ad
.sp .6
.RS 4n
デバッガは自動的にターゲットプロセスを継続し、新しい実行可能ファイルに基づいて、ターゲットプロセスのマッピングとシンボルテーブルをすべてリセットし、exec に従う。\fBfollow\fR の動作の詳細については、後述の「注意事項」の「exec との対話」を参照。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBstop\fR\fR
.ad
.sp .6
.RS 4n
exec システムコールから戻ったあと、デバッガは exec システムコールに従うことを停止します。\fBstop\fR の動作の詳細については、後述の「注意事項」の「exec との対話」を参照。\fB\fR
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBfollow_fork_mode=\fR\fImode\fR\fR
.ad
.sp .6
.RS 4n
\fBfork\fR(2)、\fBfork1\fR(2)、または \fBvfork\fR(2) システムコールに従って動作するようにデバッガを設定します。\fImode\fR は次の名前付き定数の 1 つである必要があります。
.sp
.ne 2
.mk
.na
\fB\fBask\fR\fR
.ad
.sp .6
.RS 4n
stdout が端末デバイスである場合、デバッガは \fBfork\fR(2) システムコールが返ったあとに停止して、親プロセスまたは子プロセスのどちらに従うかをユーザーに尋ねる。stdout が端末デバイスではない場合、\fBask\fR モードはデフォルトで \fBparent\fR になる。
.RE

.sp
.ne 2
.mk
.na
\fB\fBparent\fR\fR
.ad
.sp .6
.RS 4n
デバッガは親プロセスに従い、子プロセスから切断して子プロセスが動作するように設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBchild\fR\fR
.ad
.sp .6
.RS 4n
デバッガは子プロセスに従い、親プロセスから切断して親プロセスが動作するように設定します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBignoreeof\fR\fR
.ad
.sp .6
.RS 4n
端末に \fBEOF\fR シーケンス (\fB^D\fR) が入力されても、デバッガは終了しません。終了するには \fB::quit\fR dcmd を使用する必要がある
.RE

.sp
.ne 2
.mk
.na
\fB\fBnostop\fR\fR
.ad
.sp .6
.RS 4n
\fB-p\fR オプションを指定したか、\fB::attach\fR または \fB:A\fR dcmd を適用した場合、ユーザープロセスと接続しているときには、そのユーザープロセスを停止しません。\fBnostop\fR の動作の詳細については、後述の「注意事項」の「プロセスの接続と解放」を参照。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBpager\fR\fR
.ad
.sp .6
.RS 4n
出力ページャーを有効にする (デフォルト)。
.RE

.sp
.ne 2
.mk
.na
\fB\fBrepeatlast\fR\fR
.ad
.sp .6
.RS 4n
復帰改行文字がコマンドとして端末に入力された場合、\fBmdb\fR は前のコマンドを現在のドットの値で繰り返す。\fI\fR\fB-o\fR \fBadb\fR を指定した場合、このオプションも自動的に指定されている
.RE

.sp
.ne 2
.mk
.na
\fB\fBshowlmid\fR\fR
.ad
.sp .6
.RS 4n
\fBmdb\fR は \fILM_ID_BASE\fR と \fILM_ID_LDSO\fR 以外のリンクマップを使用するユーザーアプリケーションでシンボルの命名と識別をサポートする (「シンボルの名前解決」を参照)。\fB\fR\fILM_ID_BASE\fR または \fILM_ID_LDSO\fR 以外のリンクマップ上のシンボルは \fBLMlmid`library`symbol\fR のように表示される (このとき、\fBlmid\fR はデフォルトの出力基数 (16 進数) のリンクマップ \fBID\fR)。\fBshowlmid\fR オプションを有効にすると、すべてのシンボルとオブジェクト (\fILM_ID_BASE\fR と \fILM_ID_LDSO\fR に関連するものも含む) のリンクマップ \fBID\fR 有効範囲を表示するように \fBmdb\fR を構成できる。オブジェクトファイル名を扱う組み込み dcmd (\fB::nm\fR、\fB::mappings\fR、\fB$m\fR、\fB::objects\fR など) は、前述の \fBshowlmid\fR の値に従ってリンクマップ \fBID\fR を表示します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR \fIpid\fR\fR
.ad
.sp .6
.RS 4n
指定されたプロセス ID に接続し、そのプロセスを停止します。\fBmdb\fR は、\fB/proc/\fIpid\fR/object/a.out\fR ファイルを実行可能ファイルのパス名として使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-P\fR \fIprompt\fR\fR
.ad
.sp .6
.RS 4n
コマンドプロンプトを設定します。デフォルトのプロンプトは、「\fB>\fR」です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-R\fR \fIroot\fR\fR
.ad
.sp .6
.RS 4n
パス名の展開に合わせてルートディレクトリを設定します。デフォルトでは、ルートディレクトリは \fBmdb\fR 実行可能ファイル自体のパス名から導かれます。ルートディレクトリは、パス名の展開の際に \fB%r\fR トークンと置き換えられます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR \fIdistance\fR\fR
.ad
.sp .6
.RS 4n
アドレスからシンボル名への変換用のシンボルマッチングディスタンスを、指定した \fIdistance\fR に設定します。デフォルトでは、\fBmdb\fR はこの距離をゼロに設定し、スマートマッチングモードを有効にします。\fBELF\fR シンボルテーブルのエントリには値 V とサイズ S が含まれ、関数またはデータオブジェクトのサイズがバイト単位で示されます。スマートモードでは、\fBmdb\fR は、A が [ V, V + S ) の範囲にある場合、アドレス A と与えられたシンボルとを一致させます。ゼロ以外の距離を指定した場合も同じアルゴリズムが使用されますが、前述の式に S を指定した場合、常に絶対距離が指定され、シンボルのサイズは無視されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-S\fR\fR
.ad
.sp .6
.RS 4n
 ユーザーの \fB~/.mdbrc\fR ファイルの処理を抑制します。デフォルトでは、\fBmdb\fR は、$\fBHOME\fR で定義されているユーザーのホームディレクトリにマクロファイル \fB\&.mdbrc\fR があれば、それを読み取って処理します。\fB-S\fR オプションを指定すると、このファイルは読み取られません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-u\fR\fR
.ad
.sp .6
.RS 4n
強制的にユーザーデバッギングモードにします。デフォルトでは、\fBmdb\fR は、オブジェクトとコアファイルのオペランドがユーザーの実行可能ファイルとコアダンプを参照しているのか、または 1 組のオペレーティングシステムのクラッシュダンプファイルを参照しているのかを判断しようとします。\fB-u\fR オプションを使用すると、\fBmdb\fR は、これらのファイルがオペレーティングシステムのクラッシュダンプファイルではないとみなします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-U\fR\fR
.ad
.sp .6
.RS 4n
\fBkmdb\fR が読み込まれた場合は、それを読み込み解除します。\fBkmdb\fR が使用中でない場合は、それを読み込み解除し、カーネルデバッガで使用されたメモリーを解放してオペレーティングシステムが利用できるようにします。 
.RE

.sp
.ne 2
.mk
.na
\fB\fB-V\fR \fIversion\fR\fR
.ad
.sp .6
.RS 4n
逆アセンブラのバージョンを設定します。デフォルトでは、\fBmdb\fR は、デバッグターゲットに対する適切な逆アセンブラのバージョンを判断しようとします。\fB-V\fR オプションを使用すると、逆アセンブラを明示的に設定できます。\fB::disasms\fR dcmd によって、使用可能な逆アセンブラのバージョンが一覧表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR\fR
.ad
.sp .6
.RS 4n
指定したオブジェクトとコアファイルを書き込み用に開きます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-W\fR\fR
.ad
.sp .6
.RS 4n
入出力デバイスに割り当てられるメモリーアドレスへのアクセスを許可します。デフォルトでは、\fBmdb\fR はそのようなアクセスを許可しません。これは、多くのデバイスには無効なソフトウェア操作に対するハードウェア保護機能がないためです。このオプションは、デバイスドライバのデバッグ時にのみ、注意して使用してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-y\fR\fR
.ad
.sp .6
.RS 4n
tty モードに対する明示的な端末初期化シーケンスを送信します。端末には、たとえば \fBcmdtool\fR(1) など、tty モードに切り換えるために明示的な初期化シーケンスを必要とするものがあります。この初期化シーケンスがないと、\fBmdb\fR からスタンドアウトモードなどの端末機能を使用できない場合があります。
.RE

.SH オペランド
.sp
.LP
次のオペランドがサポートされています。
.sp
.ne 2
.mk
.na
\fB\fIobject\fR\fR
.ad
.sp .6
.RS 4n
調査する \fBELF\fR 書式のオブジェクトファイルを指定します。\fBmdb\fR が調査および編集できるのは、\fBELF\fR 書式の実行可能ファイル (\fBET_EXEC\fR)、\fBELF\fR 動的ライブラリファイル (\fBET_DYN\fR)、\fBELF\fR 再配置可能オブジェクトファイル (\fBET_REL\fR)、およびオペレーティングシステムのシンボルテーブル (unix.X ファイル) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIcore\fR\fR
.ad
.sp .6
.RS 4n
\fBELF\fR プロセスコアファイル (\fBET_CORE\fR) またはオペレーティングシステムのクラッシュダンプ (vmcore.X ファイル) を指定します。\fBELF\fR コアファイルオペランド (core) を指定する場合、対応するオブジェクトファイルを指定しないと、\fBmdb\fR はいくつかの異なるアルゴリズムを使用して、コアファイルを生成した実行可能ファイルの名前を推測しようとします。このような実行可能ファイルが見つからなかった場合、\fBmdb\fR は動作し続けますが、いくつかのシンボル情報が利用できなくなっている可能性があります。
.RE

.sp
.ne 2
.mk
.na
\fB\fIsuffix\fR\fR
.ad
.sp .6
.RS 4n
オペレーティングシステムのクラッシュダンプファイルのペアを表す数値の接尾辞を指定します。たとえば、接尾辞が「\fB3\fR」である場合、\fBmdb\fR は「\fBunix.3\fR」や「\fBvmcore.3\fR」などの名前のファイルを調査すると推測します。これらのファイルは存在しないが、「\fBvmdump.3\fR」が存在する場合は、ダンプファイルを圧縮解除するには最初に \fBsavecore -f vmdump.3\fR を実行する必要があることを示すメッセージが出力されます。同じ名前の実際のファイルが現在のディレクトリに存在する場合、この数字文字列は接尾辞としては解釈されません。
.RE

.SH 使用法
.sp
.LP
\fBmdb\fR は、大規模なファイルも認識しつつ、すべての入力ファイル (スクリプト、オブジェクトファイル、コアファイル、raw データファイルなど) を処理します。2G バイト (2^31 バイト) 以上の大規模なファイルの処理の詳細は、\fBlargefile\fR(5) を参照してください。
.SH 終了ステータス
.sp
.LP
次の終了値が返されます。
.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.sp .6
.RS 4n
デバッガは正常に実行を終了しました。
.RE

.sp
.ne 2
.mk
.na
\fB\fB1\fR\fR
.ad
.sp .6
.RS 4n
致命的なエラーが発生。
.RE

.sp
.ne 2
.mk
.na
\fB\fB2\fR\fR
.ad
.sp .6
.RS 4n
無効なコマンド行オプションが指定されました。
.RE

.SH 環境
.sp
.ne 2
.mk
.na
\fB\fBHISTSIZE\fR\fR
.ad
.sp .6
.RS 4n
この変数は、コマンド履歴リストの最大の長さを決定するために使用されます。この変数が存在しない場合、デフォルトの長さは \fB128\fR です。
.RE

.sp
.ne 2
.mk
.na
\fB\fBHOME\fR\fR
.ad
.sp .6
.RS 4n
この変数は、ユーザーのホームディレクトリ (\fB\&.mdbrc\fR ファイルが存在する場所) のパス名を決定するために使用されます。この変数が存在しない場合、\fB\&.mdbrc\fR は処理されません。
.RE

.sp
.ne 2
.mk
.na
\fB\fBSHELL\fR\fR
.ad
.sp .6
.RS 4n
この変数は、\fB!\fR メタキャラクタを使用して要求されたシェルエスケープを処理するシェルのパス名を決定するために使用されます。この変数が存在しない場合、\fB/bin/sh\fR が使用されます。
.RE

.SH ファイル
.sp
.ne 2
.mk
.na
\fB\fB$HOME/.mdbrc\fR\fR
.ad
.sp .6
.RS 4n
ユーザーの \fBmdb\fR 初期設定ファイル。\fB\&.mdbrc\fR ファイルが存在する場合、そのファイルが処理されるのは、デバッグターゲットが初期化されたあとですが、モジュールの自動読み込みが実行される前、またはコマンドが標準入力から読み込まれる前です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/dev/kmem\fR\fR
.ad
.sp .6
.RS 4n
カーネルの仮想記憶イメージデバイス。このデバイス固有のファイルは、稼働中のオペレーティングシステムを検査するときにコアファイルとして使用されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/dev/ksyms\fR\fR
.ad
.sp .6
.RS 4n
カーネルのシンボルテーブルデバイス。このデバイス固有のファイルは、稼働中のオペレーティングシステムを検査するときにオブジェクトファイルとして使用されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/proc/\fIpid\fR/*\fR\fR
.ad
.sp .6
.RS 4n
ユーザープロセスを検査および制御するときに読み込まれるプロセス情報ファイル。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/usr/lib/adb\fR\fR
.ad
.br
.na
\fB\fB/usr/platform/\fIplatform-name\fR/lib/adb\fR\fR
.ad
.sp .6
.RS 4n
\fB$<\fR および \fB$<<\fR dcmd で読み込まれるマクロファイルのデフォルトディレクトリ。\fIplatform-name\fR はプラットフォームの名前で、コアファイルまたはクラッシュダンプの情報から、あるいは現在のマシンから、\fBuname\fR \fB-i\fR を使用する場合と同じように得られます (\fBuname\fR(1) を参照)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB/usr/lib/mdb\fR\fR
.ad
.br
.na
\fB\fB/usr/platform/\fIplatform-name\fR/lib/mdb\fR\fR
.ad
.sp .6
.RS 4n
\fB::load\fR dcmd を使用して読み込まれるデバッガモジュールのデフォルトディレクトリ。\fIplatform-name\fR はプラットフォームの名前で、コアファイルまたはクラッシュダンプの情報から、あるいは現在のマシンから、\fBuname\fR \fB-i\fR を使用する場合と同じように得られます (\fBuname\fR(1) を参照)。
.RE

.SH 属性
.sp
.LP
属性についての詳細は、\fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件developer/debug/mdb
_
インタフェースの安定性確実
.TE

.SH 関連項目
.sp
.LP
\fBadb\fR(1), \fBcmdtool\fR(1), \fBgcore\fR(1), \fBproc\fR(1), \fBpgrep\fR(1), \fBps\fR(1), \fBstty\fR(1), \fBtruss\fR(1), \fBuname\fR(1), \fBcoreadm\fR(1M), \fBdumpadm\fR(1M), \fBlargefile\fR(5), \fBsavecore\fR(1M), \fBexec\fR(2), \fBfork\fR(2), \fB_lwp_self\fR(2), \fBpipe\fR(2), \fBvfork\fR(2), \fBdlopen\fR(3C), \fBelf\fR(3ELF), \fBlibc_db\fR(3LIB), \fBlibkvm\fR(3LIB), \fBlibthread\fR(3LIB), \fBsignal\fR(3C), \fBsignal.h\fR(3HEAD), \fBthr_self\fR(3C), \fBcore\fR(4), \fBproc\fR(4), \fBattributes\fR(5), \fBlargefile\fR(5), \fBthreads\fR(5), \fBksyms\fR(7D), \fBmem\fR(7D)
.sp
.LP
\fI『Linker and Libraries Guide』\fR
.sp
.LP
\fI『Oracle Solaris Modular Debugger Guide』\fR
.SH 警告
.SS "エラー回復メカニズムの使用"
.sp
.LP
デバッガとその dmod は同じアドレス空間内で動作するので、dmod にバグがあると、\fBmdb\fR がコアをダンプしたり、誤動作したりする可能性があります。\fBmdb\fR の resume 機能 (前述の「シグナル処理」を参照) はこのような状況に対して、制限付きで回復メカニズムを提供します。\fB\fRしかし、dmod 自身の状態やデバッガの大域的な状態だけでは、\fBmdb\fR は該当する dmod が壊れているかどうかを最終的には判断できません。したがって、resume 操作は安全であるとは保証されず、また、その後のデバッガのクラッシュを防ぐこともできません。resume によるもっとも安全な対処方法は、重要なデバッグ情報を保存し、デバッガを停止し再起動します。
.SS "動作中のオペレーティングシステムのデバッガによる修正"
.sp
.LP
動作中のオペレーティングシステムのアドレス空間をデバッガを使用して修正する (書き込む) ことは非常に危険であり、ユーザーがカーネルデータの構造を破損するとシステムパニックが発生する可能性があります。
.SH 注意事項
.SS "プロセスコアファイルの調査に関する制限"
.sp
.LP
\fBmdb\fR は、Solaris 2.6 より前の Solaris リリースで生成されたプロセスコアファイルの調査はサポートしていません。Solaris 9 以前のリリースで生成されたコアファイルをデバッグするときは、シンボル情報を利用できない場合があります。これらのコアファイルにはテキストセクションと読み取り専用データが存在しないため、プロセスがコアをダンプした時点でプロセスに存在したデータとシンボル情報が一致しない場合があります。Solaris 9 以降のリリースでは、テキストセクションと読み取り専用データはデフォルトでコアファイルに含まれます。ユーザーは、\fBcoreadm\fR(1M) を使用して、その情報をコアファイルから除外するようにプロセスを構成できます。これにより、それらのコアファイルの \fBmdb\fR によって出力される情報は、プロセスがコアをダンプした時点で存在したデータと一致しなくなります。x86 版の Solaris システムから生成されたコアファイルは SPARC 版の Solaris システムでは調査できず、その逆もできません。
.SS "クラッシュダンプファイルの調査に関する制限"
.sp
.LP
Solaris 7 以前のリリースで生成されたクラッシュダンプを調査するには、対応するオペレーティングシステムのリリース用の libkvm が必要です。あるオペレーティングシステムのリリースで生成されたクラッシュダンプを別のオペレーティングシステムのリリースで dmod を使用して調査する場合、カーネルの実装によっては、いくつかの dcmd や walker が適切に動作しない可能性があります。この状況を検出すると、\fBmdb\fR は警告メッセージを発行します。x86 版の Solaris システムから生成されたクラッシュダンプは SPARC 版の Solaris システムでは調査できず、その逆もできません。
.SS "32 ビットと 64 ビットのデバッガ間の関係"
.sp
.LP
\fBmdb\fR は 32 ビットと 64 ビットの両方のプログラムのデバッグをサポートします。ターゲットのプログラムを調査して、そのデータモデルを決定したあと、\fBmdb\fR は必要に応じて自動的に、ターゲットと同じデータモデルを持つ \fBmdb\fR バイナリを実行し直します。このアプローチによって、読み込まれたモジュールがプライマリターゲットと同じデータモデルを使用するので、デバッガモジュールを作成する作業が簡単になります。64 ビットのターゲットプログラムをデバッグできるのは 64 ビットのデバッガだけです。64 ビットのデバッガを使用できるのは 64 ビットのオペレーティング環境が動作しているシステム上だけです。
.sp
.LP
64 ビットプロセスを exec する 32 ビットプロセスをデバッグする場合、またはその逆の場合、デバッガを実行し直す必要があることもあります。このような状況に対応する方法の詳細については、後述の「exec との対話」を参照してください。\fB\fR
.SS "exec との対話"
.sp
.LP
制御されているプロセスが \fBexec\fR(2) を正常に実行するとき、デバッガの動作は \fB::set\fR \fB-o\fR \fB follow_exec_mode\fR オプションで制御できます (前述の説明を参照)。デバッガと対象プロセスのデータモデルが同じ場合、exec のあとで、\fBmdb\fR が自動的にターゲットを継続するか、デバッガのプロンプトに戻るかは、\fBstop\fR モードか \fBfollow\fR モードかによって決定されます。デバッガと対象プロセスのデータモデルが異なる場合、\fBfollow\fR モードでは、\fBmdb\fR は自動的に \fBmdb\fR バイナリを適切なデータモデルで再度 exec して、プロセスに接続し直すので、exec から戻っても、プロセスは停止したままになります。このような再実行後、すべてのデバッガの状態が保存されるわけではありません。
.sp
.LP
32 ビットの対象プロセスが 64 ビットのプログラムを実行した場合、\fBstop\fR モードでは、コマンドプロンプトに戻りますが、この時点で 64 ビットデータモデルを使用しているので、対象プロセスを検査できません。デバッグを再開するには、\fB::release\fR \fB- a\fR dcmd を実行して、\fBmdb\fR を終了し、そして、\fBmdb\fR \fB-p\fR \fIpid\fR を実行して、64 ビットデバッガを対象プロセスに接続し直します。
.sp
.LP
64 ビットの対象プロセスが 32 ビットのプログラムを実行した場合、\fBstop\fR モードでは、コマンドプロンプトに戻りますが、新しいプロセスを検査する機能はかなり制限されます。組み込み dcmd はすべてマニュアルどおりに機能しますが、読み込み可能な dcmd は構造体のデータモデル変換を実行しないので、マニュアルどおりには機能しません。デバッグ機能を完全に復元するには、前述のように、デバッガを解放し、プロセスに接続し直す必要があります。
.SS "ジョブ制御との対話"
.sp
.LP
ジョブ制御によって停止されている (つまり、\fBSIGTSTP\fR、\fBSIGTTIN\fR、または \fBSIGTTOU\fR で停止されている) プロセスにデバッガが接続されている場合、継続用の dcmd で継続しようとしても、そのプロセスは再度「動作中 (running)」に設定できません。対象プロセスが同じセッションのメンバーである場合 (つまり、\fBmdb\fR と同じ制御端末を共用している場合)、\fBmdb\fR は関連するプロセスグループをフォアグラウンドに持ってきて、\fBSIGCONT\fR でプロセスを継続し、そのプロセスをジョブ制御の停止から再開しようとします。このようなプロセスから \fBmdb\fR を切断すると、mdb はそのプロセスグループをバックグラウンドに戻してから終了します。対象プロセスが同じセッションのメンバーでない場合、\fBmdb\fR はそのプロセスを安全にフォアグラウンドに持ってくることができないので、mdb はデバッガに関してはそのプロセスを継続しますが、そのプロセスはジョブ制御によって停止されているままになります。この場合、\fBmdb\fR は警告を出力するので、ユーザーは適切なシェルから \fBfg\fR コマンドを実行して、プロセスを再開する必要があります。
.SS "プロセスの接続と解放"
.sp
.LP
\fBmdb\fR が動作中のプロセスに接続するとき、プロセスは停止し、継続用の dcmd の 1 つが適用されるまで、あるいは、デバッガが終了するまで停止したままになります。\fB-p\fR オプションでデバッガをプロセスに接続する前、あるいは、\fB::attach\fR または \fB:A\fR コマンドを発行する前に、\fB-o\fR \fBnostop\fR オプションを有効にしている場合、\fBmdb\fR はプロセスに接続しますが、プロセスを停止しません。プロセスが動作している間、(結果の整合性は失われるのにもかかわらず) プロセスは通常どおりに監視でき、ブレークポイントや追跡用のフラグも有効にできます。プロセスが動作している間に \fB:c\fR または \fB::cont\fR dcmd を実行した場合、デバッガはプロセスが停止するまで待機します。どの追跡対象ソフトウェアイベントも発生しない場合、\fB:c\fR または \fB::cont\fR のあと、割り込み文字 (通常は \fB^C\fR) を入力すると、プロセスを強制的に停止し、デバッガに制御を戻すことができます。
.sp
.LP
\fB:R\fR、\fB::release\fR、\fB:r\fR、\fB::run\fR、\fB$q\fR、または \fB::quit\fR dcmd を実行した場合、あるいは、\fBEOF\fR またはシグナルなどの結果としてデバッガが終了した場合、\fBmdb\fR は現在動作中のプロセスを (もしあれば) 解放します。プロセスが本来デバッガで \fB:r\fR または \fB::run\fR を使用して作成されていた場合、そのプロセスは解放されると、\fBSIGKILL\fR が送信された場合と同じように強制的に終了されます。プロセスが \fBmdb\fR に接続される前にすでに動作していた場合、そのプロセスは解放されると、もう一度「動作中 (running)」に設定されます。プロセスを解放して停止および放棄したままにするには、\fB::release\fR \fB-a\fR オプションを使用します。
.SS "シンボルデバッグ情報"
.sp
.LP
\fB::list\fR、\fB::offsetof\fR、\fB::print\fR、および \fB::sizeof\fR dcmd では、1 つ以上のロードオブジェクトに \fBmdb\fR での使用に適した圧縮シンボルデバッグ情報が含まれている必要があります。現時点ではこの情報を利用できるのは、特定の Solaris カーネルモジュールだけです。
.SS "開発者向けの情報"
.sp
.LP
\fI『Oracle Solaris Modular Debugger Guide』\fRには、\fBmdb\fR の機能に関する詳細な説明、およびデバッガモジュールの開発者向け情報が記載されています。
.sp
.LP
ヘッダーファイル \fB<sys/mdb_modapi.h>\fR には MDB モジュール \fBAPI\fR にある関数のプロトタイプが含まれており、\fB/source/demo/mdb-examples\fR パッケージにはディレクトリ \fB/usr/demo/mdb\fR にあるサンプルモジュールのソースコードが含まれています。
