'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 2010 Oracle and/or its affiliates. All rights reserved.
.TH csh 1 "2010 年 4 月 16 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
csh \- C に似た構文を持つシェル・コマンドインタプリタ
.SH 形式
.LP
.nf
\fBcsh\fR [\fB-bcefinstvVxX\fR] [\fIargument\fR]...
.fi

.SH 機能説明
.sp
.LP
\fBcsh\fR は、C シェルの略で、C 言語に似た構文を持つ コマンドインタプリタです。Bourne シェルにはない多くの便利な 対話型の機能を備えています。たとえば、ファイル名の補完、コマンド別名指定、履歴置換、ジョブ制御、多くの組み込みコマンドなどの機能です。Bourne シェルと同様に、C シェルは変数、コマンド、およびファイル名置換機能を提供します。
.SS "初期化と終了"
.sp
.LP
C シェルを起動すると、まず通常ホームディレクトリにある \fB\&.cshrc\fR が読み取り可能であるか、当該ユーザーがその所有者であるか、または当該ユーザーのグループ \fBID\fR がそのグループ \fBID\fR と一致するかチェックし、一致していれば .cshrc ファイルを実行します。もし、C シェルを `\fB\(mi\fR\&' で始まる名前で起動すると、そのシェルはログインシェルとして実行されます (\fBlogin\fR(1) を起動するときの動作と同じ)。\fB\fR
.sp
.LP
シェルがログインシェルであった場合、実行は連続して行われます。 最初に \fB/etc/.login\fR 中のコマンドが実行されます。次に ユーザーのホームディレクトリにある \fB\&.cshrc\fR ファイルのコマンドが実行されます。\fB\fRその後、シェルはユーザーのホームディレクトリにある \fB\&.login \fR ファイルのコマンドを実行します。このとき、このファイルにも \fB\&.cshrc\fR と同様のアクセス権チェックが実施されます。通常 \fB\&.login\fR ファイルには、端末の種類や環境を指定する コマンドが入っています。(ファイルのインタプリタの説明については、\fB「コマンドの実行」\fRと \fBexec\fR(2) を参照。)
.sp
.LP
ログインシェルが終了したとき、シェルはユーザーのホームディレクトリにある \fB\&.logout\fR ファイルのコマンドを実行します。このとき、このファイルにも \fB\&.cshrc\fR と同様のアクセス権チェックが実施されます。
.SS "対話型動作"
.sp
.LP
起動処理が終了すると、C シェルはプロンプト \fBhostname\fR\fB%\fR (特権ユーザーなら \fBhostname\fR\fB#\fR) を表示して、端末からコマンドの読み取りを開始します。以降、シェルは以下の処理を繰り返します。 まず入力コマンドを 1 行読み取り、複数のワードに分解します。\fI\fR次にこれらのワードを履歴に記憶し、構文解析します (下記の「使用法」を参照)。最後に、現在の行にある各コマンドを実行します。
.SS "非対話型動作"
.sp
.LP
非対話形式で動作しているとき、シェルは端末からの入力を促すプロンプトを表示しません。非対話形式の C シェルは、コマンド行で引数として与えられたコマンドを実行するか、スクリプトと呼ばれるファイルからコマンドを読み取り、実行します。\fI\fR
.SH オプション
.sp
.LP
次のオプションがサポートされています。
.sp
.ne 2
.mk
.na
\fB\fB-b\fR\fR
.ad
.RS 6n
.rt  
オプションの処理を強制的に中断します。以降のコマンド行引数は、C シェルのオプションとしては解釈されません。これによって、オプションを明確にスクリプトに渡すことができます。このオプションが設定されていなければ、シェルは set-user-ID または set-group-ID スクリプトを実行しません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR\fR
.ad
.RS 6n
.rt  
最初の引数 (必ず指定する) を実行します。\fI\fR残りの引数は、引数リスト変数 \fBargv\fR に格納され、\fBcsh\fR に直接渡されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR\fR
.ad
.RS 6n
.rt  
コマンドが異常終了したり、0 以外の終了ステータスを返したとき、処理を終了します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR\fR
.ad
.RS 6n
.rt  
高速起動。開始時に、\fB\&.cshrc\fR ファイルおよび \fB\&.login\fR ファイル (ログインシェルのとき) を読みません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-i\fR\fR
.ad
.RS 6n
.rt  
強制的に対話型にします。標準入力が端末 (文字特殊装置) でなくても、コマンド行入力を促すプロンプトを表示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR\fR
.ad
.RS 6n
.rt  
構文解析はしますが、コマンドは実行しません。このオプションは、C シェルスクリプトの構文エラーを チェックするのに使用できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR\fR
.ad
.RS 6n
.rt  
標準入力からコマンドを受け取ります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR\fR
.ad
.RS 6n
.rt  
コマンド行を 1 行読み取って実行します。後続の入力行へコマンド行が継続することを示すには、復帰改行 (NEWLINE) を `\fB\e\fR\&' (バックスラッシュ) でエスケープします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-v\fR\fR
.ad
.RS 6n
.rt  
冗長。定義済み変数 \fBverbose\fR を設定します。コマンド入力のエコーを、履歴置換後 (他の置換の前) かつ実行前に行います。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-V\fR\fR
.ad
.RS 6n
.rt  
\fB\&.cshrc\fR を読み取る前に \fBverbose\fR 変数を設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR\fR
.ad
.RS 6n
.rt  
エコー。\fBecho\fR 変数を設定します。すべての置換後、実行の前にコマンドをエコーします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-X\fR\fR
.ad
.RS 6n
.rt  
\fB\&.cshrc\fR を読み取る前に \fBecho\fR 変数を設定します。
.RE

.sp
.LP
\fB-c\fR、\fB-i\fR、\fB-s\fR、および \fB-t\fR の各オプションを除き、最初の必須 \fIargument\fR はコマンド名またはスクリプト名とみなされます。そして 0 番目の引数として渡され、後続の引数はそのコマンドまたは スクリプトの引数リストへ追加されます。
.SH 使用法
.SS "ファイル名の補完"
.sp
.LP
\fBfilec\fR 変数を設定することによって、対話型 C シェルは、部分的に入力されたファイル名またはユーザー名を補完することができます。ファイル名を部分的にあいまいに入力して \fBESC\fR 文字を入力すると、シェルは 作業用ディレクトリから一致するファイルを検索して、残りの文字を埋めます。
.sp
.LP
ファイル名を部分的に入力して \fBEOF\fR 文字 (通常は CTRL-D) を入力すると、シェルは 一致するすべてのファイル名を一覧表示します。そして、入力された不完全なコマンド行の内容を表示して、再度プロンプトを表示します。
.sp
.LP
最後のワード (入力値の一部) がチルド (\fB~\fR) で始まる場合、シェルは現在のディレクトリのファイル名ではなく、ユーザー名を補完しようとします。
.sp
.LP
端末は、ビープ音を鳴らすことによって、エラーまたは複数のファイル名が一致したことを知らせます。この音は、\fBnobeep\fR 変数を設定することによって抑止できます。\fBfignore\fR 変数に特定の接尾辞のリストを設定しておけば、その接尾辞を持つファイルを除外することができます。ただし、その接尾辞を持つファイル名以外に一致するものが見つからなければ、この変数は無視されます。なお \fBEOF\fR 文字によるファイル名のリスト出力には、\fBfignore\fR が示す除外対象ファイル名も含まれます。
.SS "字句構造"
.sp
.LP
シェルは、入力行をスペース文字およびタブでワードに分解します。ただし、以下に説明する例外を除きます。\fB&\fR、\fB|\fR、\fB;\|\fR、\fB<\|\fR、\fB>\|\fR、\fB(\|\fR、および \fB\|)\fR の各文字は、それぞれ別個のワードを形成します。ただし対で使用すると、1 対で 1 つのワードを形成します。これらのシェルメタキャラクタは、他のワードの一部になることもできます。その場合、`\fB\e\fR\&' (バックスラッシュ) を前に付けると、メタキャラクタの持つ特別な意味を抑制できます。\fB\e\fR の付いた復帰改行文字は、スペース文字と同等です。
.sp
.LP
さらに、単一引用符 (\|\fB\&'\fR\|) 、二重引用符 (\|\fB"\fR\|) 、または逆引用符 (\|\fB`\fR\|) で囲まれた文字列は、ワードの一部を生成します。このような文字列の中に含まれるスペース文字またはタブを含めた メタキャラクタは、別個のワードを形成しません。逆引用符 (\|\fB`\fR\|) または二重引用符 (\|\fB"\fR\|) の対で囲まれた場合、\fB\e\fR (バックスラッシュ) の付いた復帰改行は 本当の意味での復帰改行文字です。各引用符のその他の機能については、後述の 「変数置換」、「コマンド置換」、「ファイル名置換」 の各項で説明しています。\fB\fR\fB\fR\fB\fR\fB\fR
.sp
.LP
シェルの入力が端末ではない場合、\fB#\fR 文字は、入力行が最後までコメント行であることを表します。\fB\e\fR が前に付いたり、一対の引用符で囲まれると、その特別な意味は抑制されます。
.SS "コマンド行構文解析"
.sp
.LP
単純コマンド (\fIsimple command\fR) は、一連のワードで構成されます。最初のワード (リダイレクションの一部ではない) は、実行するコマンドを指定します。1 つの単純コマンド、または、\fB|\fR や \fB|&\fR 文字で区切られた一連の単純コマンド群は、パイプライン (\fIpipeline\fR) を形成します。\fB|\fR を使用すると、直前のコマンドの標準出力が、それに続くコマンドの標準入力に変更 (リダイレクション) されます。\fB|\|&\fR を使用すると、標準エラー出力および標準出力の両方の出力先が、パイプラインを介してリダイレクションされます。
.sp
.LP
パイプラインはセミコロン (\|\fB;\fR\|) で区切ることができます。この場合、それらは順次実行されます。\fB&&\fR または \fB|\||\fR で区切られたパイプラインは、条件に従って実行されます。つまり左側のパイプラインの実行が成功するか失敗するかによって、右側のパイプラインが実行されるかどうかが決まります。
.sp
.LP
1 つのパイプラインまたはパイプラインの並びを、括弧 `' で囲むことができます。囲まれた全体が単純コマンドとなり、他のパイプラインまたはパイプラインの並びのコンポーネントとなることができます。
.sp
.LP
パイプラインの並びは、`\fB&\fR\&' を付けることによって非同期的にもしくは 「バックグラウンドで」実行できます。この場合シェルは、プロンプトの出力をパイプラインの並びが終了するまで待ちません。ただちにジョブ番号 (後述の「ジョブ制御」を参照) と関連するプロセス ID を表示してから プロンプトを表示します。\fB\fR
.SS "履歴置換"
.sp
.LP
履歴置換を使用すれば、以前入力したコマンド行のワードを、これから入力するコマンド行で使用できます。これにより、綴りの訂正、複雑なコマンドや引数の繰り返し入力が簡単になります。コマンド行は履歴リストに保存されます。履歴リストのサイズは \fBhistory\fR 変数によって変更できます。どのような場合でも、最後に入力されたコマンドは必ず保持されます。履歴置換の指定は \fB!\fR で始まり (\fBhistchars\fR 変数により別の文字に変更可能)、コマンド行のどこに現われてもかまいません。ただし履歴置換のネストはできません。\fB!\fR を \fB\e\fR でエスケープすれば、その特別な意味を抑制できます。
.sp
.LP
履歴置換を含んだ入力行は、展開された後で、他の置換が起こる前またはコマンドが実行される前に、端末上に表示されます。
.SS "イベント指示子"
.sp
.LP
イベント指示子は、履歴リスト内の コマンド行エントリを参照するものです。
.sp
.ne 2
.mk
.na
\fB\fB!\fR\fR
.ad
.sp .6
.RS 4n
次の文字がスペース文字、タブ、復帰改行、\fB=\fR、または \fB(\fR でなければ、履歴置換を開始します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!!\fR\fR
.ad
.sp .6
.RS 4n
直前のコマンドを指します。他の文字を加えずにこれだけを入力すると、直前のコマンドを繰り返します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!\fR\fIn\fR\fR
.ad
.sp .6
.RS 4n
\fIn\fR 番のコマンド行を指します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!\fR\fB-n\fR\fR
.ad
.sp .6
.RS 4n
入力中のコマンドから \fIn\fR 個前のコマンドを指します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!\fR\fIstr\fR\fR
.ad
.sp .6
.RS 4n
\fIstr\fR で始まる最新のコマンドを指します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!?\fR\fIstr\fR\fB?\fR\fR
.ad
.sp .6
.RS 4n
\fIstr\fR を含む最新のコマンドを指します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!?\fR\fIstr\fR\fB?\fR \fIadditional\fR\fR
.ad
.sp .6
.RS 4n
\fIstr\fR を含む最新のコマンドを指し、その参照コマンドに \fIadditional\fR を追加します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB!{\fR\fIcommand\fR\fB}\fR \fIadditional\fR\fR
.ad
.sp .6
.RS 4n
\fIcommand\fR で始まる最新のコマンドを指し、その参照コマンドに \fIadditional\fR を追加します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB^\fR\fIprevious_word\fR\fB^\fR\fIreplacement\fR\fB^\fR\fR
.ad
.sp .6
.RS 4n
文字列 \fIprevious_word\fR を文字列 \fIreplacement\fR に置き換えて、直前のコマンド行を繰り返します。これは履歴置換と同等です。
.sp
.in +2
.nf
!:s/\fIprevious_word\fR/\fIreplacement\fR/.
.fi
.in -2
.sp

以前の特定のコマンドを再実行し、さらに同じような置換を行う場合、たとえば 6 番目のコマンドを再実行するには、次のようにします。
.sp
.in +2
.nf
!:6s/\fIprevious_word\fR/\fIreplacement\fR/.
.fi
.in -2
.sp

.RE

.SS "ワード指示子"
.sp
.LP
A `\fB:\fR' ( コロン ) はイベント指示子とワード指示子とを区切ります。ワード指示子が \fB^\fR、\fB$\fR、\fB*\fR、\fB\(mi\fR、または \fB%\fR で始まるときは省略できます。直前のコマンドからワードを選択する場合、イベント指示子の 2 番目の \fB!\fR は省略できます。たとえば、\fB!!:1\fR と \fB!:1\fR は、両方とも直前のコマンドの最初のワードを指します。また、\fB!!$\fR と \fB!$\fR は、両方とも直前のコマンドの最後のワードを指します。ワード指示子には以下のものがあります。
.sp
.ne 2
.mk
.na
\fB\fB#\fR\fR
.ad
.RS 7n
.rt  
今までに入力したすべてのコマンド行
.RE

.sp
.ne 2
.mk
.na
\fB\fB0\fR\fR
.ad
.RS 7n
.rt  
最初に入力したワード (コマンド)
.RE

.sp
.ne 2
.mk
.na
\fB\fIn\fR\fR
.ad
.RS 7n
.rt  
\fIn\fR 番目の引数
.RE

.sp
.ne 2
.mk
.na
\fB\fB^\fR\fR
.ad
.RS 7n
.rt  
最初の引数。\fB1\fR と同じ
.RE

.sp
.ne 2
.mk
.na
\fB\fB$\fR\fR
.ad
.RS 7n
.rt  
最後の引数
.RE

.sp
.ne 2
.mk
.na
\fB\fB%\fR\fR
.ad
.RS 7n
.rt  
最新の \fB?\fR\fIs\fR による検索で一致したワード
.RE

.sp
.ne 2
.mk
.na
\fB\fIx\fR\fB-\fR\fIy\fR\fR
.ad
.RS 7n
.rt  
ワードの範囲。\fB-\fR\fIy\fR は \fB0-\fR\fIy\fR の省略形
.RE

.sp
.ne 2
.mk
.na
\fB\fB*\fR\fR
.ad
.RS 7n
.rt  
すべての引数。イベント中に 1 ワードしか存在しないときは NULL
.RE

.sp
.ne 2
.mk
.na
\fB\fIx\fR\fB*\fR\fR
.ad
.RS 7n
.rt  
\fIx\fR\fB-$\fR\fIの省略形\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fIx\fR\fB-\fR\fR
.ad
.RS 7n
.rt  
\fIx*\fR と同じであるが、ワード \fB$\fR を省略
.RE

.SS "修飾子"
.sp
.LP
オプションのワード指示子の後に、\fB:\fR で始まる修飾子のうちの 1 つを追加できます。
.sp
.ne 2
.mk
.na
\fB\fBh\fR\fR
.ad
.RS 10n
.rt  
パス名の後部分のコンポーネントを除去して、前部分を残します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBr\fR\fR
.ad
.RS 10n
.rt  
`\fB\&.\fR\fIxxx\fR' の形の接尾辞を除去して、ベース名を残します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBe\fR\fR
.ad
.RS 10n
.rt  
接尾辞以外はすべて除去して、拡張部分を残します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBs/\fR\fIl\fR\fB/\fR\fIr\fR\fB/\fR\fR
.ad
.RS 10n
.rt  
\fIl\fR を \fIr\fR で置き換えます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBt\fR\fR
.ad
.RS 10n
.rt  
パス名の前部分のコンポーネントを除去して、後部分を残します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB&\fR\fR
.ad
.RS 10n
.rt  
前の置換を繰り返します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBg\fR\fR
.ad
.RS 10n
.rt  
各ワード内の最初の一致が発生した箇所を、前述のオプションに接頭辞を付けて変更します ( たとえば \fBg&\fR) 。
.RE

.sp
.ne 2
.mk
.na
\fB\fBp\fR\fR
.ad
.RS 10n
.rt  
新しいコマンドを表示するだけで、実行はしません。
.RE

.sp
.ne 2
.mk
.na
\fB\fBq\fR\fR
.ad
.RS 10n
.rt  
置換されたワードをクォートして、それ以上の置換をエスケープします。
.RE

.sp
.ne 2
.mk
.na
\fB\fBx\fR\fR
.ad
.RS 10n
.rt  
\fBq\fR と同じですが、スペース文字、タブ、復帰改行文字 (NEWLINE) ごとにワードに分割します。
.RE

.sp
.LP
\fBg\fR を先頭に付加しないと、\fIl\fR に一致する最初の文字列だけが変更されます。一致する文字列がなければ、エラーとなります。
.sp
.LP
置換部分の左側は正規表現ではなく文字列です。\fB/\fR の箇所には、区切り文字としてどのような文字でも使用できます。区切り文字用の文字はバックスラッシュで囲まれます。右側の \fB&\fR 文字は、左側のテキストで置換されます。\fB&\fR はバックスラッシュでクォートすることができます。\fIl\fR が NULL のとき、直前の文字列における \fIl\fR 、または \fB!? における文脈検索文字列 \fIs\fR を使用します。\fR\fIs \fR. 同様に \fIr\fR の直後に復帰改行がある場合、文脈検索の最右にある \fB?\fR は省略できます。
.sp
.LP
イベントが指定されないと、履歴リファレンスは前のコマンドか、(もしあれば) そのコマンド行上での前の履歴リファレンスを参照します。
.SS "高速置換"
.sp
.ne 2
.mk
.na
\fB\fB^\fR\fIl\fR\fB^\fR\fIr\fR\fB^\fR\fR
.ad
.RS 9n
.rt  
これは履歴置換と同等です。 
.sp
.in +2
.nf
!:s/\fIl\fR/\fIr\fR/.
.fi
.in -2
.sp

.RE

.SS "別名 (エイリアス)"
.sp
.LP
C シェルが持っている別名のリストは、\fBalias\fR および \fBunalias\fR コマンドを使用してユーザーが作成、表示、および変更できます。シェルは、各コマンドの最初のワードが 既存の別名に一致するかどうかをチェックします。一致すれば、そのワードを別名に置き換えて 再度コマンド処理を実行します。履歴置換のメカニズムは、そのコマンドが 前の入力行であったかのように行うことが可能です。これによって履歴置換は (定義中ではバックスラッシュでエスケープされる) 、別名が使用されているとき、実際のコマンド行引数で置き換えることができます。履歴置換が 1 度も呼ばれていなければ、引数は変更されません。
.sp
.LP
別名はネストできます。すなわち、別名の定義の中に別の別名を入れてもかまいません。ネストされた別名は履歴置換が実行される前に展開されます。これは次のようなパイプラインに役立ちます。
.sp
.in +2
.nf
\fBalias lm 'ls -l \e!* | more'\fR
.fi
.in -2
.sp

.sp
.LP
これは呼び出されたときに、\fBls\fR(1) の出力を \fBmore\fR(1) にパイプするものです。
.sp
.LP
最初のワードを除いて、別名を自分自身の定義内、また定義が参照しているほかのどの別名内にも書いてはいけません。このようなループが見つかると、エラーメッセージが表示されます。
.SS "I/O リダイレクション"
.sp
.LP
以下のメタキャラクタは、それに続くワードが、コマンドの標準入力、標準出力、標準エラーのリダイレクション先のファイル名であることを示します。このワードは、コマンドの他の部分とは別個に展開された ファイル名、変数、またはコマンドです。
.sp
.ne 2
.mk
.na
\fB\fB<\fR\fR
.ad
.RS 15n
.rt  
標準入力をリダイレクションします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB<\|<\fR\fI\|word\fR\fR
.ad
.RS 15n
.rt  
標準入力を \fIword\fR と一致する行まで読み取り、それらの行を一時ファイルに格納します。\fIword\fR がエスケープされるかクォートされていなければ、格納された行に対して、変数およびコマンド置換が行われます。そして、一時ファイルを標準入力としてパイプラインが起動されます。\fIword\fR は変数、ファイル名、およびコマンド置換の対象にはなりません。また、各行はシェルによって置換が実行される前に word と比較されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>\fR \fB>!\fR \fB>&\fR \fB>&!\fR\fR
.ad
.RS 15n
.rt  
ファイルへの標準出力をリダイレクションします。ファイルが存在しなければ作成します。存在すれば上書きします。このとき、以前の内容は失われます。
.sp
変数 \fBnoclobber\fR が設定されていれば、既存のファイルを破壊しません。この変数は、\fB!\fR 形式のいずれかが使用されていないかぎり、端末および \fB/dev/null\fR へのリダイレクションも防ぎます。\fB&\fR 形式は、標準出力および標準エラー (診断出力) の両方の出力先を、指定ファイルに変更します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>\|>\fR \fB>\|>&\fR \fB>\|>!\fR \fB>\|>&!\fR\fR
.ad
.RS 27n
.rt  
標準出力へ追加します。\fB>\fR と似ていますが、上書きするのではなくファイルの最後に追加します。\fBnoclobber\fR が設定されていると、\fB!\fR 形式のうちの 1 つを使用しないかぎり、存在しないファイルに対してはエラーになります。\fB&\fR 形式は、標準出力および標準エラーの両方をファイルへ追加します。
.RE

.SS "変数置換"
.sp
.LP
C シェルには一群の変数が備わっており、それぞれは名前と値の対で構成されています。\fI\fR\fI\fR変数には最大 128 個の文字と数字を含めることができます。先頭は文字にします。下線 (\fB_\fR) は文字と見なされます。変数の値は、スペースで区切られた 0 個以上のワードです。シェルが 128 文字以内の変数をサポートしている場合は、変数 \fBSUNW_VARLEN\fR が定義されます。128 文字までの変数名をサポートしていない場合は、以前のバージョンのシェルが使用されており、シェル変数名の長さは最大 20 文字になります。 
.sp
.LP
値を参照するには、変数名の前に `\fB$\fR' を付けます。(以下に述べる) ある種の参照は、値から特定のワードを選択したり、変数に関する別の情報を表示したりするのに使用できます。括弧は、入力行の他の文字から参照を区別するために使用できます。
.sp
.LP
変数置換は、入力行の解析、別名の展開、入出力先のリダイレクションが行われた後に実行されます例外は、入出力先のリダイレクションの変数参照 (リダイレクション中に置換される) および逆引用符で囲まれた文字列 (「コマンド置換」の項を参照) です。
.sp
.LP
\fB$\fR の前に \fB\e\fR を付加すれば、変数の置換を抑制できます。ただし、二重引用符で囲まれた中では常に置換されます。単一引用符に囲まれていれば、変数置換は抑制されます。スペース文字、タブ、または復帰改行が続く場合は、\fB$\fR はエスケープされます。
.sp
.LP
変数を生成、表示、および破壊するためには、\fBset\fR または \fBunset\fR コマンドを使用します。いくつかの変数はシェルによって管理または使用されます。たとえば \fBargv\fR 変数には、シェルの引数リストのイメージが入っています。シェルに使用される変数の多くはトグルです。つまり、シェルはその変数の値を知る必要はなく、単にその変数が設定されているか否かを知っているだけです。
.sp
.LP
数値の値は、数字として ((\fB@\fR) 組み込みコマンドで扱うように) 処理できます。数値処理では、空の値は 0 とみなされます。複数ワードからなる値の 2 番目以降のワードは無視されます。たとえば \fBverbose\fR 変数が何らかの値 (\| 空の値も含む) に設定されていれば、コマンド入力は端末にエコーされます。
.sp
.LP
コマンドおよびファイル名の置換は、変数置換の結果生成されたワードに適用されます。ただし、二重引用符で抑制されている場合、\fBnoglob\fR が設定されている場合 (ファイル名置換の抑制) 、および \fB:q\fR 修飾子で参照がクォートされている場合を除きます。二重引用符の中では、参照が展開され、クォートされた文字列 (の一部) を形成します。つまり、複数ワードからなる値は、スペース文字を埋め込んだ 1 つの文字列に展開されます。\fB:q\fR 修飾子を参照に使用すると、スペースで区切られたワードに展開され、各ワードにはそれ以降のコマンドまたはファイル名の置換を防ぐために、クォートされます。
.sp
.LP
後述する例外を除き、設定されていない変数を参照するとエラーになります。
.sp
.ne 2
.mk
.na
\fB\fB$\fR\fIvar\fR\fR
.ad
.br
.na
\fB\fB${\fR\fIvar\fR\fB}\fR\fR
.ad
.RS 17n
.rt  
\fIvar\fR が示す変数の値から得られる、スペース文字で区切られたワード群に置き換えられます。\fIvar\fR が環境変数の場合、その値が返されます (ただし `\fB:\fR' 修飾子と以下に述べる他の形式は使用できない)。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$\fR\fIvar\fR\fB[\fR\fIindex\fR\fB]\fR\fR
.ad
.br
.na
\fB\fB${\fR\fIvar\fR\fB[\fR\fIindex\fR\fB]}\fR\fR
.ad
.RS 17n
.rt  
\fIvar\fR が示す変数の値から、特定のワードだけを選択します。\fIindex\fR は 1 つの数字、`\fB\(mi\fR\&' で区切られた 2 つの数字、またはアスタリスクで、これに対して変数置換が行われます。ワード群には 1 から始まるインデックス値が付けられています。`\fB*\fR' はすべてのワードを選択します。もし (\fB$argv[\(mi2]\fR のように) 範囲の最初の数字を省略すると、デフォルトとして 1 とみなされます。もし (\fB$argv[1\(mi]\fR のように) 範囲の最後の数字を省略すると、デフォルトとして \fB$#\fR\fIvar\fR (ワード数) とみなされます。第 2 引数が省略されている (または範囲内の) ときは、範囲が空であってもエラーにはなりません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$#\fR\fIname\fR\fR
.ad
.br
.na
\fB\fB${#\fR\fIname\fR\fB}\fR\fR
.ad
.RS 17n
.rt  
変数内のワード数を指定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$0\fR\fR
.ad
.RS 17n
.rt  
setuid シェルスクリプトを除いては コマンドを読み取っているファイル名に置き換わります。ファイルの名前がわからないときはエラーになります。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$\fR\fIn\fR\fR
.ad
.br
.na
\fB\fB${\fR\fIn\fR\fB}\fR\fR
.ad
.RS 17n
.rt  
\fB$argv[\fR\fIn\fR\fB]\fR と同等です。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB$*\fR\fR
.ad
.RS 17n
.rt  
\fB$argv[*]\fR と同等です。
.RE

.sp
.LP
\fB:gh\fR、\fB:gt\fR、および \fB:gr\fR のように、修飾子 \fB:e\fR、\fB:h\fR、\fB:q\fR、\fB:r\fR、\fB:t\fR、および \fB:x\fR が適用できます (「履歴置換」の項を参照) 。\fB\fR\fB\fR中括弧 \fB{\|}\fR を使用するときは、修飾子は中括弧内に書きます。現在のインプリメントでは、このような修飾子を 1 展開あたり 1 つだけ認めています。
.sp
.LP
次の参照は、修飾子 \fB:\fR を使って修飾することはできません。
.sp
.ne 2
.mk
.na
\fB\fB$?\fR\fIvar\fR\fR
.ad
.br
.na
\fB\fB${?\fR\fIvar\fR\fB}\fR\fR
.ad
.RS 11n
.rt  
\fIvar\fR が設定されていれば文字列 1 に、設定されていなければ文字列 0 に置換します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$?0\fR\fR
.ad
.RS 11n
.rt  
現在の入力ファイル名がわかっているときは文字列 1 に、わかっていなければ文字列 0 に置換します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$$\fR\fR
.ad
.RS 11n
.rt  
(親) シェルのプロセス番号に置換します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$<\fR\fR
.ad
.RS 11n
.rt  
標準入力から得る行の内容に置換し、それ以降は何も解釈しません。キーボードからの入力を C シェルスクリプトで 読み取るときに使用できます。
.RE

.SS "コマンドおよびファイル名置換"
.sp
.LP
コマンドおよびファイル名置換は、組み込みコマンドの引数に選択的に適用されます。評価されていない表現は、展開されません。非組み込みコマンドについては、コマンド名のファイル名展開と、引数リストのファイル名展開は別々に実行されます。展開は、入出力先のリダイレクションが終わった後、サブシェル内で行われます。
.SS "コマンド行置換"
.sp
.LP
逆引用符で囲まれた (\|\fB`\fR\|. \|.\|.\|\fB`\fR\|) コマンドはサブシェルによって実行されます。その標準出力はスペース文字、タブ、復帰改行の箇所でワードに分解されます。空のワードは捨てられます。この分解されたテキストは、現在のコマンド行上の逆引用符で囲まれた文字列を置き換えます。二重引用符で囲まれると、復帰改行文字の箇所だけでワードに分解され、スペース文字、タブはそのまま保存されます。ただし、最後の復帰改行は無視されます。したがって、コマンド置換がワードの一部を生成することも可能です。
.SS "ファイル名置換"
.sp
.LP
\fB*\fR、\fB?\fR、\fB[\fR、または \fB{\fR のうちのいずれかの文字を含むクォートされていないワード、または ~ で始まるワードは、以下のようにアルファベット順に ソートされたファイル名のリストに展開 (グロビングとも呼ばれる) されます。\fI\fR
.sp
.ne 2
.mk
.na
\fB*\fR
.ad
.RS 25n
.rt  
(0 個以上の) どの文字とも一致します。
.RE

.sp
.ne 2
.mk
.na
\fB?\fR
.ad
.RS 25n
.rt  
どの単一文字とも一致します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB[\fR.\|.\|.\fB]\fR\fR
.ad
.RS 25n
.rt  
括弧内の文字リストまたは範囲内のどの単一文字とも一致します。リストは文字列です。範囲とは、ダッシュ (\fB\(mi\fR) で区切られた 2 つの文字を指し、\fBASCII\fR の順で (\fBascii\fR(5) を参照) その文字間にあるすべての文字も含みます。
.RE

.sp
.ne 2
.mk
.na
\fB{ \fIstr\fR\fB,\fR \fIstr\fR\fB,\fR .\|.\|. \fB}\fR\fR
.ad
.RS 25n
.rt  
コンマで区切られたリスト内の各文字列 (またはファイル名マッチングパターン) に展開します。この場合、前述のパターンマッチング表現とは違って、この構造の展開はソートされません。たとえば \fB{b,a}\fR は、`\fBa\fR' `\fBb\fR' ではなく、`\fBb\fR' `\fBa\fR' に展開されます。特別な例として、文字 \fB{\fR および \fB}\fR は、文字列 \fB{\|}\fR と共に、展開されずに引き渡されます。
.RE

.sp
.ne 2
.mk
.na
\fB~[\fIuser\fR]\fR
.ad
.RS 25n
.rt  
変数 \fBhome\fR の値によって示されるホームディレクトリ、または \fIuser\fR のパスワードエントリによって示される \fIuser\fR のホームディレクトリを意味します。
.RE

.sp
.LP
\fB*\fR、\fB?\fR、および \fB[\fR. \|.\|.\fB]\fR だけがパターンマッチングを意味します。パターンに一致するファイル名が存在しないときはエラーになります。`\fB\&.\fR'(ドット文字) は、それがファイル名またはパス名のコンポーネントの最初の文字である場合、明示的に一致しなければなりません。\fB/\fR (スラッシュ) も同様に明示的に一致させる必要があります。
.SS "式と演算子"
.sp
.LP
多くの C シェルの組み込みコマンドは、式を受け入れます。この式の演算子は C の演算子と類似していて、その優先度も C での優先度と同じです。通常これらの式は \fB@\fR、\fBexit\fR、\fBif\fR、\fBset\fR、および \fBwhile\fR コマンド内に現われ、コマンド実行用のフロー制御の規定に使用します。式のコンポーネントはスペースで区切られます。
.sp
.LP
式の値が NULL または値がないと \fB0\fR とみなされます。式の結果はすべて文字列で、10 進数データも文字列で表現します。
.sp
.LP
C シェルの演算子を、以下に優先度の高いものから順にグループ分けして示します。
.sp
.ne 2
.mk
.na
\fB\fB(\|\fR.\|.\|.\|\fB\|)\fR\fR
.ad
.RS 19n
.rt  
グループ化
.RE

.sp
.ne 2
.mk
.na
\fB>\fB~\fR\fR
.ad
.RS 19n
.rt  
 1 の補数
.RE

.sp
.ne 2
.mk
.na
\fB\fB!\fR\fR
.ad
.RS 19n
.rt  
論理否定
.RE

.sp
.ne 2
.mk
.na
\fB\fB* / %\fR\fR
.ad
.RS 19n
.rt  
乗算、除算、剰余 (これらは右結合なので、予想した結果が得られない場合があります。その場合、括弧を使って明示的にグループ化してください) 。
.RE

.sp
.ne 2
.mk
.na
\fB\fB+   -\fR\fR
.ad
.RS 19n
.rt  
加算、減算 (これらも右結合)
.RE

.sp
.ne 2
.mk
.na
\fB\fB<< >>\fR\fR
.ad
.RS 19n
.rt  
ビット単位の左シフト、右シフト
.RE

.sp
.ne 2
.mk
.na
\fB\fB< > <= >=\fR\fR
.ad
.RS 19n
.rt  
より小さい、より大きい、以下、以上
.RE

.sp
.ne 2
.mk
.na
\fB\fB=\|= != =~ !~\fR\fR
.ad
.RS 19n
.rt  
等しい、等しくない、ファイル名置換パターン一致 (下記参照) 、ファイル名置換パターン不一致
.RE

.sp
.ne 2
.mk
.na
\fB\fB&\fR\fR
.ad
.RS 19n
.rt  
ビット単位の AND (論理積)
.RE

.sp
.ne 2
.mk
.na
\fB\fB^\fR\fR
.ad
.RS 19n
.rt  
ビット単位の XOR (排他論理和)
.RE

.sp
.ne 2
.mk
.na
\fB\fB|\fR\fR
.ad
.RS 19n
.rt  
ビット単位の OR (包括論理和)
.RE

.sp
.ne 2
.mk
.na
\fB\fB&&\fR\fR
.ad
.RS 19n
.rt  
AND (論理積)
.RE

.sp
.ne 2
.mk
.na
\fB\fB|\|\||\fR\fR
.ad
.RS 19n
.rt  
OR (論理和)
.RE

.sp
.LP
演算子 \fB==\fR、\fB!=\fR、\fB=~\fR、および \fB!~\fR は、引数を文字列として比較します。他の演算子は数字を使用します。演算子 \fB=~\fR および \fB!~\fR は、それぞれ左側の文字列が 右側のファイル名置換パターンと一致するか否かをチェックします。これを使えば、文字列間のパターンマッチングだけ実行したいとき、\fBswitch\fR 文を使用する必要がなくなります。
.sp
.LP
以下に示すようなファイルに関する照会も可能です。
.sp
.ne 2
.mk
.na
\fB\fB-r\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
ユーザーが読み取り権を持っていれば真すなわち 1 を、そうでなければ偽すなわち 0 を返します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
ユーザーが書き込み権を持っていれば、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
ユーザーが実行権 (またはディレクトリの検索権) を持っていれば、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
\fIfilename\fR が存在していれば、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
ユーザーが \fIfilename\fR を所有していれば、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-z\fR\fI filename\fR\fR
.ad
.RS 15n
.rt  
\fIfilename\fR のサイズが 0 のとき、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
\fIfilename\fR がプレーンファイルなら、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-d\fR \fIfilename\fR\fR
.ad
.RS 15n
.rt  
\fIfilename\fR がディレクトリなら、真です。
.RE

.sp
.LP
\fIfilename\fR が存在しない、またはアクセスできない場合、すべての照会に対して偽を返します。
.sp
.LP
コマンドが成功したか否かの照会もできます。
.sp
.ne 2
.mk
.na
\fB\fB{\fR \fIcommand\fR \fB}\fR\fR
.ad
.RS 15n
.rt  
\fIcommand\fR が正常に動作していれば、この式は真すなわち 1 として、そうでなければ偽すなわち 0 として評価されます。\fB注:\fR 逆に、\fIcommand\fR 自体は正常に動作していれば通常 0 を、問題が発生すれば別の値を返します。ステータスを直接知りたければ、この式ではなく \fBstatus\fR 変数の値を使用します。
.RE

.SS "制御フロー"
.sp
.LP
シェルはスクリプト内の制御フロー、および制限付きで端末からの制御フローを規定する 多くのコマンドを持っています。これらのコマンドはシェルに入力を再度読み込ませるか (ループさせる)、ある条件下で入力をスキップさせる (分岐させる) ことによって動作します。\fI\fR\fI\fR
.sp
.LP
\fBforeach\fR、\fBswitch\fR、\fBwhile\fR、\fBif\fR . \|.\|.\fBthen\fR、および \fBelse\fR の各組み込みコマンドは、入力行の最初のワードとして記述しなければなりません。
.sp
.LP
もし、シェルの入力が見つからないのにループが読み込まれているときは、その入力はバッファリングされます。シェルは、ループによって示される再読み込みを実行するために、内部バッファを検索します (この範囲において、逆方向の \fBgoto\fR コマンドは、入力が見つからない場合でも成功します)。
.SS "コマンドの実行"
.sp
.LP
コマンドが C シェルの組み込みコマンドの場合、シェルはそれを直接実行します。そうでない場合、シェルはその名前で実行可能なファイルを検索します。コマンド名が \fB/\fR を含んでいる場合、シェルはそれをパス名とみなし検索します。コマンド名が \fB/\fR を含んでいない場合、変数 \fBpath\fR 内の各ディレクトリ内でコマンドを検索することによって、パス名として扱えるようにします。シェルは、検索を高速にするためにハッシュテーブルを使用して (\fBrehash\fR 組み込みコマンドの説明を参照)、該当するファイルが存在しないディレクトリを除外します。このハッシングは \fB-c\fR または \fB-t\fR オプション、または \fBunhash\fR 組み込みコマンドによって使用不能にできます。
.sp
.LP
特別な例として、スクリプト名に \fB/\fR が含まれず、ワード \fBshell\fR の別名が存在するときは、それの式をコマンド行に (何も変更を加えずに) 付加します。\fB\fRシステムは、この特別な別名の最初のワードを実行します。このワードは、完全なパス名でなければなりません。別名定義中の残りのワードは、入力行のテキストと共に引数として扱われます。
.sp
.LP
適切な実行権を持つパス名が見つかると、シェルは新しいプロセスをフォークし、\fBexecve\fR(\|) システムコール (\fBexec\fR(2) を参照) を使用して、そのパス名を引数と共にカーネルに引き渡します。 カーネルは、希望するプログラムで新しいプロセスをオーバレイします。ファイルが実行可能なバイナリ (\fBa.out\fR(4) 形式) なら、カーネルは新しいプロセスを引き継ぎ、実行を開始します。ファイルがテキストファイルで、先頭行が \fB#!\fR で始まる場合、次のワードが、そのスクリプトを解釈するためのシェル (またはコマンド) のパス名とみなされます。先頭行の後続のワードは、そのシェルのオプションとみなされます。カーネルは、引数としてそのスクリプト名を使用し、指定されたシェルを起動 (オーバレイ) します。
.sp
.LP
前述のいずれの条件にもあてはまらない場合は、カーネルはそのファイルをオーバレイできず、\fBexecve\fR(\|) コールは失敗します (\fBexec\fR(2) を参照)。C シェルは、以下に述べるように新しいシェルを起動して、そのファイルを実行しようとします。
.RS +4
.TP
.ie t \(bu
.el o
ファイルの先頭文字が \fB#\fR の場合、C シェルを起動
.RE
.RS +4
.TP
.ie t \(bu
.el o
それ以外の場合は Bourne シェルを起動
.RE
.SS "シグナル方式"
.sp
.LP
シェルは通常 \fBQUIT\fR シグナルを無視します。バックグラウンドジョブは、ハングアップ (\fBHUP\fR) などキーボードから生成されたシグナルを感知しません。他のシグナルは C シェルがその環境から引き継いだ値を持っています。シェルのスクリプト内における割り込みおよび終了シグナルの処理は、組み込みコマンド \fBonintr\fR で制御できます。\fBTERM\fR (終了) シグナルは、ログインシェルが受け取るか、あるいは子プロセスへ引き渡されます。ログインシェルが \fB\&.logout\fR ファイルを読み込んでいる間は、いかなる場合でも割り込みは許されません。
.SS "ジョブ制御"
.sp
.LP
シェルは、番号の付いたジョブを各コマンドの並びと関連付けて、バックグラウンドで動作中のコマンド、または \fBTSTP\fR シグナル (通常は CTRL-Z) によって停止したコマンドの動作を追跡します。\fI\fRコマンドまたはコマンドの並び (セミコロンで区切られたリスト) をメタキャラクタ \fB&\fR を使用してバックグラウンドで起動した場合、シェルは角括弧で囲まれたジョブ番号が付いた行、および関連するプロセス番号のリストを表示します。 
.sp
.in +2
.nf
[1] 1234
.fi
.in -2
.sp

.sp
.LP
現在のジョブリストを見るには、組み込みコマンド \fBjobs\fR を使用します。最後に停止したジョブ (停止したジョブがない場合は、最後にバックグラウンドに投入されたジョブ) を「現在のジョブ」といい、`\fB+\fR' で示します。\fI\fR前のジョブは `\fB-\fR\&' で示します。現在のジョブが終了したり、フォアグラウンドに移された場合、前のジョブが新たな現在のジョブになります。
.sp
.LP
ジョブを操作するには、組み込みコマンド \fBbg\fR、\fBfg\fR、\fBkill\fR、\fBstop\fR、および \fB%\fR を使用します
.sp
.LP
ジョブの参照は `\fB%\fR' で始まります。パーセント記号だけの指定は、現在のジョブを示します。
.sp
.ne 2
.mk
.na
\fB\fB%\fR \fB%+\fR \fB%%\fR\fR
.ad
.RS 12n
.rt  
現在のジョブ
.RE

.sp
.ne 2
.mk
.na
\fB\fB%-\fR\fR
.ad
.RS 12n
.rt  
前のジョブ
.RE

.sp
.ne 2
.mk
.na
\fB\fB%\fR\fIj\fR\fR
.ad
.RS 12n
.rt  
次のようにしてジョブ \fIj\fR を参照します。 `\fBkill \fR\fB-9\fR\fB %\fR\fIj\fR'。ここで、\fIj\fR はジョブ番号、またはジョブを起動した コマンド行を一意に表す文字列です。たとえば `\fBfg %vi\fR' は、停止した \fBvi\fR ジョブをフォアグラウンドに移します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%?\fR\fIstring\fR\fR
.ad
.RS 12n
.rt  
コマンド行が \fIstring\fR を含んでいるジョブ
.RE

.sp
.LP
バックグラウンドで動作中のジョブは、端末からの読み取り時に停止します。バックグラウンドジョブは、通常出力を生成しますが、`\fBstty tostop\fR' コマンドを使用して抑制することも可能です。
.SS "ステータスレポート"
.sp
.LP
対話型で動作している場合、シェルは各ジョブのステータスを追跡し、ジョブが終了したり停止したりするとレポートを出力します。通常、入力表示を乱さないように、プロンプト出力時にメッセージを表示します。変数 \fBnotify\fR が設定されているときは、シェルはステータスの変更を即座に報告します。デフォルトでは、\fBnotify\fR コマンドは現在のプロセスをマークします。バックグラウンドのジョブの起動後に \fBnotify\fR と入力すれば、そのジョブをマークできます。
.SS "コマンド (Commands)"
.sp
.LP
組み込みコマンドは C シェル内で実行されます。組み込みコマンドが、パイプラインの いずれかのコンポーネント (最後のコンポーネントを除く) として現われると、それはサブシェル内で実行されます。
.sp
.ne 2
.mk
.na
\fB\fB:\fR\fR
.ad
.RS 26n
.rt  
NULL コマンド。このコマンドは解釈されますが、実行はされません。
.RE

.sp
.ne 2
.mk
.na
\fB\fBalias\fR [ \fIname\fR [ \fIdef\fR ] ]\fR
.ad
.RS 26n
.rt  
別名 \fIname\fR に \fIdef\fR を割り当てます。\fIdef\fR は一群のワードで、エスケープされた履歴置換のメタシンタックスを含めることができます。\fIname\fR に \fBalias\fR または \fBunalias\fR を使用することはできません。\fIdef\fR を省略すると、現在の別名の定義 \fIname\fR が表示されます。\fIname\fR と \fIdef\fR の両方を省略すると、すべての別名と定義が表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBbg\fR [ \fB%\fR\fIjob .\|.\|.\fR ]\fR
.ad
.RS 26n
.rt  
バックグラウンドで、現在のジョブ または指定されたジョブを実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBbreak\fR\fR
.ad
.RS 26n
.rt  
\fBforeach\fR または \fBwhile\fR の最も内側のループの \fBend\fR の次から実行を再開します。現在の行の残りのコマンドが実行されます。これによって、複数レベルのブレークを \fBbreak\fR コマンドのリストとして 1 行にすべて書き込めます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBbreaksw\fR\fR
.ad
.RS 26n
.rt  
\fBswitch\fR からブレークして、\fBendsw\fR の直後から再開します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBcase\fR \fIlabel\fR\fB:\fR\fR
.ad
.RS 26n
.rt  
\fBswitch\fR 文のラベル。
.RE

.sp
.ne 2
.mk
.na
\fB\fBcd\fR [\fIdir\fR]\fR
.ad
.br
.na
\fB\fBchdir\fR [\fIdir\fR ]\fR
.ad
.RS 26n
.rt  
シェルの作業用ディレクトリを \fIdir\fR が示すディレクトリに変更します。引数を指定しないと、そのユーザーのホームディレクトリに変更します。\fIdir\fR が現在のディレクトリには見つからない相対パス名の場合、変数 \fBcdpath\fR 内のディレクトリリストを検索します。\fIdir\fR が \fB/\fR で始まる値を持つシェル変数の名前である場合、その変数の値が示すディレクトリに変更します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBcontinue\fR\fR
.ad
.RS 26n
.rt  
\fBwhile\fR または \fBforeach\fR の最も内側のループの、次の繰り返しから実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBdefault:\fR\fR
.ad
.RS 26n
.rt  
\fBswitch\fR 文のデフォルトケースにラベルを付けます。デフォルトはすべての \fBcase\fR ラベルの後に現れなければなりません。コマンド行の残りのコマンドが、最初に実行されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBdirs\fR [\fB-l\fR]\fR
.ad
.RS 26n
.rt  
ディレクトリスタックを出力します。現在のディレクトリが最も左に現れるように 時間順に出力されます。\fB-l\fR 引数を指定すると、~ を使った省略形ではなく、完全な形式で出力されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBecho\fR [\fB-n\fR] \fIlist\fR\fR
.ad
.RS 26n
.rt  
\fIlist\fR 内のワードをスペース文字で区切って、シェルの標準出力へ書き出します。オプション \fB-n\fR を指定しないと、出力は復帰改行で終了します。\fBecho\fR が UNIX コマンドのフルパス名なしで呼び出された場合、ユーザーの \fBPATH\fR の構成に関係なく、デフォルトでは \fBcsh\fR は、組み込みの \fBecho\fR を実行します (\fBecho\fR(1) を参照)。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBeval\fR \fIargument\fR\fB\|.\|.\|.\fR\fR
.ad
.RS 26n
.rt  
引数をシェルへの入力として読み取り、それをコマンドとして実行します。通常この指定は、コマンドまたは 変数置換の結果として生成されたコマンドを 実行するために使用します。\fBeval\fR の使用例については、\fBtset\fR(1B) を参照してください。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBexec\fR \fIcommand\fR\fR
.ad
.RS 26n
.rt  
現在のシェルの代わりに \fIcommand\fR を実行します。シェルは終了します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBexit\fR [\fB(\fR\fIexpr\fR\fB)\fR]\fR
.ad
.RS 26n
.rt  
呼び出し元のシェルまたは シェルスクリプトが終了し、ステータス変数の値、または式 \fIexpr\fR で指定された値が返されます。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBfg\fR [\fB%\fR\fIjob\fR ]\fR
.ad
.RS 26n
.rt  
現在のジョブ、または指定された \fIjob\fR をフォアグラウンドへ移します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBforeach\fR \fIvar\fR \fB(\fR\fIwordlist\fR\fB)\fR\fR
.ad
.br
.na
\fB\&.\|.\|.\fR
.ad
.br
.na
\fB\fBend\fR\fR
.ad
.RS 26n
.rt  
変数 \fIvar\fR を、\fIwordlist\fR の各メンバーに連続して設定します。\fBvar\fR の値が変わるたびに、\fIforeach\fR と end との間にあるコマンドの並びを実行します。\fBforeach\fR と \fBend\fR は異なる行に、単独で現われなければなりません。
.sp
ループの現在の繰り返しを終了するには、組み込みコマンド \fBcontinue\fR を使用します。またコマンド \fBforeach\fR の実行を終了するには、組み込みコマンド \fBbreak\fR を使用します。このコマンドが端末から読み取られるときは、ループ内の文が実行される前に、\fB?\fR をプロンプトしてから、ループが読み取られます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBglob\fR \fIwordlist\fR\fR
.ad
.sp .6
.RS 4n
\fIwordlist\fR 内のファイル名を展開します。エスケープ \fB\e\fR を認識しない点を除いて、\fBecho\fR と同様です。出力のワードは \fINULL\fR 文字によって区切られます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBgoto\fR \fIlabel\fR\fR
.ad
.sp .6
.RS 4n
指定する \fIlabel\fR は、展開されるとラベルを生成する コマンドとファイル名です。シェルは可能なかぎり入力をさかのぼり、 \fIlabel\fR\fB:\fR という形式の行を探します。 label: の前にはスペース文字またはタブ文字がある可能性もあります。指定された行の次から実行が再開します。\fBwhile\fR または \fBfor\fR 組み込みコマンドと、対応する \fBend\fR との間にあるラベルへジャンプするとエラーになります。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBhashstat\fR\fR
.ad
.sp .6
.RS 4n
\fIpath\fR 変数の内部ハッシュテーブルがコマンドの検索 (実行を伴わない) にどの程度有効に働いて いるかを示す統計情報行を出力します。\fB\fRハッシュ関数がヒットの可能性を示しているパスの各コンポーネントと、`\fB/\fR' で始まらない各コンポーネントについて、実行が試みられます。\fB\fR\fI\fRこの統計は \fIcdpath\fR 変数ではなく \fIpath\fR 変数だけの有効性を示します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBhistory\fR [\fB-hr\fR] [\fIn\fR ]\fR
.ad
.sp .6
.RS 4n
履歴リストを表示します。\fIn\fR を指定すると、\fIn\fR 個の最新のイベントを表示します。 
.sp
.ne 2
.mk
.na
\fB\fB-r\fR\fR
.ad
.RS 6n
.rt  
出力を、古い履歴からではなく最近の履歴から順に並べ変えます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
.rt  
先頭に番号を付加せずに履歴のリストを出力します。これは、\fIsource\fR に対する \fB-h\fR オプションを使用して、ソーシングに適したファイルを作成するのに使用します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBif (\fR\fIexpr\fR \fB)\fR\fIcommand\fR\fR
.ad
.sp .6
.RS 4n
指定された式が真ならば、引数付きの単一の \fIcommand\fR を実行します。\fIcommand\fR 上での変数置換を最初に実行し、同時に \fBif\fR コマンドの残りの部分を実行します。\fIcommand\fR は単純コマンドでなければならず、パイプライン、コマンドリスト、括弧付きコマンドリストは指定できません。\fBなお\fR \fIexpr\fR が偽で \fIcommand\fR が実行されなくても、入出力先のリダイレクションが実行されてしまうので注意してください (これはバグです)。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBif (\fR\fBexpr\fR\fB) then\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBelse if (\fR\fIexpr2\fR\fB) then\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|. \fR
.ad
.br
.na
\fB\fBelse\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBendif\fR\fR
.ad
.sp .6
.RS 4n
\fIexpr\fR が真ならば、最初の \fBelse\fR までのコマンドを実行します。\fIexpr2\fR が真ならば、\fBelse if\fR と 2 番目の \fBelse\fR の間にあるコマンドを実行します。それ以外の場合は、\fBelse\fR と \fBendif\fR の間にあるコマンドを実行します。 \fBelse if\fR の組はいくつでもかまいませんが \fBelse\fR は 1 つしか許されません。\fBendif\fR は 1 つだけ必要で、これは必須です。\fBelse\fR および \fBendif\fR というワードは、各行における空白を除く最初の文字でなければなりません。\fBif\fR は、その行に単独で現われるか、\fBelse\fR の後に現われるかのいずれかです。
.RE

.sp
.ne 2
.mk
.na
\fB\fBjobs\fR [\fB-l\fR]\fR
.ad
.sp .6
.RS 4n
ジョブ制御下で活動中のジョブをリストします。 
.sp
.ne 2
.mk
.na
\fB\fB-l\fR\fR
.ad
.RS 6n
.rt  
通常の情報の他に、プロセス \fBID\fR を表示します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBkill\fR [\fIsig\fR ] [ \fIpid\fR ] [ \fB%\fR\fB\fIjob\fR ] .\|.\|.\fR\fR
.ad
.br
.na
\fB\fBkill\fR \fB-l\fR\fR
.ad
.sp .6
.RS 4n
\fBTERM\fR (終了) シグナル (デフォルトの場合) または指定されたシグナルを、指定されたプロセス ID、指定されたジョブ、または現在のジョブへ送信します。\fI\fR\fI\fRシグナルは番号または名前で指定します。シグナルを送るプロセスまたはジョブにデフォルトはありません。そのため、\fBkill\fR だけを入力しても現在のジョブにはシグナルを送信しません。送信中のシグナルが \fBTERM\fR (終了) または \fBHUP\fR (ハングアップ) の場合、そのジョブまたはプロセスには \fBCONT\fR (継続) シグナルも送られます。 
.sp
.ne 2
.mk
.na
\fB\fB-l\fR\fR
.ad
.RS 6n
.rt  
送信可能なシグナル名の一覧を表示します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBlimit\fR [\fB-h\fR] [\fIresource\fR [\fImax-use\fR ] ]\fR
.ad
.sp .6
.RS 4n
現在のプロセス、またはそれが生成したすべてのプロセスについて、各プロセスが指定された \fIresource\fR を \fImax-use\fR 以上消費しないよう制限します。文字列 \fBunlimited\fR は、現在の制限値 (ある場合) の削除を要求します。\fImax-use\fR を省略すると、現在の制限値を表示します。\fIresource\fR を省略すると、すべての制限値を表示します。システムで利用可能な最大制限値を 調べるには \fBsysdef\fR(1M) コマンドを実行してください。\fBsysdef\fR により報告される値は 16 進数ですが、\fBbc\fR(1) コマンドを使って 10 進数に変換できます。
.sp
.ne 2
.mk
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
.rt  
現在の制限値ではなく強い制限値を使用します。強い制限値は現在の制限値を制限します。強い制限値を上げることができるのは特権ユーザーだけです。
.RE

\fIresource\fR として指定できるものは次のとおりです。
.sp
.ne 2
.mk
.na
\fB\fBcputime\fR\fR
.ad
.sp .6
.RS 4n
プロセス当たりの最大 \fBCPU\fR 使用時間 (秒)
.RE

.sp
.ne 2
.mk
.na
\fB\fBfilesize\fR\fR
.ad
.sp .6
.RS 4n
最大の単一ファイル容量。ファイルシステムのサイズと機能により制限されます。\fBdf\fR(1M) を参照してください。
.RE

.sp
.ne 2
.mk
.na
\fB\fBdatasize\fR (ヒープサイズ) \fR
.ad
.sp .6
.RS 4n
プロセスの (スタックも含めた) 最大データサイズ。システムの仮想記憶サイズ。\fBswap\fR(1M) を参照。
.RE

.sp
.ne 2
.mk
.na
\fB\fBstacksize\fR\fR
.ad
.sp .6
.RS 4n
プロセスの最大スタックサイズ。デフォルトのスタックサイズは 2^64 バイトです。\fBlimit\fR(1) を使用して、シェルのデフォルトのスタックサイズを変更できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBcoredumpsize\fR\fR
.ad
.sp .6
.RS 4n
最大コアダンプのファイルサイズ。ファイルシステムのサイズに制限します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBdescriptors\fR\fR
.ad
.sp .6
.RS 4n
ファイル記述子の最大数。\fBsysdef\fR(1M) を実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBmemorysize\fR\fR
.ad
.sp .6
.RS 4n
仮想記憶の最大サイズ
.RE

\fImax-use\fR は数値で、以下の単位を付加して指定することもできます。
.sp
.ne 2
.mk
.na
\fB\fIn\fR\fBh\fR\fR
.ad
.RS 9n
.rt  
(\fBcputime\fR の) 時間
.RE

.sp
.ne 2
.mk
.na
\fB\fIn\fR\fBk\fR\fR
.ad
.RS 9n
.rt  
\fIn\fR キロバイト。これは \fBcputime\fR を除くすべての値のデフォルト単位です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn\fR\fBm\fR\fR
.ad
.RS 9n
.rt  
\fIn\fRメガバイトまたは (\fBcputime\fR の) 分
.RE

.sp
.ne 2
.mk
.na
\fB\fImm\fR\fB:\fR\fIss\fR\fR
.ad
.RS 9n
.rt  
(\fBcputime\fR の) 分と秒
.RE

たとえば、 \fB0\fR メガバイトに コアファイルダンプのサイズを 制限するには次のように入力します。
.sp
.in +2
.nf
\fBlimit coredumpsize 0M\fR
.fi
.in -2
.sp

.RE

.sp
.ne 2
.mk
.na
\fB\fBlogin\fR [\fIusername\fR\|| \fB-p\fR ]\fR
.ad
.sp .6
.RS 4n
ログインシェルを終了して \fBlogin\fR(1) を起動します。\fB\&.logout\fR ファイルは処理しません。\fIusername\fR を省略すると、\fBlogin\fR がユーザー名をプロンプトしてきます。 
.sp
.ne 2
.mk
.na
\fB\fB-p\fR\fR
.ad
.RS 6n
.rt  
現在の環境変数を保存します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBlogout\fR\fR
.ad
.sp .6
.RS 4n
ログインシェルを終了します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBnice\fR [\fB+\fR\fIn\fR \||\fB-\fR\fIn\fR ] [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
シェルまたは \fIcommand\fR のプロセス優先度の値を \fIn\fR だけ増減させます。優先度の値が大きいほど、プロセスの優先度は低くなり、実行速度は遅くなります。\fIcommand\fR を指定すると、そのコマンドは常にサブシェルで実行され、指定された値は 1 つの \fBif\fR コマンドの範囲内でのみ有効です。\fIcommand\fR を省略すると、\fBnice\fR は現在のシェルの値を増やします。増やす値を省略すると、\fBnice\fR はプロセス優先度の値を 4 に設定します。プロセス優先度の値の範囲は、\(mi20 から 20 までです。\fIn\fR の値がこの範囲外の場合、最低値または最高値に設定されます。 
.sp
.ne 2
.mk
.na
\fB\fB+\fR\fIn\fR\fR
.ad
.RS 6n
.rt  
プロセス優先度の値を \fIn\fR だけ増やします。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-\fR\fIn\fR\fR
.ad
.RS 6n
.rt  
\fIn\fR だけ減らします。この引数は特権ユーザーだけが使用できます。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBnohup\fR [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
\fBHUP\fR を無視して \fIcommand\fR を実行します。command 引数を省略すると、その後のスクリプト全体において \fBHUP\fR を無視します。\fIcommand\fR を指定すると、そのコマンドは常にサブシェル内で実行されます。このとき、単純な \fBif\fR 文中のコマンドに対する制限事項が適用されます。\fB&\fR を使って切り離したすべてのプロセスに対し、このコマンドが有効になります。\fB\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBnotify\fR [\fB%\fR\fIjob\fR] .\|.\|.\fR
.ad
.sp .6
.RS 4n
現在のジョブまたは指定されたジョブのステータスが変わったとき、非同期的にユーザーに知らせます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBonintr\fR [ \fB-\fR | \fIlabel\fR]\fR
.ad
.sp .6
.RS 4n
割り込み時のシェルの動作を制御します。引数を指定しないと、\fBonintr\fR はデフォルトの動作を復元します (すなわち、シェルはシェルスクリプトを終了して、端末のコマンド入力レベルに戻ります)。\fB-\fR 引数を指定すると、シェルはすべての割り込みを無視します。\fIlabel\fR 引数を指定すると、割り込みを受信するか 割り込みのために子プロセスが終了したときに、シェルは \fBgoto\fR\fI label\fR を実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBpopd\fR [\fB+\fR\fIn\fR ]\fR
.ad
.sp .6
.RS 4n
ディレクトリスタックをポップして、新しいトップディレクトリへ \fBcd\fR します。ディレクトリスタックの構成要素は、トップディレクトリを 0 として番号付けられます。 
.sp
.ne 2
.mk
.na
\fB\fB+\fR\fIn\fR\fR
.ad
.RS 6n
.rt  
スタック内の \fIn\fR 番目のエントリを破棄します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBpushd\fR [\fB+\fR\fIn\fR |\fIdir\fR]\fR
.ad
.sp .6
.RS 4n
ディレクトリスタックにディレクトリをプッシュします。引数を指定しないと、トップの 2 つの構成要素を交換します。 
.sp
.ne 2
.mk
.na
\fB\fB+\fR\fIn\fR\fR
.ad
.RS 7n
.rt  
\fIn\fR 番目のエントリとトップスタックを交換しそれに \fBcd\fR します。
.RE

.sp
.ne 2
.mk
.na
\fB\fIdir\fR\fR
.ad
.RS 7n
.rt  
現在の作業用ディレクトリをスタックにプッシュし、\fIdir\fR を新たな作業用ディレクトリとします。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBrehash\fR\fR
.ad
.sp .6
.RS 4n
新しく追加されたコマンドに合わせて、\fIpath\fR 変数内にリストされたディレクトリの内容の 内部ハッシュテーブルを再計算します。新しく追加されたディレクトリに合わせて、\fIcdpath\fR 変数内にリストされたディレクトリの内容の 内部ハッシュテーブルを再計算します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBrepeat\fR \fIcount command\fR\fR
.ad
.sp .6
.RS 4n
\fIcommand\fR を count 回繰り返します。\fIcommand\fR は 1 行の \fBif\fR 文と同様の制限に従います。
.RE

.sp
.ne 2
.mk
.na
\fB\fBset\fR [\fIvar\fR [\fB=\fR \fIvalue\fR ] ]\fR
.ad
.br
.na
\fB\fBset\fR \fIvar\fR\fB[\fR\fIn\fR\fB] =\fR \fIword\fR\fR
.ad
.sp .6
.RS 4n
引数を設定しないと \fBset\fR はすべてのシェル変数の値を表示します。複数ワードからなる値は括弧でくくられて表示されます。引数 \fIvar\fR のみを設定すると、\fBset\fR は空の (NULL) 値を \fIvar\fR が示す変数に割り当てます。引数を \fIvar\fR \fB=\fR \fIvalue\fR の形式で設定すると、\fBset\fR は \fIvar\fR が示す変数に \fIvalue\fR が示す値を割り当てます。\fIvalue\fR は次のいずれかです。   
.sp
.ne 2
.mk
.na
\fB\fIword\fR\fR
.ad
.RS 14n
.rt  
単一ワード (もしくは引用符付きの文字列)
.RE

.sp
.ne 2
.mk
.na
\fB\fB(\fR\fIwordlist\fR\fB)\fR\fR
.ad
.RS 14n
.rt  
スペースで区切られた、括弧付きワードの並び
.RE

値は、割り当てられる前に、コマンドおよびファイル名展開されます。\fBset\fR\fI var\fR\fB[\fR\fIn\fR\fB] =\fR\fI word\fR 形式は、複数ワードからなる値の \fIn\fR 番目のワードを \fIword\fR に置き換えます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBsetenv\fR [\fIVAR\fR [\fIword\fR ] ]\fR
.ad
.sp .6
.RS 4n
引数を設定しないと \fBsetenv\fR はすべての環境変数を表示します。引数 \fIVAR\fR を指定すると、\fBsetenv\fR は環境変数 \fB\fR\fIVAR\fR\fB \fR に空の値 (NULL) を設定します。 (慣習上、環境変数名は大文字で指定されるのが通常)。\fIVAR\fR と \fIword\fR の両引数を指定すると、\fBsetenv\fR は、環境変数 \fBNAME\fR に単一ワードまたはクォートされた文字列である値 \fIword\fR を設定します。最もよく使用される環境変数 \fBUSER\fR、\fBTERM\fR 、\fBPATH\fR は、自動的に \fBcsh\fR変数 \fBuser\fR、\fBterm\fR、\fBpath\fRから (へ) インポート (エクスポート) されます。したがって、これらの変数に \fBsetenv\fR を使用する必要はありません。さらにシェルは、\fBcsh\fR 変数 \fBcwd\fR が変更されるたびに、その値を 環境変数 \fBPWD\fR へ設定します。
.sp
環境変数 \fBLC_CTYPE\fR、\fBLC_MESSAGES\fR、\fBLC_TIME\fR、\fBLC_COLLATE\fR、\fBLC_NUMERIC\fR、\fBLC_MONETARY\fR は、C シェル内で変更されると新しい値が即座に有効になります。
.sp
\fBLC_*\fR 変数 (\fBLC_CTYPE\fR、 \fBLC_MESSAGES\fR、 \fBLC_TIME\fR、 \fBLC_COLLATE\fR、 \fBLC_NUMERIC\fR、\fBLC_MONETARY\fR) のいずれも環境に設定されていなければ (\fBenviron\fR(5) を参照) 、それぞれ対応するロケールのカテゴリにおける \fBcsh\fR の動作は、環境変数 \fBLANG\fR によって決定されます。 もし、\fBLC_ALL\fR が設定されていれば、その内容が \fBLANG\fR 変数やその他の \fBLC_*\fR 変数より優先されます。上記の変数が環境にまったく設定されていなければ、C ロケール (米国スタイル) が \fBcsh\fR の動作を決定します。
.sp
.ne 2
.mk
.na
\fB\fBLC_CTYPE\fR\fR
.ad
.RS 15n
.rt  
\fBcsh\fR の文字の処理方法を決定します。\fBLC_CTYPE\fR に有効な値が設定されていると、\fBcsh\fR は、そのロケールにあった文字を含む テキストやファイル名を表示および処理できます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBLC_MESSAGES\fR\fR
.ad
.RS 15n
.rt  
診断メッセージや情報メッセージの表示方法を決定します。また、メッセージの言語とスタイル、そして肯定応答および否定応答の正しい形も決定します。C ロケールでは、メッセージはプログラム自身が使用しているデフォルトの形 (通常、米語) で表示されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBLC_NUMERIC\fR\fR
.ad
.RS 15n
.rt  
基数文字、小数点 (C ロケールでは (\fB\&.\fR))、および 3 桁ごとのセパレータ、空文字列 (C ロケールでは (\fB""\fR)) の値を決定します。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBshift\fR [\fIvariable\fR ]\fR
.ad
.sp .6
.RS 4n
\fBargv\fR のコンポーネント (または \fIvariable\fR が指定されればその変数のコンポーネント) を、 左へずらして最初のコンポーネントを切り捨てます。未設定の変数および NULL 値に対してはエラーとなります。
.RE

.sp
.ne 2
.mk
.na
\fB\fBsource\fR [\fB-h\fR] \fIname\fR\fR
.ad
.sp .6
.RS 4n
\fIname\fR からコマンドを読み取ります。\fBsource\fR コマンドはネストできますが、あまり深くネストするとシェルのファイル記述子が不足する可能性があります。ソースファイル中のエラーは、それがいかなるレベルであろうと、 入れ子にされたすべての \fBsource\fR コマンドを終了させます。 
.sp
.ne 2
.mk
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
.rt  
\fIname\fR が示す、履歴のリスト上のファイル からコマンドを持ってきますが、実行はしません。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBstop\fR \fB%\fR\fIjobid .\|.\|.\fR\fR
.ad
.sp .6
.RS 4n
現在のジョブまたは 指定されたバックグラウンドジョブを停止します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBstop\fR \fIpid .\|.\|.\fR\fR
.ad
.sp .6
.RS 4n
指定された \fIpid\fR (プロセス ID 番号) の実行を停止します (\fBps\fR(1) を参照)。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBsuspend\fR\fR
.ad
.sp .6
.RS 4n
\fB^Z\fR を使用して停止シグナルが送信されたときと同様に、トラック内でシェルを停止します。このコマンドは、\fBsu\fR コマンドによって開始されたシェルを停止するときによく使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBswitch (\fR\fIstring\fR\fB)\fR\fR
.ad
.br
.na
\fB\fBcase\fR \fIlabel\fR\fB:\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBbreaksw\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|. \fR
.ad
.br
.na
\fB\fBdefault:\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBbreaksw\fR\fR
.ad
.br
.na
\fB\fBendsw\fR\fR
.ad
.sp .6
.RS 4n
各 \fIlabel\fR を、指定された \fIstring\fR (初めにコマンドおよびファイル名展開される) とマッチングします。ファイルメタキャラクタ \fB*\fR、\fB?\fR、および \fB[\fR. \|.\|.\fB ]\fR は、case ラベルとして使用できます。このラベルは変数展開されます。一致するラベルが見つかる前にデフォルトラベルを検出すると、そのデフォルトのラベルの次から実行が開始されます。各 \fBcase\fR 文および \fBdefault\fR 文は、行の先頭になければなりません。コマンド \fBbreaksw\fR は \fBendsw\fR の次から実行を続けます。それ以外は、C の場合と同様に、後続の \fBcase\fR および \fBdefault\fR 文に制御が移ります。一致するラベルが見つからずデフォルトも指定されていない場合、\fBendsw\fR の次から実行されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBtime\fR [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
引数を省略すると、現在の C シェルとその子プロセスが 消費した時間についての情報を出力します。\fIcommand\fR を指定すると、\fIcommand\fR を実行し、その実行時間の情報を出力します。現在 \fBtime\fR 組み込みコマンドは出力の最後 6 フィールドに対する値を計算しません。これらのフィールドに \fB0\fR の値を表示します。 
.sp
.in +2
.nf
example %\fBtime ls\fR \fB-R\fR 
        9.0u 11.0s 3:32 10% 0+0k 0+0io 0pf+0w
.fi
.in -2
.sp

(\fBtime\fR 変数については、下の\fB「環境変数と定義済みシェル変数」\fRを参照)。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBumask\fR [\fIvalue\fR ]\fR
.ad
.sp .6
.RS 4n
ファイル生成マスクを表示します。\fIvalue\fR を指定すると、ファイル生成マスクが設定されます。\fIvalue\fR は 8 進数で指定され、どんなビットもオフにできますが、新たにアクセス権を追加するようなビット をオンにできません。よく使われる値として 077 、002 、または 022 があります。077 は、自分以外の誰に対しても何のアクセス権も 与えません。002 は、グループユーザーに対しては全アクセス権、グループ外ユーザーに対しては読み取り (およびディレクトリ検索) 権を与えます。022 は、グループおよびグループ外ユーザーに対して読み取り (およびディレクトリ検索) 権を与えますが、書き込み権を与えません。
.RE

.sp
.ne 2
.mk
.na
\fB\fBunalias\fR \fIpattern\fR\fR
.ad
.sp .6
.RS 4n
\fIpattern\fR が示すファイル名置換パターン に一致する別名を破棄します。`\fBunalias *\fR' と指定すると、すべての別名が破棄されます。 
.RE

.sp
.ne 2
.mk
.na
\fB\fBunhash\fR\fR
.ad
.sp .6
.RS 4n
\fIpath\fR と \fIcdpath\fR 変数の内部ハッシュテーブルを使用不能にします。
.RE

.sp
.ne 2
.mk
.na
\fB\fBunlimit\fR [\fB-h\fR] [\fIresource\fR ]\fR
.ad
.sp .6
.RS 4n
\fIresource\fR に関する制限を削除します。\fIresource\fR が指定されないと、すべてのリソースの制限が削除されます。リソース名の一覧については、前述の \fBlimit\fR コマンドの説明を参照してください。 
.sp
.ne 2
.mk
.na
\fB\fB-h\fR\fR
.ad
.RS 6n
.rt  
対応する強い制限値を削除します。これは特権ユーザーだけしか実行できません。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBunset\fR \fIpattern\fR\fR
.ad
.sp .6
.RS 4n
\fIpattern\fR が示すファイル名置換パターンに一致する名の変数を削除します。`\fBunset *\fR' と指定すると、すべての変数が削除されます。ただしこれによって、たいへんな副作用を引き起こします。
.RE

.sp
.ne 2
.mk
.na
\fB\fBunsetenv\fR \fIvariable\fR\fR
.ad
.sp .6
.RS 4n
環境から \fIvariable\fR が示す変数を削除します。\fBunset\fR のようなパターンマッチングは行いません。
.RE

.sp
.ne 2
.mk
.na
\fB\fBwait\fR\fR
.ad
.sp .6
.RS 4n
プロンプトする前に、バックグラウンドジョブの終了 (または割り込み) を待ちます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBwhile (\fR\fIexpr\fR\fB)\fR\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fB\fBend\fR\fR
.ad
.sp .6
.RS 4n
\fIexpr\fR が真 (0 以外) であるかぎり、\fBwhile\fR と、対応する \fBend\fR 文の間のコマンドを繰り返します。ループを途中で終了させるには \fBbreak\fR を、または先頭から再開するには \fBcontinue\fR を使用します。\fBwhile\fR と \fBend\fR は入力行に単独で現われなければなりません。シェルの入力が端末の場合、疑問符のプロンプトを表示してコマンドを受け付け、\fBend\fR コマンドが入力されると ループ内でコマンドを実行します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB%\fR [\fIjob\fR ] [\fB&\fR]\fR
.ad
.sp .6
.RS 4n
現在のジョブまたは \fIjob\fR で指定されたジョブをフォアグラウンドへ移します。アンパサンドを付加すると、ジョブをバックグラウンドで実行し続けます。\fI\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB@\fR [\fIvar\fR \fB=\fR\fIexpr\fR]\fR
.ad
.br
.na
\fB\fB@\fR [\fIvar\fR\fB[\fR\fIn\fR\fB]\fR\fB=\fR\fIexpr\fR] \fR
.ad
.sp .6
.RS 4n
引数を指定しないと、すべてのシェル変数の値を表示します。引数を指定すると、\fIvar\fR が示す変数の値、またはその値の \fIn\fR 番目のワードを、\fIexpr\fR が示す式の評価値に設定します。\fI\fR\fB[\fR\fIn\fR\fB]\fR を指定するときは、\fIvar\fR が示す変数およびその \fIn\fR 番目のコンポーネントが既に存在していなければなりません。
.sp
式が文字 \fB>\fR、\fB<\fR、\fB&\fR、または \fB|\fR を含んでいる場合、少なくともその部分は括弧で囲む必要があります。\fI\fR
.sp
演算子 \fB*=\fR や \fB+=\fR などは、C と同様に使用できます。名前と代入演算子とを区切っているスペースは、指定してもしなくてもかまいません。ただし、指定しないと 1 ワードとみなされる式のコンポーネントを区切る場合は、スペースは必須です。\fI\fR
.sp
特別な接尾演算子の \fB+\|+\fR と \fB\(mi\|\(mi\fR は、\fIname\fR をそれぞれ増加・減少させます。
.RE

.SS "環境変数と定義済みシェル変数"
.sp
.LP
C シェルは、起動したプロセスに自動的に値がエクスポートされる環境変数と、そうでないシェル変数を区別します。この点は Bourne シェルとは異なります。両タイプの変数とも変数置換においては同等に扱われます。初期化の際、シェルは、変数 \fBargv\fR、\fBcwd\fR、\fBhome\fR、\fBpath\fR、 \fBprompt\fR、\fBshell\fR、および \fBstatus\fR を設定します。シェルは、環境変数 \fBUSER\fR、\fBTERM\fR、\fBHOME\fRをそれぞれシェル変数 \fBuser\fR、\fBterm\fR、\fBhome\fR へコピーします。そして、前述のシェル変数が再設定されるたびに、対応する環境変数へその値を書き戻します。\fBPATH\fR と \fBpath\fR は同様に扱われます。\fBpath\fR は \fB\&.cshrc\fR または \fB\&.login\fR ファイル内で 1 度設定するだけです。環境変数 \fBPWD\fR は、\fBcwd\fR が変更されるたびに設定されます。以下のシェル変数の意味は (事前に) 以下の通り定義済みです。
.sp
.ne 2
.mk
.na
\fB\fBargv\fR\fR
.ad
.RS 13n
.rt  
引数リスト。シェルの今回の呼び出しの際に渡された コマンド行引数リストを含んでいます。この変数は、\fB$1\fR や \fB$2\fR などの定位置パラメータの値を決定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBcdpath\fR\fR
.ad
.RS 13n
.rt  
\fBcd\fR、\fBchdir\fR、および \fBpopd\fR コマンドが検索するディレクトリのリスト。これらのコマンドが受け取ったディレクトリ引数が 現在のディレクトリのサブディレクトリでないとき、この変数が示すディレクトリ群が検索されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBcwd\fR\fR
.ad
.RS 13n
.rt  
現在のディレクトリの完全なパス名
.RE

.sp
.ne 2
.mk
.na
\fB\fBecho\fR\fR
.ad
.RS 13n
.rt  
実行前に置換後のコマンドをエコーします。
.RE

.sp
.ne 2
.mk
.na
\fB\fBfignore\fR\fR
.ad
.RS 13n
.rt  
ファイル名を補完させるときに無視する ファイル名接尾辞のリスト。典型的な例は `\fB\&.o\fR' の 1 ワードだけ。
.RE

.sp
.ne 2
.mk
.na
\fB\fBfilec\fR\fR
.ad
.RS 13n
.rt  
ファイル名補完を可能にします。その際、CTRL-d 文字の \fBEOT\fR および \fBESC\fR 文字が端末の入力行の最後に入力されると特別な意味を持ちます。 
.sp
.ne 2
.mk
.na
\fB\fBEOT\fR\fR
.ad
.RS 7n
.rt  
前に指定した文字列で始まる ファイル名のリストをすべて出力します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBESC\fR\fR
.ad
.RS 7n
.rt  
前に指定した文字列を 最も長い明確な拡張子に置き換えます。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBhardpaths\fR\fR
.ad
.RS 13n
.rt  
設定すると、ディレクトリスタック内のパス名は、シンボリックリンクのコンポーネントを含まないように展開されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBhistchars\fR\fR
.ad
.RS 13n
.rt  
2 文字の文字列。最初の文字は、履歴置換文字として \fB!\fR を置き換えます。2 番目の文字は、高速置換のためのキャレット (\fB^\fR) を置き換えます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBhistory\fR\fR
.ad
.RS 13n
.rt  
履歴リストに保存される行数。数字が非常に大きいと、C シェルのメモリーすべてを消費してしまいます。設定を行わない場合、C シェルは最新のコマンドだけを保存します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBhome\fR\fR
.ad
.RS 13n
.rt  
ユーザーのホームディレクトリ。ファイル名展開の ~ は、この変数の値を指します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBignoreeof\fR\fR
.ad
.RS 13n
.rt  
設定すると、シェルは端末からの \fBEOF\fR を無視します。これにより、CTRL-D を誤って入力して C シェルを終了させてしまう ことが防げます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBmail\fR\fR
.ad
.RS 13n
.rt  
C シェルがメールの有無をチェックするファイルのリスト。値の最初のワードが数字の場合、メールをチェックする間隔を秒数 (デフォルトは 5 秒) で表します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBnobeep\fR\fR
.ad
.RS 13n
.rt  
あいまいなファイル名を C シェルに拡張させる際、一致したものを見つけたときに発生するビープ音を抑制します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBnoclobber\fR\fR
.ad
.RS 13n
.rt  
既存のファイルが間違って破壊されないように 出力先のリダイレクションを制限します。\fB>\fR は新規のファイルへのみ出力先をリダイレクションできます。\fB>>\fR は既存のファイルへのみ出力先をリダイレクションできます。
.RE

.sp
.ne 2
.mk
.na
\fB\fBnoglob\fR\fR
.ad
.RS 13n
.rt  
ファイル名置換を禁止します。これは、シェルスクリプト内で一度ファイル名 (もしあれば) を取得した後、これ以上拡張したくないときに便利です。
.RE

.sp
.ne 2
.mk
.na
\fB\fBnonomatch\fR\fR
.ad
.RS 13n
.rt  
パターンが一致しなかったとき、エラーではなくファイル名置換パターンを返します。パターンが間違っているときは、エラーを返します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBnotify\fR\fR
.ad
.RS 13n
.rt  
設定すると、シェルはプロンプトの発行まで待つことなく、ジョブの終了を即座に報告します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBpath\fR\fR
.ad
.RS 13n
.rt  
コマンドを検索するディレクトリのリストです。\fBpath\fR は環境変数 \fBPATH\fR から初期化されます。この環境変数は、\fBpath\fR を変更するたびに C シェルによって更新されます。NULL ワードは現在のディレクトリを指定します。デフォルトは通常 \fB(/usr/bin .) です。\fR \fB\&.cshrc\fR ファイルまたは \fB\&.login\fR ファイル (ログインシェルのみ) 内に設定することにより、\fBcsh\fR の起動時にこの初期検索パスを上書きできます。\fBpath\fR が設定されないと、完全なパス名だけが実行されます。対話型の C シェルは、通常 \fB\&.cshrc\fR の読み取り後と \fBpath\fR の再設定時には、必ずリストされたディレクトリの内容をハッシングします。新しいコマンドが追加されたときは、\fBrehash\fR コマンドを使用してテーブルを更新します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBprompt\fR\fR
.ad
.RS 13n
.rt  
対話型 C シェルのプロンプト文字列。非対話型シェルの \fBprompt\fR 変数は未設定のままです。対話型でのみ有効な \fB\&.cshrc\fR ファイル内の別名および他のコマンドは、 `\fBif ($?prompt == 0) exit\fR' という記述の後におくことができ、これによって、非対話型シェルの起動時間が短縮できます。\fBprompt\fR 文字列内の \fB!\fR は、現在のイベント番号で置換されます。デフォルトプロンプトは通常の \fIhostname\fR\fB%\fR または特権ユーザー用の \fIhostname\fR\fB#\fR です。
.sp
\fB$prompt\fR の設定には次の 3 つの意味があります。
.sp
.ne 2
.mk
.na
\fB\fB$prompt\fR が設定されていない\fR
.ad
.sp .6
.RS 4n
非対話型シェル、\fB$?prompt\fR を評価する
.RE

.sp
.ne 2
.mk
.na
\fB\fB$prompt\fR が設定されているが、\fB== ""\fR である\fR
.ad
.sp .6
.RS 4n
\fB\&.cshrc\fR が \fBwhich\fR(1) コマンドによって呼び出されました。
.RE

.sp
.ne 2
.mk
.na
\fB\fB$prompt\fR が設定されており、\fB!= ""\fR である\fR
.ad
.sp .6
.RS 4n
通常の対話型シェル。
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBsavehist\fR\fR
.ad
.RS 13n
.rt  
ユーザーがログアウトしたときに ~/.history に保管される履歴リストの行数。\fB savehist\fR の値が大きすぎると、C シェルの起動処理が遅くなります。
.RE

.sp
.ne 2
.mk
.na
\fB\fBshell\fR\fR
.ad
.RS 13n
.rt  
C シェルが存在するファイル。実行ビットがセットされているが システムにより実行できないようなファイルを解釈するために、シェルをフォークする際に使用します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBstatus\fR\fR
.ad
.RS 13n
.rt  
最新のコマンドによって返されたステータス。そのコマンドが異常終了した場合、ステータスに 0200 が加算されます。異常終了した組み込みコマンドは、終了ステータス 1 を返します。他のすべての組み込みコマンドは、ステータスを 0 に設定します。
.RE

.sp
.ne 2
.mk
.na
\fB\fBtime\fR\fR
.ad
.RS 13n
.rt  
コマンドの自動タイミングを制御します。1 つまたは 2 つの値が与えられます。最初の値は、報告するしきい値の \fBCPU\fR 時間 (秒) です。2 番目の値は、どのリソースについて報告するかを示すタグとテキストの文字列です。タグは、先頭にパーセント記号 (\fB%\fR) を付加した 1 つの英大文字で表します。認識できないタグはテキストとして表示します。 
.sp
.ne 2
.mk
.na
\fB\fB%D\fR\fR
.ad
.RS 6n
.rt  
使用された、共有でないデータ領域の平均サイズ (キロバイト)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%E\fR\fR
.ad
.RS 6n
.rt  
コマンド実行時間
.RE

.sp
.ne 2
.mk
.na
\fB\fB%F\fR\fR
.ad
.RS 6n
.rt  
ページフォルト回数
.RE

.sp
.ne 2
.mk
.na
\fB\fB%I\fR\fR
.ad
.RS 6n
.rt  
ブロック入力操作の数
.RE

.sp
.ne 2
.mk
.na
\fB\fB%K\fR\fR
.ad
.RS 6n
.rt  
使用された、共有でないスタック領域の平均サイズ (キロバイト)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%M\fR\fR
.ad
.RS 6n
.rt  
プロセスの実行中に使用された最大実記憶領域
.RE

.sp
.ne 2
.mk
.na
\fB\fB%O\fR\fR
.ad
.RS 6n
.rt  
ブロック出力操作の数
.RE

.sp
.ne 2
.mk
.na
\fB\fB%P\fR\fR
.ad
.RS 6n
.rt  
エラップス時間 (E) に占める CPU 時間 (ユーザー時間 (U) とシステム時間 (S) の合計) のパーセンテージ
.RE

.sp
.ne 2
.mk
.na
\fB\fB%S\fR\fR
.ad
.RS 6n
.rt  
ユーザープロセス内で、カーネルによって消費された CPU 時間 (秒)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%U\fR\fR
.ad
.RS 6n
.rt  
ユーザープロセスに使用された \fBCPU\fR 時間 (秒)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%W\fR\fR
.ad
.RS 6n
.rt  
スワップの回数
.RE

.sp
.ne 2
.mk
.na
\fB\fB%X\fR\fR
.ad
.RS 6n
.rt  
使用されたの共有メモリ領域の平均サイズ (キロバイト)
.RE

デフォルトの出力は、\fB%U\fR、\fB%S\fR、\fB%E\fR、\fB%P\fR、\fB%X\fR、\fB%D\fR、\fB%I\fR、\fB%O\fR、\fB%F\fR、\fB%W\fR の順です。
.RE

.sp
.ne 2
.mk
.na
\fB\fBverbose\fR\fR
.ad
.RS 13n
.rt  
履歴置換の後で各コマンドを表示します。
.RE

.SS "大規模ファイルの動作"
.sp
.LP
ファイルが 2 ギガバイト (2^31 バイト) 以上ある場合の \fBcsh\fR の動作については、\fBlargefile\fR(5) を参照してください。
.SH ファイル
.sp
.ne 2
.mk
.na
\fB\fB~/.cshrc\fR\fR
.ad
.RS 15n
.rt  
 各シェルの起動時に読み取られる
.RE

.sp
.ne 2
.mk
.na
\fB\fB~/.login\fR\fR
.ad
.RS 15n
.rt  
 ログイン時、ログインシェルによって \fB\&.cshrc\fR の後に読み取られる
.RE

.sp
.ne 2
.mk
.na
\fB\fB~/.logout\fR\fR
.ad
.RS 15n
.rt  
 ログアウト時、ログインシェルによって読み取られる
.RE

.sp
.ne 2
.mk
.na
\fB\fB~/.history\fR\fR
.ad
.RS 15n
.rt  
 次回のログイン時に使用できるよう履歴を保管する
.RE

.sp
.ne 2
.mk
.na
\fB\fB/usr/bin/sh\fR\fR
.ad
.RS 15n
.rt  
`\fB#\fR' で始まらないシェルスクリプト用の Bourne シェル
.RE

.sp
.ne 2
.mk
.na
\fB\fB/tmp/sh*\fR\fR
.ad
.RS 15n
.rt  
`\fB<<\fR\&' 用の一時ファイル
.RE

.sp
.ne 2
.mk
.na
\fB\fB/etc/passwd\fR\fR
.ad
.RS 15n
.rt  
\fI`~name'\fR 用のホームディレクトリを指定したソース
.RE

.SH 属性
.sp
.LP
属性についての詳細は、\fBattributes\fR(5) を参照してください。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件system/core-os
_
CSI有効
.TE

.SH 関連項目
.sp
.LP
\fBbc\fR(1), \fBecho\fR(1), \fBlimit\fR(1), \fBlogin\fR(1), \fBls\fR(1), \fBmore\fR(1), \fBpfcsh\fR(1), \fBpfexec\fR(1), \fBps\fR(1), \fBsh\fR(1), \fBshell_builtins\fR(1), \fBtset\fR(1B), \fBwhich\fR(1), \fBdf\fR(1M), \fBswap\fR(1M), \fBsysdef\fR(1M), \fBaccess\fR(2), \fBexec\fR(2), \fBfork\fR(2), \fBpipe\fR(2), \fBa.out\fR(4), \fBascii\fR(5), \fBattributes\fR(5), \fBenviron\fR(5), \fBlargefile\fR(5), \fBtermio\fR(7I)
.SH 診断
.sp
.ne 2
.mk
.na
\fB\fBYou have stopped jobs.\fR\fR
.ad
.RS 26n
.rt  
ジョブ制御下で停止しているジョブ上で C シェルを終了しようとしました。すぐに再度 C シェルを終了すれば正常に終了しますが、停止しているジョブも終了します。
.RE

.SH 警告
.sp
.LP
シェルスクリプトを \fBsetuid\fR して使用することは避けてください。\fI\fR
.SH 注意事項
.sp
.LP
ワードは 1024 バイト以下でなければなりません。引数リストはシステムによって 1,048,576 バイト以下に制限されています。しかし、ファイル名の展開が適用できるコマンドの引数の最大数は 1706 です。コマンド置換は、引数リストに許されているのと同じ文字数までしか展開できません。ループを検出するために、シェルは別名置換を 1 行あたり 20 に制限しています。\fB\fR
.sp
.LP
コマンドが停止後再開されたとき、最初にコマンドを開始したディレクトリが現在のディレクトリと異なる場合、シェルは現在のディレクトリを表示します。これは、ジョブがディレクトリを内部で変更している可能性があるので、誤解を招きます (すなわち、間違っています)。
.sp
.LP
シェルの組み込み関数を停止または再開することはできません。\fIa\fR \fIb\fR \fIc\fR のような形式のコマンドの並びも、停止が試されるとうまく処理できません。\fIb\fR で一時停止するとシェルは \fIc\fR を実行しません。このことは、別名から展開された場合に特に注意が必要です。この現象は、コマンドの並びを括弧で囲んで サブシェルに実行させると避けられます。
.sp
.LP
ループ内のコマンドは \fB?\fR でプロンプトしてきますが、履歴リストには格納されません。\fI\fR
.sp
.LP
制御構造は組み込みコマンドと みなすより構文解析をするべきです。これによって、制御コマンドはどこにでも置くことができ、\fB|\fR と組み合わせたり、\fB&\fR および \fB;\fR などのメタシンタックスと組み合わせることが できるようになるはずです。
.sp
.LP
コマンド置換の出力に、修飾子 \fB:\fR を使えるようにすべきです。この \fB:\fR 修飾子を変数置換に使用するには 2 つの問題があります。 1 つはすべての修飾子が使用できるわけではないこと、もう 1 つは一度の置換に 1 つの修飾子しか許されないことです。
.sp
.LP
履歴置換内の \fBg\fR (グローバル) フラグは、すべてのワード内のすべての一致箇所ではなく、各ワード内の最初の一致箇所にしか適用されません。通常のテキストエディタは、置換コマンドに \fBg\fR が指定されると、すべての一致箇所の指定とみなすのが一般的です。
.sp
.LP
クォートの規則は複雑です。二重引用符内で変数置換を強要するエスケープ文字を 無効にするということは、混乱を招いて理解しにくくなり、Bourne シェルとの一貫性も保たれません。
.sp
.LP
シェルが、シンボリックリンクを無視してしまうことがあります。\fBhardpaths\fR 変数を設定すればこれを緩和できます。
.sp
.LP
次のような組み込みコマンドを複数回使ってできた重複したパス名は、すべてユーザーが手動で除かなければなりません。
.sp
.in +2
.nf
set path = \fIpathnames\fR
.fi
.in -2
.sp

.sp
.LP
または
.sp
.in +2
.nf
setenv PATH = \fIpathnames\fR
.fi
.in -2
.sp

.sp
.LP
 シェルスクリプトまたは \fB\&.cshrc\fR ファイルが次のようなコマンドを発行したときに、よくパス名が重複します。
.sp
.in +2
.nf
`set path=(/usr/local /usr/hosts $path)'
.fi
.in -2
.sp

.sp
.LP
このコマンドは、指定したディレクトリがパス名リスト内にあることを保証する場合に使用されます。
.sp
.LP
標準出力と標準エラーを分けて出力する唯一の方法は、以下のようにサブシェルを起動することです。
.sp
.in +2
.nf
\fIcommand\fR > \fIoutfile\fR ) >& \fIerrorfile\fR
.fi
.in -2
.sp

.sp
.LP
一般的な使用には十分耐えられますが、C シェルを少し複雑に使うと予期しない結果を招くことがあります。
.sp
.LP
\fBcsh\fR をログインシェルとして起動しても、\fB\&.login\fR がホームディレクトリに存在しない場合は、\fBcsh\fR は \fB/etc/.login\fR を読み取ります。
.sp
.LP
存在しないコマンドのインタプリタを実行しようとするシェルスクリプトを、シェルが処理した場合、シェルはシェルスクリプトが存在しないという間違った診断メッセージを 返します。
.SH 使用上の留意点
.sp
.LP
現在 \fBtime\fR 組み込みコマンドは出力の最後 6 フィールドに対する値を計算しません。これらのフィールドに \fB0\fR の値を表示します。\fB\fR
.sp
.in +2
.nf
example %\fBtime ls -R\fR
        9.0u 11.0s 3:32 10% 0+0k 0+0io 0pf+0w
.fi
.in -2
.sp

