'\" te
.\" Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
.\" Copyright 1992, X/Open Company Limited All Rights Reserved
.\" Copyright 1989 AT&T
.\" Portions Copyright (c) 1982-2007 AT&T Knowledge Ventures
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for permission to reproduce portions of its copyrighted documentation. Original documentation from The Open Group can be obtained online at http://www.opengroup.org/bookstore/.
.\" The Institute of Electrical and Electronics Engineers and The Open Group, have given us permission to reprint portions of their documentation. In the following statement, the phrase "this text" refers to portions of the system documentation. Portions of this text are reprinted and reproduced in electronic form in the Sun OS Reference Manual, from IEEE Std 1003.1, 2004 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between these versions and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html. This notice shall appear on any product containing this material.
.TH test 1 "2011 年 7 月 12 日" "SunOS 5.11" "ユーザーコマンド"
.SH 名前
test \- 条件の評価
.SH 形式
.LP
.nf
\fB/usr/bin/test\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "sh"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "csh"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "ksh88"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SS "ksh"
.LP
.nf
\fBtest\fR [\fIcondition\fR]
.fi

.LP
.nf
\fB[\fR [\fIcondition\fR] ]
.fi

.SH 機能説明
.sp
.LP
\fBtest\fR ユーティリティは、\fIcondition\fR が示す条件を評価し、その結果を終了ステータスで表します。評価結果が真のときは終了ステータスが 0 に、偽のときは 1 になります。
.sp
.LP
test ユーティリティーの第 1 の形式は次のとおりです。
.sp
.in +2
.nf
test [\fIcondition\fR]
.fi
.in -2
.sp

.sp
.LP
角括弧は \fIcondition\fR が省略可能なオペランドであり、必ずしもコマンド行で指定する必要がないことを示します。
.sp
.LP
test ユーティリティーの第 2 の形式は次のとおりです。
.sp
.in +2
.nf
\fB[\fR [ \fIcondition\fR ] \fB]\fR
.fi
.in -2
.sp

.sp
.LP
最初の開く角括弧 (\fB[\fR) は必須のユーティリティ名です。内側の角括弧は \fIcondition\fR がオプションであることを示しています。最後の閉じる角括弧 (\fB]\fR)は必須のオペランドです。
.sp
.LP
2G バイト (2^31 バイト) 以上のファイルに対する \fBtest\fR の動作については、\fBlargefile\fR(5) を参照してください。
.sp
.LP
\fBtest\fR と \fB[\fR ユーティリティーは条件 \fIcondition\fR を評価して、その値が真である場合は終了ステータスを \fB0\fR に設定します。そうでない場合はゼロ以外の値 (偽) に設定します。引数がない場合は、\fBtest\fR と \fB[\fR ユーティリティは終了ステータスをゼロ以外の値に設定します。アクセス権をテストするときは、プロセスの実効ユーザー \fBID\fR が使用されます。
.sp
.LP
test と [ ユーティリティーに指定する引数、つまり、オペレータ、フラグ、および (最後の行を示す) 括弧はすべて、区切り文字で区切る必要があります。通常、これらの引数はスペースで区切られます。
.SH オペランド
.sp
.LP
2 つの要素を持つ、次の形式のプライマリ:
.sp
.in +2
.nf
\fI-primary_operator primary_operand\fR
.fi
.in -2

.sp
.LP
これを、「単項プライマリ」と呼びます。\fB\fR3 つの要素を持つ、次のいずれかの形式のプライマリ:
.sp
.in +2
.nf
\fIprimary_operand -primary_operator primary_operand\fR
\fIprimary_operand primary_operator primary_operand\fR
.fi
.in -2

.sp
.LP
これを、「2 項プライマリ」と呼びます。\fB\fR
.sp
.LP
ファイルオペランド (\fB-h\fR と \fB-L\fR プライマリを除く) がシンボリックリンクを示している場合、シンボリックリンクは展開され、test は展開後のファイルに実行されます。
.sp
.LP
自分のファイルをテストした場合でも (\fB-r\fR、\fB-w\fR、または \fB-x\fR のテスト)、テストしたファイルのアクセス権に所有者ビットが設定されていない場合は、ファイルのアクセス権に「グループ」ビットまたは「その他」のビットが設定されていても、ゼロ以外 (偽) の終了ステータスが返されます。\fI\fR\fB\fR\fB\fR
.sp
.LP
\fB=\fR と \fB!=\fR プライマリは単項プライマリよりも優先されます。\fB=\fR と \fB!=\fR プライマリは常に引数をとります。したがって、\fB=\fR と \fB!=\fR は単項プライマリの引数として使用できません。
.sp
.LP
\fIcondition\fR を記述するために以下の基本式が使用できます。
.sp
.ne 2
.mk
.na
\fB\fB-a\fR \fIfile\fR \fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在すれば真。(\fBsh\fR では使用不可)
.RE

.sp
.ne 2
.mk
.na
\fB\fB-b\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、ブロック型特殊ファイルであれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-c\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、文字型特殊ファイルであれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-d\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、ディレクトリであれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-e\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在すれば真。(\fBsh\fR では使用不可)
.RE

.sp
.ne 2
.mk
.na
\fB\fB-f\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、そのファイルが通常ファイルであれば真。あるいは、\fB/usr/bin/sh\fR ユーザーが自分の \fBPATH\fR 環境変数内で \fB/usr/bin\fR よりも前に \fB/usr/ucb\fR を指定しており、\fBfile\fR が存在し、そのファイルがディレクトリでなければ、\fItest\fR は真を返します。\fB\fR\fBcsh\fR の \fBtest\fR と \fB[\fR ビルトインは常に後者の動作を行います。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-g\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、セットグループ \fBID\fR フラグが設定されていれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-G\fR \fIfile\fR \fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、ファイルのグループがプロセスの実効グループ \fBID\fR と一致していれば真。(\fBsh\fR では使用不可)
.RE

.sp
.ne 2
.mk
.na
\fB\fB-h\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、シンボリックリンクであれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-k\fR \fIfile\fR \fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、スティッキビットが設定されていれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-L\fR \fIfile\fR \fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、シンボリックリンクであれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-n\fR \fIstring\fR\fR
.ad
.RS 28n
.rt  
\fIstring\fR の長さがゼロでなければ真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-o\fR \fIoption\fR \fR
.ad
.RS 28n
.rt  
オプション \fIoption\fR がついていれば真。\fBcsh\fR または \fBsh\fR では、このオプションは使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-O\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、プロセスの実効ユーザー \fBID\fR がそのファイルを所有していれば真。\fBsh\fR では、このオプションは使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-p\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が名前付きパイプ (\fBFIFO\fR) であれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-r\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、読み取り可能であれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-s\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、サイズがゼロより大きければ真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-S\fR \fIfile\fR \fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、そのファイルがソケットであれば真。\fBsh\fR では、このオプションは使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-t\fR [\fIfile_descriptor\fR]\fR
.ad
.RS 28n
.rt  
ファイル記述子番号が \fIfile_descriptor\fR であるファイルがオープンされていて、端末装置に対応していれば真。\fIfile_descriptor\fR が指定されていない場合、デフォルト値として \fB1\fR が使用されます。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-u\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、セットユーザー ID フラグが設定されていれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-w\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、書き込み可能であれば真。真であっても、書き込みフラグが設定されていることを表すだけです。ファイルシステムが読み取り専用であれば、この条件が真であっても \fIfile\fR は書き込み不可能です。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-x\fR \fIfile\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile\fR が存在し、実行可能であれば真。真であっても、実行フラグが設定されていることを表すだけです。\fIfile\fR がディレクトリの場合には、真は \fIfile\fR が検索可能なことを表します。
.RE

.sp
.ne 2
.mk
.na
\fB\fB-z\fR \fIstring\fR\fR
.ad
.RS 28n
.rt  
文字列 \fIstring\fR の長さがゼロであれば真。
.RE

.sp
.ne 2
.mk
.na
\fB\fIfile1\fR \fB-nt\fR \fIfile2\fR \fR
.ad
.RS 28n
.rt  
ファイル \fIfile1\fR が存在し、\fIfile2\fR よりも新しい場合は真。\fBsh\fR では、このオプションは使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fIfile1\fR \fB-ot\fR \fIfile2\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile1\fR が存在し、\fIfile2\fR よりも古い場合は真。\fBsh\fR では、このオプションは使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fIfile1\fR \fB-ef\fR \fIfile2\fR\fR
.ad
.RS 28n
.rt  
ファイル \fIfile1\fR と \fIfile2\fR が存在し、同じファイルを参照している場合は真。\fBsh\fR では、このオプションは使用できません。
.RE

.sp
.ne 2
.mk
.na
\fB\fIstring\fR\fR
.ad
.RS 28n
.rt  
文字列 \fIstring\fR が NULL 文字列でなければ、真です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIstring1\fR\fB = \fR\fIstring2\fR \fR
.ad
.RS 28n
.rt  
文字列 \fIstring1\fR と \fIstring2\fR が等しければ真。
.RE

.sp
.ne 2
.mk
.na
\fB\fIstring1\fR\fB != \fR\fIstring2\fR \fR
.ad
.RS 28n
.rt  
文字列 \fIstring1\fR と \fIstring2\fR が等しくなければ真。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-eq\fR \fIn2\fR \fR
.ad
.RS 28n
.rt  
数値 \fIn1\fR と \fIn2\fR が代数的に等しければ真。数値は C99/XPG6/SUS で指定された任意の形式の整数、浮動小数点、または浮動小数点定数 ([+/-]Inf、[+/-]NaN など) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-ne\fR \fIn2\fR \fR
.ad
.RS 28n
.rt  
数値 \fIn1\fR と \fIn2\fR が代数的に等しくなければ真。数値は C99/XPG6/SUS で指定された任意の形式の整数、浮動小数点、または浮動小数点定数 ([+/-]Inf、[+/-]NaN など) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-gt\fR \fIn2\fR \fR
.ad
.RS 28n
.rt  
数値 \fIn1\fR が代数的に数値 \fIn2\fR より大きければ真。数値は C99/XPG6/SUS で指定された任意の形式の整数、浮動小数点、または浮動小数点定数 ([+/-]Inf、[+/-]NaN など) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-ge\fR \fIn2\fR \fR
.ad
.RS 28n
.rt  
数値 \fIn1\fR が代数的に数値 \fIn2\fR より大きいか等しければ真。数値は C99/XPG6/SUS で指定された任意の形式の整数、浮動小数点、または浮動小数点定数 ([+/-]Inf、[+/-]NaN など) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-lt\fR \fIn2\fR \fR
.ad
.RS 28n
.rt  
数値 \fIn1\fR が代数的に数値 \fIn2\fR より小さければ真。数値は C99/XPG6/SUS で指定された任意の形式の整数、浮動小数点、または浮動小数点定数 ([+/-]Inf、[+/-]NaN など) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIn1\fR \fB-le\fR \fIn2\fR \fR
.ad
.RS 28n
.rt  
数値 \fIn1\fR が代数的に数値 \fIn2\fR より小さいか等しければ真。数値は C99/XPG6/SUS で指定された任意の形式の整数、浮動小数点、または浮動小数点定数 ([+/-]Inf、[+/-]NaN など) です。
.RE

.sp
.ne 2
.mk
.na
\fB\fIcondition1\fR \fB-a\fR \fIcondition2\fR\fR
.ad
.RS 28n
.rt  
\fIcondition1\fR および \fIcondition2\fR の両方が真であれば真。\fB-a\fR 2 項プライマリは左結合であり、\fB-o\fR 2 項プライマリよりも優先される。
.RE

.sp
.ne 2
.mk
.na
\fB\fIcondition1\fR \fB-o\fR \fIcondition2\fR\fR
.ad
.RS 28n
.rt  
\fIcondition1\fR または \fIcondition2\fR のどちらかが真であれば真。\fB-o\fR バイナリプライマリは左結合である。
.RE

.sp
.LP
これらの基本式は、以下の演算子と組み合わせて指定できます。
.sp
.ne 2
.mk
.na
\fB\fB!\fR \fIcondition\fR\fR
.ad
.RS 17n
.rt  
条件 \fIcondition\fR が偽であれば真。
.RE

.sp
.ne 2
.mk
.na
\fB( \fIcondition\fR )\fR
.ad
.RS 17n
.rt  
condition が真であれば真。丸括弧 ( ) を使用すると、通常の優先順位や結合規則を変更できる。丸括弧はシェルにとっても意味を持つので、引用する必要があります。
.RE

.sp
.LP
演算子の優先順位を決めるアルゴリズム、および生成される戻り値は、\fBtest\fR に渡す引数の数により異なります。ただし \fB[...]\fR 形式を使う場合、最終引数の右角括弧は、このアルゴリズムでは引数には含まれません。
.sp
.LP
以下のリストにおいて、\fB$1\fR、\fB$2\fR、\fB$3\fR、\fB$4\fR は、\fIcondition\fR、\fIcondition1\fR、または \fIcondition2\fR として \fBtest\fR に渡す引数を表します。
.sp
.ne 2
.mk
.na
\fB\fI引数 0 個\fR\fR
.ad
.RS 16n
.rt  
偽 (1) で終了。
.RE

.sp
.ne 2
.mk
.na
\fB\fI引数 1 個\fR\fR
.ad
.RS 16n
.rt  
\fB$1\fR が空でなければ真 (0) で終了。NULL なら偽。
.RE

.sp
.ne 2
.mk
.na
\fB\fI引数 2 個\fR\fR
.ad
.RS 16n
.rt  
.RS +4
.TP
.ie t \(bu
.el o
\fB$1\fR が \fB!\fR のとき、\fB$2\fR が空なら真、\fB$2\fR が空でなければ偽。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB$1\fR が単項基本式のとき、単項テストの結果が真なら真、偽なら偽。
.RE
.RS +4
.TP
.ie t \(bu
.el o
その他の場合、結果は不確定です。
.RE
.RE

.sp
.ne 2
.mk
.na
\fB\fI引数 3 個\fR\fR
.ad
.RS 16n
.rt  
.RS +4
.TP
.ie t \(bu
.el o
\fB$2\fR が 2 項基本式のとき、\fB$1\fR と \fB$3\fR を対象に 2 項テストを実行。
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB$1\fR が \fB!\fR のとき、\fB$2\fR と \fB$3\fR の 2 つの引数に対するテストを否定形に。
.RE
.RS +4
.TP
.ie t \(bu
.el o
その他の場合、結果は不確定です。
.RE
.RE

.sp
.ne 2
.mk
.na
\fB\fI引数 4 個\fR\fR
.ad
.RS 16n
.rt  
.RS +4
.TP
.ie t \(bu
.el o
\fB$1\fRが \fB!\fR のとき、\fB$2\fR、\fB$3\fR、\fB$4\fR の 3 つの引数に対するテストを否定形に。
.RE
.RS +4
.TP
.ie t \(bu
.el o
その他の場合、結果は不確定です。
.RE
.RE

.SH 使用法
.sp
.LP
基本式と演算子が混在しているような、ユーザーが用意した入力データを処理する際、スクリプト側では十分な注意が必要です。スクリプトに対して入力データが生成されるケースをアプリケーション作成者がすべて理解していない限り、\fBtest "$1" -a "$2"\fR というような記述は、\fBtest "$1" && test "$2"\fR と変えた方がいいでしょう。ユーザーが \fB$1\fR を \fB!\fR に設定し、\fB$2\fR を空の文字列に設定したような場合の問題を防ぐためです。つまり移植性の高さが問題の場合には、\fBtest expr1 -a expr2\fR というような記述は \fBtest expr1 && test expr2\fR に変更し、 また、\fBtest expr1 -o expr2\fR の記述は \fBtest expr1 || test expr2\fR に変更してください。ただし、シェルでは \fB&&\fR と \fB-|\||\fR が同等の優先順位を持つのに対し、\fBtest\fR では \fB-a\fR の方が \fBo\fR よりも優先順位が高いことに注意してください。\fB\fR\fB\fR
.sp
.LP
シェルコマンド言語では、グループ分け用に小括弧と中括弧が使用できます。
.sp
.LP
\fBsh\fR を使うときは、小括弧はエスケープ付きで記述しなければなりません。例: 
.sp
.in +2
.nf
test \e( expr1 -a expr2 \e) -o expr3
.fi
.in -2

.sp
.LP
このコマンドは、 XSI 準拠のシステム以外では、必ずしも移植可能ではありません。この形式の代わりに、以下のように記述できます。
.sp
.in +2
.nf
( test expr1 && test expr2 ) || test expr3
.fi
.in -2

.sp
.LP
次に、以下の 2 つのコマンドを見てください。
.sp
.in +2
.nf
test "$1"
test ! "$1"
.fi
.in -2

.sp
.LP
古いシステムの一部では、このコマンドの動作は信頼性を欠くことがあります。つまりこのような \fIstring\fR 条件を使い \fB$1\fR を \fB!\fR、\fB(\fR、または単項基本式に展開すると、その結果は保証できません。したがって、それぞれ以下のように記述する方がいいでしょう。
.sp
.in +2
.nf
test -n "$1"
test -z "$1"
.fi
.in -2

.sp
.LP
同様に、古いシステムでは以下のようなコマンドの信頼性は保証できません。
.sp
.in +2
.nf
test "$response" = "expected string"
.fi
.in -2

.sp
.LP
これは、次のどちらかの形式に変えるようにしてください。
.sp
.in +2
.nf
test "X$response" = "Xexpected string"
test "expected string" = "$response"
.fi
.in -2

.sp
.LP
2 番目の形式は、\fBexpected string\fR が単項基本式とまぎらわしくなることはない、というのが前提です。つまり \fBexpected string\fR の先頭文字が \fB\(mi\fR、\fB(\fR、\fB!\fR、\fB=\fR のいずれかのときは、1 番目の形式を使用してください。注記した事項を除き、前述の規則を使用すれば、前述の 3 つの比較形式はどのような入力データに対しても信頼性の高いものです。なお、どの形式でも文字列は引用符で囲んで記述する点に注意してください。
.sp
.LP
引数の数が 4 個を超えている場合、文字列比較の 2 項基本式 \fB=\fR と \fB!=\fR はどの単項基本式よりも優先順位が高いので、引数が正しく指定されていないと処理結果は保証できません。たとえば次の例を見てください。
.sp
.in +2
.nf
test -d $1 -o -d $2
.fi
.in -2

.sp
.LP
ここで \fB$1\fR の評価結果がディレクトリ名 \fB=\fR となった場合、先頭の 3 つの引数は文字列比較を表すものと見なされます。したがって 2 つ目の \fB-d\fR を検出したときに構文エラーとなります。 これを避けるには、次に示すどちらかの形式、できれば 2 番目の方を使用してください。
.sp
.in +2
.nf
test \e( -d "$1" \e) -o \e( -d "$2" \e)
test -d "$1" || test -d "$2"
.fi
.in -2

.sp
.LP
また引数が 4 個を超えているときに次のように指定したとします。
.sp
.in +2
.nf
test "$1" = "bat" -a "$2" = "ball"
.fi
.in -2

.sp
.LP
このとき \fB$1\fR の評価結果が \fB(\fR または \fB!\fR だと構文エラーとなります。これを避けるには、次に示すいずれかの形式、できれば 3 番目を使用してください。
.sp
.in +2
.nf
test "X$1" = "Xbat" -a "X$2" = "Xball"
test "$1" = "bat" && test "$2" = "ball"
test "X$1" = "Xbat" && test "X$2" = "Xball"
.fi
.in -2

.SH 使用例
.sp
.LP
\fBif\fR の例では次の 3 つの状態が調べられ、3 つのすべてが真、または正常終了とみなされた場合、その結果が画面に出力されます。調べられる 3 つの内容は次のとおりです。
.RS +4
.TP
.ie t \(bu
.el o
1 に設定されている変数の値が 0 より大きいか
.RE
.RS +4
.TP
.ie t \(bu
.el o
2 に設定されている変数の値が 2 に等しいか
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fBroot\fR という語がテキストファイル \fB/etc/passwd\fR に含まれているか
.RE
.SS "/usr/bin/test"
.LP
\fB例 1 \fR/usr/bin/test の使用
.sp
.LP
ディレクトリが存在しなければ \fBmkdir\fR を実行します。

.sp
.in +2
.nf
test ! -d tempdir && mkdir tempdir
.fi
.in -2

.sp
.LP
読み取り不可になるまで少し待つ。

.sp
.in +2
.nf
while test -r thefile
do
   sleep 30
done
echo'"thefile" is no longer readable'
.fi
.in -2

.sp
.LP
引数が 3 つの文字列 (2 つは変形) のうちの 1 つであり、\fBtest\fR コマンドの開く角括弧バージョン (\fB[\fR) を使用していればコマンドを実行します。

.sp
.in +2
.nf
if [ "$1" = "pear" ] || [ "$1" = "grape" ] || [ "$1" = "apple" ]
then
    command
fi
case "$1" in
    pear|grape|apple) command;;
esac
.fi
.in -2

.LP
\fB例 2 \fR/usr/bin/test での -e オプションの使用
.sp
.LP
実際に \fBsh\fR で \fB-e\fR オプションを使用する場合、次のように \fB/usr/bin/test\fR を使用します。

.sp
.in +2
.nf
if [ ! -h $PKG_INSTALL_ROOT$rLink ] && /usr/bin/test -e
$PKG_INSTALL_ROOT/usr/bin/$rFile ; then
    ln -s $rFile $PKG_INSTALL_ROOT$rLink
fi
.fi
.in -2

.SS "test 組み込みコマンド"
.sp
.LP
以下の例では、Bourne シェルの \fBif\fR に続いて \fBtest\fR 組み込みコマンドの 2 つの形式を記します。
.LP
\fB例 3 \fRsh 組み込みコマンドの使用
.sp
.in +2
.nf
ZERO=0 ONE=1 TWO=2 ROOT=root

if  [ $ONE \fB-gt\fR $ZERO ]

[ $TWO \fB-eq\fR 2 ]

grep $ROOT  /etc/passwd >&1 > /dev/null  \fI# discard output\fR

then

    echo "$ONE is greater than 0, $TWO equals 2, and $ROOT is" \e
          "a user-name in the password file"

else

    echo "At least one of the three test conditions is false"        
fi
.fi
.in -2

.LP
\fB例 4 \fRtest 組み込みコマンドの使用
.sp
.LP
\fBtest\fR 組み込みコマンドの例

.sp
.in +2
.nf
test \(gagrep $ROOT /etc/passwd >&1 /dev/null\(ga   \fI# discard output\fR 

echo $?    \fI# test for success\fR
[ \(gagrep nosuchname /etc/passwd >&1 /dev/null\(ga ]

echo $?    \fI# test for failure\fR
.fi
.in -2

.SS "csh"
.LP
\fB例 5 \fRcsh 組み込みコマンドの使用
.sp
.in +2
.nf
@ ZERO = 0; @ ONE = 1; @ TWO = 2;  set ROOT = root
grep $ROOT  /etc/passwd >&1 /dev/null  \fI# discard output\fR         
    \fI# $status must be tested for immediately following grep\fR 
if ( "$status" == "0" && $ONE > $ZERO && $TWO == 2 ) then
       echo "$ONE is greater than 0, $TWO equals 2, and $ROOT is" \e
             "a user-name in the password file"
 endif
.fi
.in -2

.SS "ksh88"
.LP
\fB例 6 \fRksh88/ksh 組み込みコマンドの使用
.sp
.in +2
.nf
ZERO=0 ONE=1 TWO=$((ONE+ONE)) ROOT=root         
if  ((ONE > ZERO))            \fI#  arithmetical comparison\fR
 [[ $TWO = 2 ]]                \fI#  string comparison\fR
 [ \(gagrep $ROOT  /etc/passwd >&1 /dev/null\(ga ] \fI# discard output\fR        
then 
     echo "$ONE is greater than 0, $TWO equals 2, and $ROOT is" \e
             "a user-name in the password file"

else
     echo "At least one of the three test conditions is false"
fi
.fi
.in -2

.SH 環境
.sp
.LP
\fBtest\fR の実行に影響を与える次の環境変数についての詳細は、\fBenviron\fR(5) を参照してください。\fBLANG\fR、\fBLC_ALL\fR、\fBLC_CTYPE\fR、\fBLC_MESSAGES\fR、および \fBNLSPATH\fR。
.SH 終了ステータス
.sp
.LP
次の終了値が返されます。
.sp
.ne 2
.mk
.na
\fB\fB0\fR \fR
.ad
.RS 7n
.rt  
\fIcondition\fR の評価結果は真だった。
.RE

.sp
.ne 2
.mk
.na
\fB\fB1\fR \fR
.ad
.RS 7n
.rt  
\fIcondition\fR の評価結果は偽だった、または \fIcondition\fR が指定されていなかった。
.RE

.sp
.ne 2
.mk
.na
\fB\fB>1\fR \fR
.ad
.RS 7n
.rt  
エラーが発生しました。
.RE

.SH 属性
.sp
.LP
属性についての詳細は、\fBattributes\fR(5) を参照してください。
.SS "/usr/bin/test、csh、ksh88、sh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件system/core-os
_
インタフェースの安定性確実
_
標準T{
\fBstandards\fR(5) を参照してください。
T}
.TE

.SS "ksh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性タイプ属性値
_
使用条件system/core-os
_
インタフェースの安定性不確実
.TE

.SH 関連項目
.sp
.LP
\fBcsh\fR(1), \fBksh\fR(1), \fBksh88\fR(1), \fBsh\fR(1), \fBtest\fR(1B), \fBattributes\fR(5), \fBenviron\fR(5), \fBlargefile\fR(5), \fBstandards\fR(5)
.SH 注意事項
.sp
.LP
\fB-f\fR オプションの代替である \fBnot\(mia\(midirectory\fR は \fBBSD\fR アプリケーションの移行を補助するものであり、将来のリリースではサポートされなくなる可能性があります。
.SS "XPG4 \fBsh\fR, \fBksh\fR, \fBksh\fR"
.sp
.LP
次のような算術式を使用します。
.sp
.in +2
.nf
$(( x > 3.1 )) #
.fi
.in -2
.sp

.sp
.LP
次の代わりに
.sp
.in +2
.nf
$ /usr/bin/test "$x" -gt 3.1 # )
.fi
.in -2
.sp

.sp
.LP
2 つの浮動小数点変数、または定数と浮動小数点変数を比較して、(base16 から base10 への変換による) 丸め誤差が結果に影響を与えることを避ける場合です。さらに、XPG4 \fBsh\fR、\fBksh88\fR、および \fBksh\fR での組み込み演算のサポートは、比較するたびに文字列を明示的に変換する必要がないため、大幅に高速になります。
