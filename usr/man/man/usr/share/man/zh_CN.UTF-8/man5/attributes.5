'\" te
.\" Copyright (c) 2007, 2011, Oracle and/or its affiliates. 保留所有权利。
.TH attributes 5 "2011 年 6 月 23 日" "SunOS 5.11" "标准、环境和宏"
.SH 名称
attributes, architecture, availability, CSI, stability, MT-Level, standard \- 接口属性
.SH 描述
.sp
.LP
手册页的\fB属性\fR部分包含一个定义属性类型及其相应值的表。下面提供了属性表的一个示例。并非所有属性类型都适用于所有接口类型。
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
属性类型属性值
_
体系结构SPARC
_
可用性system/kernel
_
CSIEnabled（已启用）
_
接口稳定性Committed（已确定）
_
MT 级别Safe（安全）
_
标准请参见 \fBstandards\fR(5)。
.TE

.SS "体系结构"
.sp
.LP
体系结构定义处理器或特定硬件。请参见 \fBuname\fR(1) 的 \fB-p\fR 选项。在某些情况下，体系结构可能表示所需适配器或外围设备。
.SS "可用性"
.sp
.LP
这表示包含本手册页介绍的命令或组件的软件包。要使用此命令，必须安装指示的软件包。有关如何添加软件包的信息，请参见 \fBpkg\fR(1)。
.SS "代码集独立性 (Code Set Independence, CSI)"
.sp
.LP
不依赖于任何代码集的属性的 \fBOS\fR 实用程序和库具有代码集独立性 (Code Set Independence, CSI)。它们具有启用 \fBCSI\fR 的属性。这区别于许多仅使用扩展 Unix 代码集 (Extended Unix Codeset, EUC) 等编码方法的命令和实用程序。扩展 Unix 代码集编码方法允许同时支持最多四个代码集并且通常用于表示亚洲字符集。
.sp
.LP
不过，出于实际原因，这种独立性不是绝对的。某些假设对当前 \fBCSI\fR 实现依然适用：
.RS +4
.TP
.ie t \(bu
.el o
文件代码是 \fBASCII\fR 的超集。
.RE
.RS +4
.TP
.ie t \(bu
.el o
要支持多字节字符和以 null 结尾的 \fBUNIX\fR 文件名，任何多字节字符不能包含 \fINULL\fR 和 \fB/\fR（斜杠）字符。
.RE
.RS +4
.TP
.ie t \(bu
.el o
仅支持"无状态"文件代码编码。无状态编码可避免移位、锁定移位、指定、调用等，但单一移位未排除在外。
.RE
.RS +4
.TP
.ie t \(bu
.el o
进程代码（\fBwchar_t\fR 值）取决于实现，并且可随时间、实现或语言环境而发生更改。
.RE
.RS +4
.TP
.ie t \(bu
.el o
并非每个对象的名称都可由任意字符组成。下列对象的名称必须由 \fBASCII\fR 字符组成： 
.RS +4
.TP
.ie t \(bu
.el o
用户名、组名和口令
.RE
.RS +4
.TP
.ie t \(bu
.el o
系统名称
.RE
.RS +4
.TP
.ie t \(bu
.el o
打印机和特殊设备的名称
.RE
.RS +4
.TP
.ie t \(bu
.el o
终端名称 (/\fBdev/tty*\fR)
.RE
.RS +4
.TP
.ie t \(bu
.el o
进程 \fBID\fR 号
.RE
.RS +4
.TP
.ie t \(bu
.el o
消息队列、信号量和共享内存标签。
.RE
.RS +4
.TP
.ie t \(bu
.el o
下列各项可由 \fBISO\fR Latin-1 或 \fBEUC\fR 字符组成： 
.RS +4
.TP
.ie t \(bu
.el o
文件名
.RE
.RS +4
.TP
.ie t \(bu
.el o
目录名称
.RE
.RS +4
.TP
.ie t \(bu
.el o
命令名称
.RE
.RS +4
.TP
.ie t \(bu
.el o
Shell 变量和环境变量名称
.RE
.RS +4
.TP
.ie t \(bu
.el o
文件系统挂载点
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fBNIS\fR 键名和域名
.RE
.RE
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fBNFS\fR 共享文件的名称应由 \fBASCII\fR 字符组成。尽管文件和目录的名称及内容可由非 \fBASCII\fR 代码集中的字符组成，但如果仅使用 \fBASCII\fR 代码集，则允许在任何计算机上挂载 \fBNFS\fR，而不管是否已本地化。所有启用了 \fBCSI\fR 的命令和实用程序均可处理在 2.6 中发布的单字节和多字节语言环境。为使应用程序获得完整的国际化服务支持，必须应用动态绑定。只有 C 和 POSIX 语言环境才支持静态绑定程序。
.RE
.SS "接口稳定性"
.sp
.LP
Oracle 通常使开发人员提前就能够接触到新技术，这使得开发人员能够尽早对这些技术进行评估。遗憾的是，新技术容易发生更改，并且标准化新技术往往会导致接口与以前的版本不兼容。
.sp
.LP
为了进行合理的风险评估，开发人员必须了解接口在将来发行版中发生更改的可能性。为了帮助开发人员进行上述评估，某些手册页中提供了命令、入口点和文件格式的接口稳定性信息。
.sp
.LP
由于 Oracle 将尽力确保在将来的次要发行版中继续使用接口，因此这些接口将更加稳定，可供几乎所有应用程序安全地使用。仅依赖于已确定接口的应用程序应在将来的次要发行版中（而不一定是在早期主要发行版中）继续可靠地正常运行。
.sp
.LP
欠稳定的接口可用于进行实验和设计原型，但使用时必须了解这些接口可能会发生不兼容的更改，甚至可能在将来的次要发行版中被删除或替换为其他接口。
.sp
.LP
Oracle 未记录的"接口"（例如，大多数内核数据结构以及系统头文件中的某些符号）可能是实现工件。此类内部接口不仅会发生不兼容的更改或被删除，我们还可能不会在发行说明中提及此类更改。
.SS "发行版级别"
.sp
.LP
产品具有指定的发行版级别和名称，这些有助于进行兼容性介绍。每个发行版级别还可能包括适合较低级别的更改。
.sp

.sp
.TS
tab();
cw(1.1i) cw(1.1i) cw(3.3i) 
lw(1.1i) lw(1.1i) lw(3.3i) 
.
发行版版本含义
_
主x.0T{
可能包含增加的主要功能；遵循可能不兼容的不同标准修订；可能会更改、删除或替换已确定接口（虽然这些情况不太可能发生）。产品初始发行版通常为 1.0。
T}
_
次x.yT{
与 x.0 或早期发行版 (y!=0) 相比，此发行版可能包括：增加的功能、对已确定接口所做的兼容更改、或者可能对未确定或 Volatile（可变）接口所做的不兼容更改。
T}
_
微x.y.zT{
应为与上一个发行版 (z!=0) 兼容的接口，但可能修复了更多错误、改进了性能并且支持其他硬件。可能对 Volatile（可变）接口进行了不兼容的更改。
T}
.TE

.sp
.LP
在接口稳定性上下文中，更新发行版（有时称为修补发行版）应视为等效于微发行版。
.SS "分类"
.sp
.LP
下表概述了稳定性级别分类与发行版级别的关系。第一列中列出了稳定性级别。第二列中列出了不兼容的更改所对应的发行版级别，第三列中列出了其他注释。有关各分类的完整讨论，请参见下面的相应小节。
.sp

.sp
.TS
tab();
cw(1.1i) cw(1.1i) cw(3.3i) 
lw(1.1i) lw(1.1i) lw(3.3i) 
.
稳定性发行版注释
_
已确定主发行版 (x.0)极少发生不兼容情况。
_
未确定次发行版 (x.y)经常发生不兼容情况。
_
Volatile（可变）微发行版 (x.y.z)经常发生不兼容情况。
.TE

.sp
.LP
除非另行说明，否则本手册页中介绍的接口稳定性级别分类适用于源代码接口和二进制接口。所有稳定性级别分类都是公共的，但\fB专用\fR分类除外。除非明确说明，否则不会指定公共接口（即本手册页中记录的接口）的确切稳定性级别。未记录接口的稳定性级别缺省为\fB专用\fR。
.sp
.LP
除了 Solaris 产品中包含的文档以外，其他现有文档不应解释为暗指 Solaris 产品所提供接口的任何稳定性级别。Solaris 手册页是稳定性级别信息的唯一来源。
.sp
.ne 2
.mk
.na
\fB\fBCommitted（已确定）\fR\fR
.ad
.sp .6
.RS 4n
已确定接口的用途在于使第三方能够根据这些接口开发和发布应用程序，并确信这些应用程序能够在引入接口的产品发行版的所有后续发行版（属于同一主要发行版）中正常运行。即使在主要发行版中，不兼容的更改也应当极少出现，并且应具有正当理由。
.sp
作为行业标准定义和控制的接口通常视为已确定接口。在这种情况下，属性表中的"标准"条目或其他文档位置通常会说明监管机构和/或公共文档版本。
.sp
虽然不兼容的更改很少发生，但是如果相关缺陷极其严重（如本文档的"例外情况"部分中所述），在任何发行版中都可能会发生不兼容的更改；或者在次要发行版中，可能会通过"功能终止"过程来执行不兼容的更改。如果必须停止对已确定接口的支持，Oracle 将会尝试提供通知并将稳定性级别标记为"过时"。
.RE

.sp
.ne 2
.mk
.na
\fB\fBUncommitted（未确定）\fR\fR
.ad
.sp .6
.RS 4n
不对这些接口在不同次要发行版中的源代码或二进制兼容性进行任何承诺。甚至在次要发行版中可能会发生接口删除等重大的不兼容更改。未确定的接口通常不适用于与发行版无关的产品。
.sp
对接口进行不兼容更改旨在对接口进行实质性的改进（包括考虑到易用性等因素）。一般情况下，未确定的接口不太可能进行不兼容的更改，如果发生此类更改，这些更改将影响甚微，并且通常具有减轻风险计划。
.sp
未确定的接口通常属于下列子类别之一：
.RS +4
.TP
1.
实验性或过渡性接口。这些接口通常旨在使外部开发者可以及早接触到一些新兴的、不断发展变化的技术，或者提供一个临时的解决问题的办法，有待将来再寻求更通用的解决方案。
.RE
.RS +4
.TP
2.
其规范由外部机构控制的接口，但 Oracle 希望在提供与外部规范同步的下一个次要发行版之前尽力与以前的发行版保持兼容。
.RE
.RS +4
.TP
3.
相较于稳定性而言，其目标用户更重视创新（或者易用性）的接口。此属性通常与较高层组件的管理接口相关联。
.RE
对于未确定的接口，Oracle 不会对不同次要发行版之间的源代码或二进制兼容性做出任何声明。根据这些接口开发的应用程序可能无法在将来的次要发行版中运行。
.RE

.sp
.ne 2
.mk
.na
\fB\fBVolatile（可变）\fR\fR
.ad
.sp .6
.RS 4n
Volatile（可变）接口可能出于任何原因而随时发生更改。
.sp
通过 Volatile（可变）接口稳定性级别，Oracle 产品可以快速跟上不断发展变化的规范。在许多情况下，与为接口提供额外的稳定性相比，Volatile（可变）接口能够更好地满足使用者的期望，因此人们更喜欢使用 Volatile（可变）接口。
.sp
此分类级别最常应用于由 Oracle 以外的机构控制的接口，但与重视接口兼容性的标准机构或免费/开源软件 (Free or Open Source Software, FOSS) 社区控制的规范不同的是，无法声明极少对接口规范进行的不兼容更改。此外，此接口还适用于由 FOSS 控制的软件，对于此类软件，大家认为在最短时间内了解社区动态比向我们的客户提供稳定性更为重要。
.sp
通常还可以在可靠组织或广泛认可的组织定义接口的过程中，将 Volatile（可变）分类级别应用于接口。这些级别通常称为标准草案。"IETF Internet 草案"就是一个广为人知的正在开发的规范的示例。
.sp
此外，实验性接口也可以是 Volatile（可变）接口。
.sp
我们不对任何两个发行版（包括修补程序）之间的 Volatile（可变）接口的源代码或二进制兼容性做出任何声明。包含这些接口的应用程序可能无法在将来的任何发行版中正常运行。
.RE

.sp
.ne 2
.mk
.na
\fB\fBNot-an-Interface（不是接口）\fR\fR
.ad
.sp .6
.RS 4n
有时会出现以下情况：推断存在的某个实体可能是一个接口，但实际上却并非是接口。常见示例包括：仅供人员使用的 CLI 的输出以及 GUI 的确切布局。
.sp
此分类是一个适合用于阐明确定可能存在此类混淆的术语。如果无法对实体应用此术语，也并不意味着该实体就是某种形式的接口。它仅表明未确定可能存在此类混淆。
.RE

.sp
.ne 2
.mk
.na
\fB\fBPrivate（专用）\fR\fR
.ad
.sp .6
.RS 4n
专用接口是由组件（或产品）提供的专用于该组件的接口。专用接口仍可对其他组件可见或可由其他组件访问。由于使用其他组件的专用接口存在巨大的稳定性风险，因此明确不支持这种使用方式。并非由 Oracle Corporation 提供的组件不应使用专用接口。
.sp
大多数专用接口都未予以记录。我们很少记录专用接口。记录专用接口的原因包括（但不限于）：接口用途可能会在将来重新分类为某个公共稳定性级别分类，或者该接口会无规律地显现。
.RE

.sp
.ne 2
.mk
.na
\fB\fBObsolete（已过时）\fR\fR
.ad
.sp .6
.RS 4n
"已过时"是可与上述分类级别一起显示的修饰符。"已过时"修饰符表示接口"已弃用"并且/或者建议不要继续用于一般用途。通过应用"已过时"修饰符，现有接口可从某个其他状态（例如，已确定或未确定）发生降级，以便建议客户先从该接口进行迁移，然后再删除（或以不兼容方式更改）该接口。
.sp
当前发行版支持已过时接口，但计划在将来的（次要）发行版中将其删除。停止接口支持之前，Oracle 将会首先尝试提供通知，然后再停止支持相应接口。使用已过时接口会生成警告消息。
.RE

.SS "例外情况"
.sp
.LP
在极少情况下，为了维护 Oracle 和客户的最佳利益，需要违反接口稳定性承诺。下表包含接口提供者违反接口稳定性确定的常见已知原因，但不排除存在其他原因。
.RS +4
.TP
1.
存在安全漏洞（接口固有的漏洞）。
.RE
.RS +4
.TP
2.
发生数据损坏（接口固有的漏洞）。
.RE
.RS +4
.TP
3.
违反标准的情况（由一致性测试的解释或改进中的更改所揭示）。
.RE
.RS +4
.TP
4.
并非由 Oracle 控制的接口规范已发生不兼容的更改，并且大多数接口使用者都希望提供更新的接口。
.RE
.RS +4
.TP
5.
对于客户来说，不进行不兼容更改是无法接受的。例如，在放弃 DOS 8.3 命名限制后，如果不对 pcfs 进行不兼容的更改，就会是一个这样的示例。
.RE
.sp
.LP
例外情况允许的不兼容更改将始终尽可能在"最主要的"发行版中提供。但是，漏洞带来的后果或合同相关规定要求往往会强制在修补程序中提供。
.SS "与早期接口分类机制的兼容性"
.sp
.LP
在 Solaris 10 以及先前的发行版中，采用不同的接口分类机制。下表概述了新旧分类机制之间的映射。
.sp

.sp
.TS
tab();
cw(1.1i) cw(1.1i) cw(3.3i) 
lw(1.1i) lw(1.1i) lw(3.3i) 
.
旧机制新建 注释
_
标准已确定T{
应显示标准属性类型的属性表中的条目。
T}
稳定已确定名称更改。
发展中未确定实际承诺相符。
不稳定未确定名称更改。
外部Volatile（可变）T{
名称更改，同时扩展了允许的使用情况。
T}
已过时(已过时)以前为分类，现在为修饰符。
.TE

.sp
.LP
免费/开源软件的重要性日益提高，促使将名称从"稳定/不稳定"更改为"已确定/未确定"。"稳定"一词与该术语在 FOSS 社区中的常见用途相冲突。
.sp
.LP
"正在改进"的定义比较模糊，导致很难理解此术语。在迁移到新分类机制的过程中，以前的许多"正在改进"的接口都已升级为"已确定"。不过，在遇到术语"正在改进"时，应推断为"未确定"。
.SS "MT 级别"
.sp
.LP
库分为若干类别，这些类别定义了其支持多个线程的能力。包含属于多个或不同级别的函数的手册页在\fB注释\fR或\fB用法\fR部分中对此方面进行了介绍。
.sp
.ne 2
.mk
.na
\fB\fBSafe（安全）\fR\fR
.ad
.sp .6
.RS 4n
"安全"是可从多线程应用程序调用的代码的属性。调入安全接口或安全代码段的作用是：即使由多个线程调用，结果仍然有效。人们常常忽视的一点是：此安全接口或安全代码段的结果可产生影响所有线程的全局后果。例如，从一个线程打开或关闭文件的操作对进程中的所有线程都可见。多线程应用程序负责安全地使用这些接口，这与此接口是否安全有所不同。例如，关闭应用程序中其他线程仍在使用的文件的多线程应用程序未安全地使用 \fBclose\fR(2) 接口。
.RE

.sp
.ne 2
.mk
.na
\fB\fBUnsafe（非安全）\fR\fR
.ad
.sp .6
.RS 4n
非安全库包含不受保护的全局和静态数据。除非应用程序安排每次仅在库中执行一个线程，否则使用此库会不安全。非安全库可能包含安全函数；不过，库包含的大多数函数在调用时都是不安全的。某些非安全函数具有多线程安全的可重入函数。可重入函数由附加到函数名称的 \fB_r\fR 后缀指定。
.RE

.sp
.ne 2
.mk
.na
\fB\fBMT-Safe（MT 安全）\fR\fR
.ad
.sp .6
.RS 4n
多线程安全库是为多线程访问而充分准备的库。它通过锁定保护其全局和静态数据，并且可提供合理数目的并发性。可以安全使用的库并不能视为多线程安全。例如，使用监视器监视整个库可使库保持安全，但它不支持并发性，因此不能视为多线程安全。多线程安全库必须允许合理数目的并发性。（此定义的目的是精确定义安全库的含义。安全库的定义不会指定该库是否支持并发性。多线程安全定义明确指明该库是安全的，并且支持一定程度的并发性。这阐明了安全定义，它可以表示从单线程到任何并发度的多线程的所有内容。）
.RE

.sp
.ne 2
.mk
.na
\fB\fBAsync-Signal-Safe（异步信号安全）\fR\fR
.ad
.sp .6
.RS 4n
"异步信号安全"表示可从信号处理程序安全地调用的特定库函数。执行异步信号安全函数的线程在被信号中断时，自身不会发生死锁。信号只会为获取锁定的多线程安全函数带来问题。
.sp
异步信号安全函数也具有多线程安全性。在异步信号安全函数中获取锁定时，将禁用信号。这些信号用于防止调用可能获取相同锁定的信号处理程序。
.RE

.sp
.ne 2
.mk
.na
\fB\fBMT-Safe with Exceptions（MT 安全，但存在异常）\fR\fR
.ad
.sp .6
.RS 4n
有关异常的说明，请参见这些页面的\fB注释\fR或\fB用法\fR部分。
.RE

.sp
.ne 2
.mk
.na
\fB\fBSafe with Exceptions（安全，但存在异常）\fR\fR
.ad
.sp .6
.RS 4n
有关异常的说明，请参见这些页面的 \fB\fR"附注"或\fB\fR"用法"部分。
.RE

.sp
.ne 2
.mk
.na
\fB\fBFork-Safe（Fork 安全）\fR\fR
.ad
.sp .6
.RS 4n
\fBfork\fR(2) 函数仅在子进程中复制调用线程。\fBfork1\fR(2) 函数的存在目的是为了与以前版本兼容，它与 \fBfork()\fR 同义。当调用 \fBfork()\fR 时，如果未在执行派生的其他线程保持锁定，该锁定仍将保持在子进程中，但是由于未复制所属线程，因此没有锁定所有者。调用尝试获取锁定的函数的子进程自身将发生死锁。
.sp
当调用 \fBfork()\fR 时，Fork 安全库安排仅让执行派生的线程保留该库的所有内部锁定。这通常是使用 \fBpthread_atfork\fR(3C) 实现的，该函数在初始化库时调用。
.sp
在极少情况下，如果进程需要在执行派生时复制其所有线程，\fBforkall\fR(2) 函数会提供此功能。调用 \fBforkall()\fR 时，不会执行 \fBpthread_atfork()\fR 操作。调用 \fBforkall()\fR 存在相应的危险。当某个线程调用 \fBforkall()\fR 时，如果进程中的某些其他线程正在执行 I/O 操作，这些线程将继续在父进程和子进程中执行相同的 I/O 操作，这可能会导致数据损坏。出于此原因以及其他竞争情况原因，不建议使用 \fBforkall()\fR。
.sp
在 Solaris 10 之前的所有 Solaris 发行版中，\fBfork()\fR 的行为取决于应用程序是否与 \fB-lpthread\fR 相链接（有关 POSIX 线程，请参见 \fBstandards\fR(5)）。如果与 \fB-lpthread\fR 链接，\fBfork()\fR 的行为与 \fBfork1()\fR 相似，否则与 \fBforkall()\fR 相似。为了避免产生有关 \fBfork()\fR 行为的任何混淆，应用程序可以根据需要明确地调用 \fBfork1()\fR 或 \fBforkall()\fR。
.RE

.sp
.ne 2
.mk
.na
\fB\fBCancel-Safety（取消安全）\fR\fR
.ad
.sp .6
.RS 4n
如果多线程应用程序使用 \fBpthread_cancel\fR(3C) 取消（即中止）线程，目标线程在中止时可能会保留某项资源，例如锁定或分配的内存。如果线程未安装有适当的取消清除处理程序来释放相应资源（请参见 \fBpthread_cancel\fR(3C)），该应用程序即为"取消不安全"，也就是说，从线程取消方面来说，该应用程序不安全。由于取消的线程未释放锁定，这种非安全性可能导致死锁或资源泄漏；例如，不会在取消线程时释放内存。使用 \fBpthread_cancel\fR(3C) 的所有应用程序都应确保它们在"取消安全"环境中运行。此外，如果库具有取消点并且获取锁定等资源或动态分配内存，也会导致与这些库关联的应用程序的取消不安全性。这为多线程程序中的库引入了另一个安全级别：取消安全。取消安全包含两个子类别：延迟取消安全以及异步取消安全。如果应用程序对于取消类型为 \fBPTHREAD_CANCEL_DEFERRED\fR 的线程为取消安全时，该应用程序被视为延迟取消安全。如果应用程序对于取消类型为 \fBPTHREAD_CANCEL_ASYNCHRONOUS\fR 的线程为取消安全时，该应用程序被视为异步取消安全。由于具有延迟取消类型的线程只能在正确定义的取消点取消，而具有异步取消类型的线程可在任意位置取消，因此延迟取消安全比异步取消安全更容易实现。缺省情况下，创建的所有线程都具有延迟取消类型，因此可能永远不需要担心异步取消安全。大多数应用程序和库都应当始终为异步取消不安全。根据定义，异步取消安全的应用程序同时也是延迟取消安全的。
.RE

.SS "标准"
.sp
.LP
许多接口都作为行业标准进行定义和控制。在这种情况下，本部分中将说明监管机构和/或公共文档版本。
.sp
.LP
程序员在生成可移植应用程序时，应该遵照此应用程序应符合的标准或规范中提供的接口说明，而不能遵照基于公共标准的接口的手册页说明。当标准或规范允许备用实现选项时，本手册页通常仅介绍由 Oracle 实现的备用选项。此外，本手册页还会介绍由 Oracle 提供的标准接口的基本定义的所有兼容扩展。
.sp
.LP
对于文中引用的监管机构或文档，并不意味着我们将其认可为"标准"条目。监管机构可以是非常正式的组织（例如 ISO 或 ANSII）、较不正式但广泛接受的组织（例如 IETF）或非正式的独立贡献者（例如 FOSS（Free or Open Source Software，免费/开源软件）贡献者）。
.SH 另请参见
.sp
.LP
\fBuname\fR(1)、\fBIntro\fR(3)、\fBstandards\fR(5)
.sp
.LP
\fBpkg\fR(1)
