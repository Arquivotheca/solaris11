'\" te
.\" Copyright (c) 2007, 2011, Oracle and/or its affiliates.All rights reserved.
.\" Copyright 1989 AT&T
.\" Portions Copyright (c) 1982-2007 AT&T Knowledge Ventures
.TH shell_builtins 1 "2011 年 7 月 27 日" "SunOS 5.11" "用户命令"
.SH 名称
shell_builtins, case, for, foreach, function, if, repeat, select, switch, until, while \- shell 命令解释程序内置命令
.SH 描述
.sp
.LP
shell 命令解释程序 \fBcsh\fR(1)、\fBksh\fR(1)、\fBksh88\fR(1) 和 \fBsh\fR(1) 具有特殊的内置命令。命令 \fBcase\fR、\fBfor\fR、\fBforeach\fR、\fBfunction\fR、\fBif\fR、\fBrepeat\fR、\fBselect\fR、\fBswitch\fR、\fBuntil\fR 和 \fBwhile\fR 是可被 shell 识别的语法中的命令。这些命令在各自 shell 手册页中的 \fBCommands\fR 一节中进行了介绍。缺省情况下，在 \fBksh\fR(1) 中，\fBfc\fR、\fBhash\fR、\fBstop\fR、\fBsuspend\fR、\fBtimes\fR 和 \fBtype\fR 为别名。
.sp
.LP
下表中列出的其余命令出于效率或在命令调用之间共享数据等原因而内置到 shell 中。这些命令在各自的手册页中进行了介绍。
.sp

.sp
.TS
tab();
cw(2.75i) cw(2.75i) 
lw(2.75i) lw(2.75i) 
.
命令 Shell
_
\fBalarm\fRksh
\fB++**alias\fRcsh、ksh88、ksh
\fBbg\fRcsh、ksh88、ksh、sh
\fB+*break\fRcsh、ksh88、ksh、sh
\fBbuiltin\fRksh
\fBcase\fRcsh、ksh88、ksh、sh
\fBcd\fRcsh、ksh88、ksh、sh
\fBchdir\fRcsh、sh
\fBcommand \fRksh
\fB+*continue\fRcsh、ksh88、ksh、sh
\fBdirs\fRcsh
\fBdisown\fRksh
\fBecho\fRcsh、ksh88、ksh、sh
\fBenum\fRksh
\fB+*eval\fRcsh、ksh88、ksh、sh
\fB+*exec\fRcsh、ksh88、ksh、sh
\fB+*exit\fRcsh、ksh88、ksh、sh
\fB++**export\fRksh88、ksh、sh
\fBfalse\fRksh88、ksh
\fBfc\fRksh88、ksh
\fBfg\fRcsh、ksh88、ksh、sh
\fBfor\fRksh88、ksh、sh
\fBforeach\fRcsh
\fBfunction\fRksh88、ksh
\fBgetopts\fRksh88、ksh、sh
\fBglob\fRcsh
\fBgoto\fRcsh
\fBhash（散列）\fRksh88、ksh、sh
\fBhashstat\fRcsh
\fBhist\fRksh
\fBhistory\fRcsh
\fBif\fRcsh、ksh88、ksh、sh
\fBjobs\fRcsh、ksh88、ksh、sh
\fBkill\fRcsh、ksh88、ksh、sh
\fBlet\fRksh88、ksh
\fBlimit\fRcsh
\fBlogin\fRcsh、ksh88、ksh、sh
\fBlogout\fRcsh
\fBnice\fRcsh
\fB+*newgrp\fRksh88、ksh、sh
\fBnohup\fRcsh
\fBnotify\fRcsh
\fBonintr\fRcsh
\fBpopd\fRcsh
\fBprint\fRksh88、ksh
\fBprintf\fRksh
\fBpushd\fRcsh
\fBpwd\fRksh88、ksh、sh
\fBread（读取）\fRksh88、ksh、sh
\fB++**readonly\fRksh88、ksh、sh
\fBrehash\fRcsh
\fBrepeat\fRcsh
\fB+*return\fRksh88、ksh、sh
\fBselect\fRksh88、ksh
\fB+set\fRcsh、ksh88、ksh、sh
\fBsetenv\fRcsh
\fB*shift\fRcsh、ksh88、ksh、sh
\fBsource（源）\fRcsh
\fBstop\fRcsh、ksh88、ksh、sh
\fBsuspend\fRcsh、ksh88、sh
\fBswitch\fRcsh
\fBtest\fRksh88、ksh、sh
\fBtime\fRcsh
\fB*times\fRksh88、ksh、sh
\fB*+trap\fRksh88、ksh、sh
\fBtrue\fRksh88、ksh
\fBtype\fRksh88、ksh、sh
\fB++**typeset\fRksh88、ksh
\fBulimit\fRksh88、ksh、sh
\fBumask\fRcsh、ksh88、ksh、sh
\fB+unalias\fRcsh、ksh88、ksh
\fBunhash\fRcsh
\fBunlimit\fRcsh
\fB+unset\fRcsh、ksh88、ksh、sh
\fBunsetenv\fRcsh
\fBuntil\fRksh88、ksh、sh
\fBvmap\fRksh
\fBvpath\fRksh
\fB*wait\fRcsh、ksh88、ksh、sh
\fBwhence\fRksh88、ksh
\fBwhile\fRcsh、ksh88、ksh、sh
.TE

.SS "Bourne Shell、sh、特殊命令"
.sp
.LP
允许对这些命令执行输入/输出重定向。文件描述符 1 是缺省输出位置。启用 "Job Control"（作业控制）后，将向 shell 的环境添加其他\fB特殊命令\fR。
.sp
.LP
除了这些内置保留命令字，\fBsh\fR 还使用：
.sp
.ne 2
.mk
.na
\fB\fB:\fR\fR
.ad
.RS 19n
.rt  
无影响；命令不执行任何操作。返回零退出代码。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\&.\fR\fI文件名称\fR\fR
.ad
.RS 19n
.rt  
读取和执行 \fIfilename\fR 中的命令并返回。\fBPATH\fR 指定的搜索路径用于查找包含 \fIfilename\fR 的目录。
.RE

.SS "C shell、csh"
.sp
.LP
内置命令在 C shell 内执行。如果内置命令是流水线除最后一个组件之外的任意组件，则在子 shell 中执行该命令。除了这些内置保留命令字，\fBcsh\fR 还使用：
.sp
.ne 2
.mk
.na
\fB\fB:\fR\fR
.ad
.RS 5n
.rt  
空命令。此命令将被解释，但不执行任何操作。
.RE

.SS "Korn Shell、ksh88、特殊命令"
.sp
.LP
允许输入/输出重定向。除非有指示，否则输出写在文件描述符 1 上，并且如果没有语法错误，退出状态为零。
.sp
.LP
前面有一个或两个 \fB*\fR（星号）的命令专门通过以下方式进行处理：
.RS +4
.TP
1.
命令完成时，该命令前面的变量赋值列表仍然有效。
.RE
.RS +4
.TP
2.
在变量赋值后进行 \fBI/O\fR 重定向。
.RE
.RS +4
.TP
3.
脚本中包含的错误会导致其中止。
.RE
.RS +4
.TP
4.
如果字的后面是前面加有 \fB**\fR 的命令且字为变量赋值的格式，则使用与变量赋值相同的规则扩展这些字。这表示在 \fB=\fR 符号之后执行波浪号替换，并且不执行字拆分和文件名生成。
.RE
.sp
.LP
除了这些内置保留命令字，\fBksh88\fR 还使用：
.sp
.ne 2
.mk
.na
\fB* \fB:\fR [ \fIarg\fR .\|.\|. ]\fR
.ad
.RS 29n
.rt  
该命令仅扩展参数。
.RE

.sp
.ne 2
.mk
.na
\fB* \fB\&.\fR\fIfile\fR [ \fIarg\fR .\|.\|. ]\fR
.ad
.RS 29n
.rt  
读取完整的 \fIfile\fR，然后执行命令。在当前 shell 环境中执行命令。\fBPATH\fR 指定的搜索路径用于查找包含 \fIfile\fR 的目录。如果指定了任何参数 \fIarg\fR，则它们将成为位置参数。否则，将不会更改位置参数。退出状态是最后执行的命令的退出状态。循环终止测试。
.RE

.SS "Korn Shell、ksh、特殊命令"
.sp
.LP
允许输入/输出重定向。除非有指示，否则输出写在文件描述符 1 上，并且如果没有语法错误，退出状态为零。
.sp
.LP
除了 \fB:\fR、\fBtrue\fR、\fBfalse\fR、\fBecho\fR、\fBnewgrp\fR 和 \fBlogin\fR，所有内置命令均可用 \fB--\fR 来表示选项结束。它们还将选项 \fB--man\fR 解释为要显示有关标准错误的手册页的请求，将 \fB-?\fR 解释为打印有关标准错误的使用消息的请求。 
.sp
.LP
前面有一个或两个 \fB+\fR 的命令专门通过以下方式进行处理：
.RS +4
.TP
1.
命令完成时，该命令前面的变量赋值列表仍然有效。
.RE
.RS +4
.TP
2.
在变量赋值后进行 \fBI/O\fR 重定向。
.RE
.RS +4
.TP
3.
脚本中包含的错误会导致其中止。
.RE
.RS +4
.TP
4.
它们不是有效的函数名称。
.RE
.RS +4
.TP
5.
如果字的后面是前面加有 \fB++\fR 的命令且字为变量赋值的格式，则使用与变量赋值相同的规则扩展这些字。这意味着将在 \fB=\fR 符号之后执行波浪号替换，并且不执行字段分割和文件名生成。
.RE
.sp
.LP
除了这些内置保留命令字，\fBksh\fR 还使用：
.sp
.ne 2
.mk
.na
\fB\fB:\fR [ \fIarg\fR .\|.\|. ]\fR
.ad
.RS 27n
.rt  
该命令仅扩展参数。
.RE

.sp
.ne 2
.mk
.na
\fB\fB\&.\fR\fIname\fR [ \fIarg\fR .\|.\|. ]\fR
.ad
.RS 27n
.rt  
如果 \fIname\fR 是使用函数 \fIname\fR 保留字语法定义的函数，则在当前环境中执行该函数（如同使用 \fBname()\fR 语法定义了该函数一样）。否则，如果 \fIname\fR 表示一个文件，则会读取整个文件并在当前的 shell 环境中执行命令。\fBPATH\fR 指定的搜索路径用于查找包含该文件的目录。如果指定了任何参数 \fIarg\fR，则在处理 \fB\&.\fR 命令时，这些参数将成为位置参数，并且原始位置参数会在完成后恢复。否则，位置参数保持不变。退出状态是最后执行的命令的退出状态。 
.RE

.SH 另请参见
.sp
.LP
\fBIntro\fR(1)、\fBalias\fR(1)、\fBbreak\fR(1)、\fBbuiltin\fR(1)、\fBcd\fR(1)、\fBchmod\fR(1)、\fBcsh\fR(1)、\fBdisown\fR(1)、\fBecho\fR(1)、\fBexec\fR(1)、\fBexit\fR(1)、\fBfind\fR(1)、\fBgetoptcvt\fR(1)、\fBgetopts\fR(1)、\fBglob\fR(1)、\fBhash\fR(1)、\fBhistory\fR(1)、\fBjobs\fR(1)、\fBkill\fR(1)、\fBksh\fR(1)、\fBksh88\fR(1)、\fBlet\fR(1)、\fBlimit\fR(1)、\fBlogin\fR(1)、\fBlogout\fR(1)、\fBnewgrp\fR(1)、\fBnice\fR(1)、\fBnohup\fR(1)、\fBprint\fR(1)、\fBprintf\fR(1)、\fBpwd\fR(1)、\fBread\fR(1)、\fBreadonly\fR(1)、\fBset\fR(1)、\fBsh\fR(1)、\fBshift\fR(1)、\fBsleep\fR(1)、\fBsuspend\fR(1)、\fBtest\fR(1)\fBtest\fR(1)、\fBtest\fR(1B)、\fBtime\fR(1)、\fBtimes\fR(1)、\fBtrap\fR(1)、\fBtypeset\fR(1)、\fBumask\fR(1)、\fBwait\fR(1)、\fBchdir\fR(2)、\fBchmod\fR(2)、\fBcreat\fR(2)、\fBumask\fR(2)、\fBgetopt\fR(3C)、\fBprofile\fR(4)、\fBenviron\fR(5)
