'\" te
.\" Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
.TH td_thr_getgregs 3C_DB "13 Sep 2010" "SunOS 5.11" "Threads Debugging Library Functions"
.SH NAME
td_thr_getgregs, td_thr_setgregs, td_thr_getfpregs, td_thr_setfpregs, td_thr_getxregsize, td_thr_getxregs, td_thr_setxregs \- reading and writing thread registers in libc_db
.SH SYNOPSIS
.LP
.nf
cc [ \fIflag\fR... ] \fIfile\fR... -lc_db [ \fIlibrary\fR... ]
#include <proc_service.h>
#include <thread_db.h>

\fBtd_err_e\fR \fBtd_thr_getgregs\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBprgregset_t\fR\fIgregset\fR);
.fi

.LP
.nf
\fBtd_err_e\fR \fBtd_thr_setgregs\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBprgregset_t\fR\fIgregset\fR);
.fi

.LP
.nf
\fBtd_err_e\fR \fBtd_thr_getfpregs\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBprfpregset_t *\fR\fIfpregset\fR);
.fi

.LP
.nf
\fBtd_err_e\fR \fBtd_thr_setfpregs\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBprfpregset_t *\fR\fIfpregset\fR);
.fi

.LP
.nf
\fBtd_err_e\fR \fBtd_thr_getxregsize\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBint *\fR\fIxregsize\fR);
.fi

.LP
.nf
\fBtd_err_e\fR \fBtd_thr_getxregs\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBprxregset_t *\fR\fIxregset\fR);
.fi

.LP
.nf
\fBtd_err_e\fR \fBtd_thr_setxregs\fR(\fBconst td_thrhandle_t *\fR\fIth_p\fR, \fBprxregset_t *\fR\fIxregset\fR);
.fi

.SH DESCRIPTION
.sp
.LP
These functions read and write the register sets associated with thread \fIth_p\fR. The \fBtd_thr_getgregs()\fR and \fBtd_thr_setgregs()\fR functions get and set, respectively, the general registers of thread \fIth_p\fR. The \fBtd_thr_getfpregs()\fR and \fBtd_thr_setfpregs()\fR functions get and set, respectively, the thread's floating point register set. The \fBtd_thr_getxregsize()\fR, \fBtd_thr_getxregs()\fR, and \fBtd_thr_setxregs()\fR functions are system-specific. The \fBtd_thr_getxregsize()\fR function returns in *\fIxregsize\fR the size of the architecture-dependent extra state registers. The \fBtd_thr_getxregs()\fR and \fBtd_thr_setxregs()\fR functions get and set, respectively, those extra state registers. On systems that does not support extra state registers, these functions return \fBTD_NOXREGS\fR.
.sp
.LP
If the thread specified by \fIth_p\fR is currently executing on a lightweight process ( \fBLWP),\fR these functions read or write, respectively, the appropriate register set to the \fBLWP\fR using the imported interface.  If the thread is not currently executing on an \fBLWP\fR, the floating point and extra state registers may cannot be read or written. Some of the general registers might also not be readable or writable, depending on the architecture, in which case \fBtd_thr_getfpregs()\fR and \fBtd_thr_setfpregs()\fR return  \fBTD_NOFPREGS\fR and \fBtd_thr_getxregs()\fR and \fBtd_thr_setxregs()\fR will \fBTD_NOXREGS\fR. Calls to \fBtd_thr_getgregs()\fR and \fBtd_thr_setgregs()\fR succeed, but values returned for unreadable registers are undefined, values specified for unwritable registers are ignored. In this instance, and \fBTD_PARTIALREGS\fR is returned.  See the architecture-specific notes that follow regarding the registers that may be read and written for a thread not currently executing on an \fBLWP\fR.
.SS "SPARC"
.sp
.LP
On a thread not currently assigned to an \fBLWP\fR, only %i0-%i7, %l0-%l7, %g7, %pc, and %sp (%o6) can be read or written.  %pc and %sp refer to the program counter and stack pointer that the thread will have when it resumes execution.
.SS "x86 Architecture"
.sp
.LP
On a thread not currently assigned to an \fBLWP,\fR only %pc, %sp, %ebp, %edi, %edi, and %ebx can be read.
.SH RETURN VALUES
.sp
.ne 2
.mk
.na
\fB\fBTD_OK\fR\fR
.ad
.RS 18n
.rt  
The call completed successfully.
.RE

.sp
.ne 2
.mk
.na
\fB\fBTD_BADTH\fR\fR
.ad
.RS 18n
.rt  
An invalid thread handle was passed in.
.RE

.sp
.ne 2
.mk
.na
\fB\fBTD_DBERR\fR\fR
.ad
.RS 18n
.rt  
A call to one of the imported interface routines failed.
.RE

.sp
.ne 2
.mk
.na
\fB\fBTD_PARTIALREGS\fR\fR
.ad
.RS 18n
.rt  
Because the thread is not currently assigned to a \fBLWP,\fR not all registers were read or written. See \fBDESCRIPTION\fR for a discussion about which registers are not saved when a thread is not assigned to an \fBLWP\fR. 
.RE

.sp
.ne 2
.mk
.na
\fB\fBTD_NOFPREGS\fR\fR
.ad
.RS 18n
.rt  
Floating point registers could not be read or written, either because the thread is not currently assigned to an \fBLWP\fR, or because the architecture does not have such registers.
.RE

.sp
.ne 2
.mk
.na
\fB\fBTD_NOXREGS\fR\fR
.ad
.RS 18n
.rt  
System-dependent extra state registers could not be read or written, either because the thread is not currently assigned to an \fBLWP\fR, or because the architecture does not have such registers, or because the system does not have extra state registers.
.RE

.sp
.ne 2
.mk
.na
\fB\fBTD_ERR\fR\fR
.ad
.RS 18n
.rt  
A \fBlibc_db\fR internal error occurred.
.RE

.SH ATTRIBUTES
.sp
.LP
See \fBattributes\fR(5) for description of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
MT-LevelSafe
.TE

.SH SEE ALSO
.sp
.LP
\fBlibc_db\fR(3LIB), \fBattributes\fR(5) 
