'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 1996, Sun Microsystems, Inc.  All Rights Reserved.
.TH terminfo 4 "9 Jul 1996" "SunOS 5.11" "File Formats"
.SH NAME
terminfo \- terminal and printer capability database
.SH SYNOPSIS
.LP
.nf
\fB/usr/share/lib/terminfo/?/*\fR
.fi

.SH DESCRIPTION
.sp
.LP
The \fBterminfo\fR database describes the capabilities of devices such as terminals and printers. Devices are described in \fBterminfo\fR source files by specifying a set of capabilities, by quantifying certain aspects of the device, and by specifying character sequences that affect particular results. This database is often used by screen oriented applications such as \fBvi\fR and \fBcurses\fR-based programs, as well as by some system commands such as \fBls\fR and \fBmore\fR. This usage allows them to work with a variety of devices without changes to the programs.
.sp
.LP
\fBterminfo\fR descriptions are located in the directory pointed to by the environment variable \fBTERMINFO\fR or in \fB/usr/share/lib/terminfo\fR. \fBterminfo\fR descriptions are generated by \fBtic\fR(1M).
.sp
.LP
\fBterminfo\fR source files consist of one or more device descriptions. Each description consists of a header (beginning in column 1) and one or more lines that list the features for that particular device. Every line in a \fBterminfo\fR source file must end in a comma (\fB,\fR). Every line in a \fBterminfo\fR source file except the header must be indented with one or more white spaces (either spaces or tabs).
.sp
.LP
Entries in \fBterminfo\fR source files consist of a number of comma-separated fields. White space after each comma is ignored. Embedded commas must be escaped by using a backslash. Each device entry has the following format:
.sp
.in +2
.nf
\fBalias\fR1 | \fBalias\fR2 | .\|.\|. | \fBalias\fRn | \fIfullname\fR,
         capability1, \fIcapability\fR2,
         .
         .
         .
         \fIcapability\fRn,
.fi
.in -2
.sp

.sp
.LP
The first line, commonly referred to as the header line, must begin in column one and must contain at least two aliases separated by vertical bars. The last field in the header line must be the  long name of the device and it may contain any string. Alias names must be unique in the \fBterminfo\fR database and they must conform to system file naming  conventions. See \fBtic\fR(1M). They cannot, for example, contain white space or slashes.
.sp
.LP
Every device must be assigned a name, such as "vt100". Device names (except the long name) should be chosen using the following conventions. The name should not contain hyphens because hyphens are  reserved for use when adding suffixes that indicate special modes.
.sp
.LP
These special modes may be modes that the hardware can be in, or user preferences. To assign a special mode to a particular device, append a suffix consisting of a hyphen and an indicator of the mode to the device name. For example, the \fB-w\fR suffix means "wide mode". When specified, it allows for a width of 132 columns instead of the standard 80 columns. Therefore, if you want to use a "vt100" device set to wide mode, name the device "vt100-w". Use the following suffixes where possible.
.sp

.sp
.TS
tab();
lw(.21i) lw(.74i) lw(2.79i) lw(1.76i) 
lw(.21i) lw(.74i) lw(2.79i) lw(1.76i) 
.
SuffixMeaningExample
\fB-w\fRWide mode (more than 80 columns)\fB5410-w\fR
\fB-am\fRWith auto. margins (usually default)\fBvt100-am\fR
\fB-nam\fRWithout automatic margins\fBvt100-nam\fR
\fI-n\fRNumber of lines on the screen\fB2300-40\fR
\fB-na\fRNo arrow keys (leave them in local)\fBc100-na\fR
-\fIn\fRpNumber of pages of memory\fBc100-4p\fR
\fB-rv\fRReverse video\fB4415-rv\fR
.TE

.sp
.LP
The \fBterminfo\fR reference manual page is organized in two sections:
.RS +4
.TP
.ie t \(bu
.el o
\fBPART 1: DEVICE CAPABILITIES\fR
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fBPART 2: PRINTER CAPABILITIES\fR
.RE
.SS "PART 1: DEVICE CAPABILITIES"
.sp
.LP
Capabilities in \fBterminfo\fR are of three types:  Boolean capabilities (which show that a device has or does not have a particular feature), numeric capabilities (which quantify particular features of a device), and string capabilities (which provide sequences that can be used to perform particular operations on devices).
.sp
.LP
In the following table, a \fBVariable\fR is the name by which a \fBC\fR programmer accesses a capability (at the \fBterminfo\fR level). A \fBCapname\fR is the short name for a capability specified in the \fBterminfo\fR source file. It is used by a person updating the source file and by the \fBtput\fR command. A \fBTermcap Code\fR is a two-letter sequence that corresponds to the \fBtermcap\fR capability name. (Note that \fBtermcap\fR is no longer supported.)
.sp
.LP
Capability names have no real length limit, but an informal limit of five characters has been adopted to keep them short. Whenever possible, capability names are chosen to be the same as or similar to those specified by the ANSI X3.64-1979 standard. Semantics are also intended to match those of the ANSI standard.
.sp
.LP
All string capabilities listed below may have padding specified, with the exception of those used for input. Input capabilities, listed under the \fBStrings\fR section in the following tables, have names beginning with \fBkey_\fR. The \fB#i\fR symbol in the description field of the following tables refers to the \fIi\fRth parameter.
.SS "Booleans"
.sp
.in +2
.nf
________________________________________________________________
                          Cap-   Termcap
Variable                  name   Code     Description
________________________________________________________________
 
auto_left_margin          bw     bw       cub1 wraps from column 0 to
                                          last column
auto_right_margin         am     am       Terminal has automatic margins
back_color_erase          bce    be       Screen erased with background
                                          color
can_change                ccc    cc       Terminal can re-define existing
                                          color
ceol_standout_glitch      xhp    xs       Standout not erased by
                                          overwriting (hp)
col_addr_glitch           xhpa   YA       Only positive motion
                                          for hpa/mhpa caps
cpi_changes_res           cpix   YF       Changing character pitch
                                          changes resolution
cr_cancels_micro_mode     crxm   YB       Using cr turns off micro mode
dest_tabs_magic_smso      xt     xt       Destructive tabs, magic
                                          smso char (t1061)
eat_newline_glitch        xenl   xn       Newline ignored after
                                          80 columns (Concept)
erase_overstrike          eo     eo       Can erase overstrikes with a
                                          blank
generic_type              gn     gn       Generic line type
                                          (for example, dialup, switch)
hard_copy                 hc     hc       Hardcopy terminal
hard_cursor               chts   HC       Cursor is hard to see
has_meta_key              km     km       Has a meta key (shift,
                                          sets parity bit)
has_print_wheel           daisy  YC       Printer needs operator
                                          to change character set
has_status_line           hs     hs       Has extra "status line"
hue_lightness_saturation  hls    hl       Terminal uses only HLS
                                          color notation (Tektronix)
insert_null_glitch        in     in       Insert mode distinguishes nulls
lpi_changes_res           lpix   YG       Changing line pitch
                                          changes resolution
memory_above              da     da       Display may be retained
                                          above the screen
memory_below              db     db       Display may be retained
                                          below the screen
move_insert_mode          mir    mi       Safe to move while in insert
                                          mode
move_standout_mode        msgr   ms       Safe to move in standout modes
needs_xon_xoff            nxon   nx       Padding won't work,
                                          xon/xoff required
no_esc_ctlc               xsb    xb       Beehive (f1=escape, f2=ctrl C)
no_pad_char               npc    NP       Pad character doesn't exist
non_dest_scroll_region    ndscr  ND       Scrolling region
                                          is nondestructive
non_rev_rmcup             nrrmc  NR       smcup does not reverse rmcup
over_strike               os     os       Terminal overstrikes
                                          on hard-copy terminal
prtr_silent               mc5i   5i       Printer won't echo on screen
row_addr_glitch           xvpa   YD       Only positive motion
                                          for vpa/mvpa caps
semi_auto_right_margin    sam    YE       Printing in last column causes
                                          cr
status_line_esc_ok        eslok  es       Escape can be used on
                                          the status line
tilde_glitch              hz     hz       Hazeltine; can't print tilde (~)
transparent_underline     ul     ul       Underline character overstrikes
xon_xoff                  xon    xo       Terminal uses xon/xoff 
                                          handshaking                                  
.fi
.in -2
.sp

.SS "Numbers"
.sp
.in +2
.nf
________________________________________________________________
                      Cap-    Termcap
Variable              name    Code     Description
________________________________________________________________
 
bit_image_entwining   bitwin  Yo       Number of passes for each
                                       bit-map row
bit_image_type        bitype  Yp       Type of bit image device
buffer_capacity       bufsz   Ya       Number of bytes buffered
                                       before printing
buttons               btns    BT       Number of buttons on the mouse
columns               cols    co       Number of columns in a line
dot_horz_spacing      spinh   Yc       Spacing of dots horizontally
                                       in dots per inch
dot_vert_spacing      spinv   Yb       Spacing of pins vertically
                                       in pins per inch
init_tabs             it      it       Tabs initially every # spaces
label_height          lh      lh       Number of rows in each label
label_width           lw      lw       Number of columns in each label
lines                 lines   li       Number of lines on a screen or
                                       a page
lines_of_memory       lm      lm       Lines of memory if > lines;
                                       0 means varies
max_attributes        ma      ma       Maximum combined video attributes
                                       terminal can display
magic_cookie_glitch   xmc     sg       Number of blank characters
                                       left by smso or rmso
max_colors            colors  Co       Maximum number of colors
                                       on the screen
max_micro_address     maddr   Yd       Maximum value in
                                       micro_..._address
max_micro_jump        mjump   Ye       Maximum value in parm_..._micro
max_pairs             pairs   pa       Maximum number of
                                       color-pairs on the screen
maximum_windows       Wnum    MW       Maximum number of definable windows
micro_char_size       mcs     Yf       Character step size when
                                       in micro mode
micro_line_size       mls     Yg       Line step size when in micro mode
no_color_video        ncv     NC       Video attributes that
                                       can't be used with colors
num_labels            nlab    Nl       Number of labels on screen
number_of_pins        npins   Yh       Number of pins in print-head
output_res_char       orc     Yi       Horizontal resolution in
                                       units per character
output_res_line       orl     Yj       Vertical resolution in units per
                                       line
output_res_horz_inch  orhi    Yk       Horizontal resolution in
                                       units per inch
output_res_vert_inch  orvi    Yl       Vertical resolution in
                                       units per inch
padding_baud_rate     pb      pb       Lowest baud rate
print_rate            cps     Ym       Print rate in characters per second
                                       where padding needed
virtual_terminal      vt      vt       Virtual terminal number (system)
wide_char_size        widcs   Yn       Character step size when
                                       in double wide mode
width_status_line     wsl     ws       Number of columns in status line
.fi
.in -2
.sp

.SS "Strings"
.sp
.in +2
.nf
________________________________________________________________
                           Cap-   Termcap
Variable                   name   Code     Description
________________________________________________________________
 
acs_chars                  acsc   ac       Graphic charset pairs aAbBcC
alt_scancode_esc           scesa  S8       Alternate escape for
                                           scancode emulation
                                           (default is for vt100)
back_tab                   cbt    bt       Back tab
bell                       bel    bl       Audible signal (bell)
bit_image_carriage_return  bicr   Yv       Move to beginning of
                                           same row (use tparm)
bit_image_newline          binel  Zz       Move to next row of
                                           the bit image (use tparm)
bit_image_repeat           birep  Zy       Repeat bit-image cell
                                           #1 #2 times (use tparm)
carriage_return            cr     cr       Carriage return
change_char_pitch          cpi    ZA       Change number of
                                           characters per inch
change_line_pitch          lpi    ZB       Change number of lines per inch
change_res_horz            chr    ZC       Change horizontal resolution
change_res_vert            cvr    ZD       Change vertical resolution
change_scroll_region       csr    cs       Change to lines #1
                                           through #2 (vt100)
char_padding               rmp    rP       Like ip but when in replace
                                           mode
char_set_names             csnm   Zy       List of character set names
clear_all_tabs             tbc    ct       Clear all tab stops
clear_margins              mgc    MC       Clear all margins
                                           (top, bottom, and sides)
clear_screen               clear  cl       Clear screen and home cursor
clr_bol                    el1    cb       Clear to beginning of
                                           line, inclusive
clr_eol                    el     ce       Clear to end of line
clr_eos                    ed     cd       Clear to end of display
code_set_init              csin   ci       Init sequence
                                           for multiple codesets
color_names                colornm  Yw     Give name for color #1
column_address             hpa    ch       Horizontal position
command_character          cmdch  CC       Terminal settable cmd
                                           character in prototype
create_window              cwin   CW       Define win #1 to go
                                           from #2,#3to #4,#5
cursor_address             cup    cm       Move to row #1 col #2
cursor_down                cud1   do       Down one line
cursor_home                home   ho       Home cursor (if no cup)
cursor_invisible           civis  vi       Make cursor invisible
cursor_left                cub1   le       Move left one space.
cursor_mem_address         mrcup  CM       Memory relative cursor
                                           addressing
cursor_normal              cnorm  ve       Make cursor appear
                                           normal (undo vs/vi)
cursor_right               cuf1   nd       Non-destructive space
                                           (cursor or carriage right)
cursor_to_ll               ll     ll       Last line, first
                                           column (if no cup)
cursor_up                  cuu1   up       Upline (cursor up)
cursor_visible             cvvis  vs       Make cursor very visible
define_bit_image_region    defbi  Yx       Define rectangular bit-
                                           image region (use tparm)
define_char                defc   ZE       Define a character in
                                           a character set
delete_character           dch1   dc       Delete character
delete_line                dl1    dl       Delete line
device_type                devt   dv       Indicate language/
                                           codeset support
dial_phone                 dial   DI       Dial phone number #1
dis_status_line            dsl    ds       Disable status line
display_clock              dclk   DK       Display time-of-day clock
display_pc_char            dispc  S1       Display PC character
down_half_line             hd     hd       Half-line down (forward
                                           1/2 linefeed)
ena_acs                    enacs  eA       Enable alternate character set
end_bit_image_region       endbi  Yy       End a bit-image region
                                           (use tparm)
enter_alt_charset_mode     smacs  as       Start alternate character set
enter_am_mode              smam   SA       Turn on automatic margins
enter_blink_mode           blink  mb       Turn on blinking
enter_bold_mode            bold   md       Turn on bold (extra
                                           bright) mode
enter_ca_mode              smcup  ti       String to begin programs
                                           that use cup
enter_delete_mode          smdc   dm       Delete mode (enter)
enter_dim_mode             dim    mh       Turn on half-bright mode
enter_doublewide_mode      swidm  ZF       Enable double wide printing
enter_draft_quality        sdrfq  ZG       Set draft quality print mode
enter_insert_mode          smir   im       Insert mode (enter)
enter_italics_mode         sitm   ZH       Enable italics
enter_leftward_mode        slm    ZI       Enable leftward carriage
                                           motion
enter_micro_mode           smicm  ZJ       Enable micro motion
                                           capabilities
enter_near_letter_quality  snlq   ZK       Set near-letter quality print
enter_normal_quality       snrmq  ZL       Set normal quality
enter_pc_charset_mode      smpch  S2       Enter PC character display mode
enter_protected_mode       prot   mp       Turn on protected mode
enter_reverse_mode         rev    mr       Turn on reverse video mode
enter_scancode_mode        smsc   S4       Enter PC scancode mode
enter_scancode_mode        smsc   S4       Enter PC scancode mode
enter_secure_mode          invis  mk       Turn on blank mode
                                           (characters invisible)
enter_shadow_mode          sshm   ZM       Enable shadow printing
enter_standout_mode        smso   so       Begin standout mode
enter_subscript_mode       ssubm  ZN       Enable subscript printing
enter_superscript_mode     ssupm  ZO       Enable superscript printing
enter_underline_mode       smul   us       Start underscore mode
enter_upward_mode          sum    ZP       Enable upward carriage motion
                                           mode
enter_xon_mode             smxon  SX       Turn on xon/xoff handshaking
erase_chars                ech    ec       Erase #1 characters
exit_alt_charset_mode      rmacs  ae       End alternate character set
exit_am_mode               rmam   RA       Turn off automatic margins
exit_attribute_mode        sgr0   me       Turn off all attributes
exit_ca_mode               rmcup  te       String to end programs
                                           that use cup
exit_delete_mode           rmdc   ed       End delete mode
exit_doublewide_mode       rwidm  ZQ       Disable double wide printing
exit_insert_mode           rmir   ei       End insert mode
exit_italics_mode          ritm   ZR       Disable italics
exit_leftward_mode         rlm    ZS       Enable rightward (normal)
                                           carriage motion
exit_micro_mode            rmicm  ZT       Disable micro motion
                                           capabilities
exit_pc_charset_mode       rmpch  S3       Disable PC character
                                           display mode
exit_scancode_mode         rmsc   S5       Disable PC scancode mode
exit_shadow_mode           rshm   ZU       Disable shadow printing
exit_standout_mode         rmso   se       End standout mode
exit_subscript_mode        rsubm  ZV       Disable subscript printing
exit_superscript_mode      rsupm  ZW       Disable superscript printing
exit_underline_mode        rmul   ue       End underscore mode
exit_upward_mode           rum    ZX       Enable downward (normal)
                                           carriage motion
exit_xon_mode              rmxon  RX       Turn off xon/xoff handshaking
fixed_pause                pause  PA       Pause for 2-3 seconds
flash_hook                 hook   fh       Flash the switch hook
flash_screen               flash  vb       Visible bell (may
                                           not move cursor)
form_feed                  ff     ff       Hardcopy terminal page eject
from_status_line           fsl    fs       Return from status line
get_mouse                  getm   Gm       Curses should get button events
goto_window                wingo  WG       Go to window #1
hangup                     hup    HU       Hang-up phone
init_1string               is1    i1       Terminal or printer
                                           initialization string
init_2string               is2    is       Terminal or printer
                                           initialization string
init_3string               is3    i3       Terminal or printer
                                           initialization string
init_file                  if     if       Name of initialization file
init_prog                  iprog  iP       Path name of program
                                           for initialization
initialize_color           initc  Ic       Initialize the
                                           definition of color
initialize_pair            initp  Ip       Initialize color-pair
insert_character           ich1   ic       Insert character
insert_line                il1    al       Add new blank line
insert_padding             ip     ip       Insert pad after
                                           character inserted
.fi
.in -2
.sp

.SS "key_Strings"
.sp
.LP
The ``\fBkey_\fR'' strings are sent by specific keys. The ``\fBkey_\fR'' descriptions include the macro, defined in \fB<curses.h>\fR, for the code returned by the \fBcurses\fR routine \fBgetch\fR when the key is pressed (see \fBcurs_getch\fR(3CURSES)).
.sp
.in +2
.nf
________________________________________________________________
                        Cap-    Termcap
Variable                name    Code     Description
________________________________________________________________

key_a1                  ka1     K1       KEY_A1, upper left of keypad
key_a3                  ka3     K3       KEY_A3, upper right of keypad
key_b2                  kb2     K2       KEY_B2, center of keypad
key_backspace           kbs     kb       KEY_BACKSPACE, sent by
                                         backspace key
key_beg                 kbeg    @1       KEY_BEG, sent by beg(inning) key
key_btab                kcbt    kB       KEY_BTAB, sent by back-tab key
key_c1                  kc1     K4       KEY_C1, lower left of keypad
key_c3                  kc3     K5       KEY_C3, lower right of keypad
key_cancel              kcan    @2       KEY_CANCEL, sent by cancel key
key_catab               ktbc    ka       KEY_CATAB, sent by
                                         clear-all-tabs key
key_clear               kclr    kC       KEY_CLEAR, sent by
                                         clear-screen or erase key
key_close               kclo    @3       KEY_CLOSE, sent by close key
key_command             kcmd    @4       KEY_COMMAND, sent by
                                         cmd (command) key
key_copy                kcpy    @5       KEY_COPY, sent by copy key
key_create              kcrt    @6       KEY_CREATE, sent by create key
key_ctab                kctab   kt       KEY_CTAB, sent by clear-tab key
key_dc                  kdch1   kD       KEY_DC, sent by delete-character
                                         key
key_dl                  kdl1    kL       KEY_DL, sent by delete-line key
key_down                kcud1   kd       KEY_DOWN, sent by terminal
                                         down-arrow key
key_eic                 krmir   kM       KEY_EIC, sent by rmir or smir in
                                         insert mode
key_end                 kend    @7       KEY_END, sent by end key
key_enter               kent    @8       KEY_ENTER, sent by enter/send
                                         key
key_eol                 kel     kE       KEY_EOL, sent by
                                         clear-to-end-of-line key
key_eos                 ked     kS       KEY_EOS, sent by
                                         clear-to-end-of-screen key
key_exit                kext    @9       KEY_EXIT, sent by exit key
key_f0                  kf0     k0       KEY_F(0), sent by function key f0
key_f1                  kf1     k1       KEY_F(1), sent by function key f1
key_f2                  kf2     k2       KEY_F(2), sent by function key f2
key_f3                  kf3     k3       KEY_F(3), sent by function key f3
key_fB                  kf4     k4       KEY_F(4), sent by function key fB
key_f5                  kf5     k5       KEY_F(5), sent by function key f5
key_f6                  kf6     k6       KEY_F(6), sent by function key f6
key_f7                  kf7     k7       KEY_F(7), sent by function key f7
key_f8                  kf8     k8       KEY_F(8), sent by function key f8
key_f9                  kf9     k9       KEY_F(9), sent by function key f9

key_f10                 kf10    k;       KEY_F(10), sent by function key
                                         f10
key_f11                 kf11    F1       KEY_F(11), sent by function key 
                                         f11
key_f12                 kf12    F2       KEY_F(12), sent by function key 
                                         f12
key_f13                 kf13    F3       KEY_F(13), sent by function key
                                         f13
key_f14                 kf14    F4       KEY_F(14), sent by function key
                                         f14
key_f15                 kf15    F5       KEY_F(15), sent by function key
                                         f15
key_f16                 kf16    F6       KEY_F(16), sent by function key
                                         f16
key_f17                 kf17    F7       KEY_F(17), sent by function key
                                         f17
key_f18                 kf18    F8       KEY_F(18), sent by function key
                                         f18
key_f19                 kf19    F9       KEY_F(19), sent by function key
                                         f19
key_f20                 kf20    FA       KEY_F(20), sent by function key
                                         f20
key_f21                 kf21    FB       KEY_F(21), sent by function key
                                         f21
key_f22                 kf22    FC       KEY_F(22), sent by function key 
                                         f22
key_f23                 kf23    FD       KEY_F(23), sent by function key
                                         f23
key_f24                 kf24    FE       KEY_F(24), sent by function key
                                         f24
key_f25                 kf25    FF       KEY_F(25), sent by function key
                                         f25
key_f26                 kf26    FG       KEY_F(26), sent by function key
                                         f26
key_f27                 kf27    FH       KEY_F(27), sent by function key
                                         f27
key_f28                 kf28    FI       KEY_F(28), sent by function key
                                         f28
key_f29                 kf29    FJ       KEY_F(29), sent by function key
                                         f29
key_f30                 kf30    FK       KEY_F(30), sent by function key
                                         f30
key_f31                 kf31    FL       KEY_F(31), sent by function key
                                         f31
key_f32                 kf32    FM       KEY_F(32), sent by function key
                                         f32
key_f33                 kf33    FN       KEY_F(13), sent by function key
                                         f13
key_f34                 kf34    FO       KEY_F(34), sent by function key
                                         f34
key_f35                 kf35    FP       KEY_F(35), sent by function key
                                         f35
key_f36                 kf36    FQ       KEY_F(36), sent by function key
                                         f36
key_f37                 kf37    FR       KEY_F(37), sent by function key
                                         f37
key_f38                 kf38    FS       KEY_F(38), sent by function key
                                         f38
key_f39                 kf39    FT       KEY_F(39), sent by function key
                                         f39
key_fB0                 kf40    FU       KEY_F(40), sent by function key
                                         fB0
key_fB1                 kf41    FV       KEY_F(41), sent by function key
                                         fB1
key_fB2                 kf42    FW       KEY_F(42), sent by function key
                                         fB2
key_fB3                 kf43    FX       KEY_F(43), sent by function key
                                         fB3
key_fB4                 kf44    FY       KEY_F(44), sent by function key
                                         fB4
key_fB5                 kf45    FZ       KEY_F(45), sent by function key
                                         fB5
key_fB6                 kf46    Fa       KEY_F(46), sent by function key
                                         fB6
key_fB7                 kf47    Fb       KEY_F(47), sent by function key
                                         fB7
key_fB8                 kf48    Fc       KEY_F(48), sent by function key
                                         fB8
key_fB9                 kf49    Fd       KEY_F(49), sent by function key
                                         fB9
key_f50                 kf50    Fe       KEY_F(50), sent by function key
                                         f50
key_f51                 kf51    Ff       KEY_F(51), sent by function key
                                         f51
key_f52                 kf52    Fg       KEY_F(52), sent by function key
                                         f52
key_f53                 kf53    Fh       KEY_F(53), sent by function key
                                         f53
key_f54                 kf54    Fi       KEY_F(54), sent by function key
                                         f54
key_f55                 kf55    Fj       KEY_F(55), sent by function key
                                         f55
key_f56                 kf56    Fk       KEY_F(56), sent by function key
                                         f56
key_f57                 kf57    Fl       KEY_F(57), sent by function key
                                         f57
key_f58                 kf58    Fm       KEY_F(58), sent by function key
                                         f58
key_f59                 kf59    Fn       KEY_F(59), sent by function key
                                         f59
key_f60                 kf60    Fo       KEY_F(60), sent by function key
                                         f60
key_f61                 kf61    Fp       KEY_F(61), sent by function key
                                         f61
key_f62                 kf62    Fq       KEY_F(62), sent by function key
                                         f62
key_f63                 kf63    Fr       KEY_F(63), sent by function key
                                         f63
key_find                kfnd    @0       KEY_FIND, sent by find key
key_help                khlp    %1       KEY_HELP, sent by help key
key_home                khome   kh       KEY_HOME, sent by home key
key_ic                  kich1   kI       KEY_IC, sent by ins-char/enter
                                         ins-mode key
key_il                  kil1    kA       KEY_IL, sent by insert-line key
key_left                kcub1   kl       KEY_LEFT, sent by
                                         terminal left-arrow key
key_ll                  kll     kH       KEY_LL, sent by home-down key
key_mark                kmrk    %2       KEY_MARK, sent by
key_message             kmsg    %3       KEY_MESSAGE, sent by message key
key_mouse               kmous   Km       0631, Mouse event has occured
key_move                kmov    %4       KEY_MOVE, sent by move key
key_next                knxt    %5       KEY_NEXT, sent by next-object
                                         key
key_npage               knp     kN       KEY_NPAGE, sent by next-page
                                         key
key_open                kopn    %6       KEY_OPEN, sent by open key
key_options             kopt    %7       KEY_OPTIONS, sent by options
                                         key
key_ppage               kpp     kP       KEY_PPAGE, sent by
                                         previous-page key
key_previous            kprv    %8       KEY_PREVIOUS, sent by
                                         previous-object key
key_print               kprt    %9       KEY_PRINT, sent by
                                         print or copy key
key_redo                krdo    %0       KEY_REDO, sent by redo key
key_reference           kref    &1       KEY_REFERENCE, sent by
                                         reference key
key_refresh             krfr    &2       KEY_REFRESH, sent by
                                         refresh key
key_replace             krpl    &3       KEY_REPLACE, sent by
                                         replace key
key_restart             krst    &4       KEY_RESTART, sent by
                                         restart key
key_resume              kres    &5       KEY_RESUME, sent by resume key
key_right               kcuf1   kr       KEY_RIGHT, sent by terminal
                                         right-arrow key
key_save                ksav    &6       KEY_SAVE, sent by save key
key_sbeg                kBEG    &9       KEY_SBEG, sent by
                                         shifted beginning key
key_scancel             kCAN    &0       KEY_SCANCEL, sent by
                                         shifted cancel key
key_scommand            kCMD    *1       KEY_SCOMMAND, sent by
                                         shifted command key
key_scopy               kCPY    *2       KEY_SCOPY, sent by
                                         shifted copy key
key_screate             kCRT    *3       KEY_SCREATE, sent by
                                         shifted create key
key_sdc                 kDC     *4       KEY_SDC, sent by
                                         shifted delete-char key
key_sdl                 kDL     *5       KEY_SDL, sent by
                                         shifted delete-line key
key_select              kslt    *6       KEY_SELECT, sent by
                                         select key
key_send                kEND    *7       KEY_SEND, sent by
                                         shifted end key
key_seol                kEOL    *8       KEY_SEOL, sent by
                                         shifted clear-line key
key_sexit               kEXT    *9       KEY_SEXIT, sent by
                                         shifted exit key
key_sf                  kind    kF       KEY_SF, sent by
                                         scroll-forward/down key
key_sfind               kFND    *0       KEY_SFIND, sent by
                                         shifted find key
key_shelp               kHLP    #1       KEY_SHELP, sent by
                                         shifted help key
key_shome               kHOM    #2       KEY_SHOME, sent by
                                         shifted home key
key_sic                 kIC     #3       KEY_SIC, sent by
                                         shifted input key
key_sleft               kLFT    #4       KEY_SLEFT, sent by
                                         shifted left-arrow key
key_smessage            kMSG    %a       KEY_SMESSAGE, sent by
                                         shifted message key
key_smove               kMOV    %b       KEY_SMOVE, sent by
                                         shifted move key
key_snext               kNXT    %c       KEY_SNEXT, sent by
                                         shifted next key
key_soptions            kOPT    %d       KEY_SOPTIONS, sent by
                                         shifted options key
key_sprevious           kPRV    %e       KEY_SPREVIOUS, sent by
                                         shifted prev key
key_sprint              kPRT    %f       KEY_SPRINT, sent by
                                         shifted print key
key_sr                  kri     kR       KEY_SR, sent by
                                         scroll-backward/up key
key_sredo               kRDO    %g       KEY_SREDO, sent by
                                         shifted redo key
key_sreplace            kRPL    %h       KEY_SREPLACE, sent by
                                         shifted replace key
key_sright              kRIT    %i       KEY_SRIGHT, sent by shifted
                                         right-arrow key
key_srsume              kRES    %j       KEY_SRSUME, sent by
                                         shifted resume key
key_ssave               kSAV    !1       KEY_SSAVE, sent by
                                         shifted save key
key_ssuspend            kSPD    !2       KEY_SSUSPEND, sent by
                                         shifted suspend key
key_stab                khts    kT       KEY_STAB, sent by
                                         set-tab key
key_sundo               kUND    !3       KEY_SUNDO, sent by
                                         shifted undo key
key_suspend             kspd    &7       KEY_SUSPEND, sent by
                                         suspend key
key_undo                kund    &8       KEY_UNDO, sent by undo key
key_up                  kcuu1   ku       KEY_UP, sent by
                                         terminal up-arrow key
keypad_local            rmkx    ke       Out of
                                         ``keypad-transmit'' mode
keypad_xmit             smkx    ks       Put terminal in
                                         ``keypad-transmit'' mode
lab_f0                  lf0     l0       Labels on function key
                                         f0 if not f0
lab_f1                  lf1     l1       Labels on function key
                                         f1 if not f1
lab_f2                  lf2     l2       Labels on function key
                                         f2 if not f2
lab_f3                  lf3     l3       Labels on function key
                                         f3 if not f3
lab_fB                  lfB     l4       Labels on function key
                                         fB if not fB
lab_f5                  lf5     l5       Labels on function key
                                         f5 if not f5
lab_f6                  lf6     l6       Labels on function key
                                         f6 if not f6
lab_f7                  lf7     l7       Labels on function key
                                         f7 if not f7
lab_f8                  lf8     l8       Labels on function key
                                         f8 if not f8
lab_f9                  lf9     l9       Labels on function key
                                         f9 if not f9
lab_f10                 lf10    la       Labels on function key
                                         f10 if not f10
label_format            fln     Lf       Label format
label_off               rmln    LF       Turn off soft labels
label_on                smln    LO       Turn on soft labels
meta_off                rmm     mo       Turn off "meta mode"
meta_on                 smm     mm       Turn on "meta mode" (8th bit)
micro_column_address    mhpa    ZY       Like column_address
                                         for micro adjustment
micro_down              mcud1   ZZ       Like cursor_down
                                         for micro adjustment
micro_left              mcub1   Za       Like cursor_left
                                         for micro adjustment
micro_right             mcuf1   Zb       Like cursor_right
                                         for micro adjustment
micro_row_address       mvpa    Zc       Like row_address
                                         for micro adjustment
micro_up                mcuu1   Zd       Like cursor_up
                                         for micro adjustment
mouse_info              minfo   Mi       Mouse status information
newline                 nel     nw       Newline (behaves like
                                         cr followed by lf)
order_of_pins           porder  Ze       Matches software bits
                                         to print-head pins
orig_colors             oc      oc       Set all color(-pair)s
                                         to the original ones
orig_pair               op      op       Set default color-pair
                                         to the original one
pad_char                pad     pc       Pad character (rather than null)
parm_dch                dch     DC       Delete #1 chars
parm_delete_line        dl      DL       Delete #1 lines
parm_down_cursor        cud     DO       Move down #1 lines
parm_down_micro         mcud    Zf       Like parm_down_cursor
                                         for micro adjust
parm_ich                ich     IC       Insert #1 blank chars
parm_index              indn    SF       Scroll forward #1 lines
parm_insert_line        il      AL       Add #1 new blank lines
parm_left_cursor        cub     LE       Move cursor left #1 spaces
parm_left_micro         mcub    Zg       Like parm_left_cursor
                                         for micro adjust
parm_right_cursor       cuf     RI       Move right #1 spaces
parm_right_micro        mcuf    Zh       Like parm_right_cursor
                                         for micro adjust
parm_rindex             rin     SR       Scroll backward #1 lines
parm_up_cursor          cuu     UP       Move cursor up #1 lines
parm_up_micro           mcuu    Zi       Like parm_up_cursor
                                         for micro adjust
pc_term_options         pctrm   S6       PC terminal options
pkey_key                pfkey   pk       Prog funct key #1 to
                                         type string #2
pkey_local              pfloc   pl       Prog funct key #1 to
                                         execute string #2
pkey_plab               pfxl    xl       Prog key #1 to xmit
                                         string #2 and show string #3
pkey_xmit               pfx     px       Prog funct key #1 to
                                         xmit string #2
plab_norm               pln     pn       Prog label #1 to show
                                         string #2
print_screen            mc0     ps       Print contents of the screen
prtr_non                mc5p    pO       Turn on the printer for #1 bytes
prtr_off                mc4     pf       Turn off the printer
prtr_on                 mc5     po       Turn on the printer
pulse                   pulse   PU       Select pulse dialing
quick_dial              qdial   QD       Dial phone number #1, without
                                         progress detection
remove_clock            rmclk   RC       Remove time-of-day clock
repeat_char             rep     rp       Repeat char #1 #2 times
req_for_input           rfi     RF       Send next input char (for ptys)
req_mouse_pos           reqmp   RQ       Request mouse position report
reset_1string           rs1     r1       Reset terminal completely to
                                         sane modes
reset_2string           rs2     r2       Reset terminal completely to
                                         sane modes
reset_3string           rs3     r3       Reset terminal completely to
                                         sane modes
reset_file              rf      rf       Name of file containing
                                         reset string
restore_cursor          rc      rc       Restore cursor to
                                         position of last sc
row_address             vpa     cv       Vertical position absolute
save_cursor             sc      sc       Save cursor position
scancode_escape         scesc   S7       Escape for scancode emulation
scroll_forward          ind     sf       Scroll text up
scroll_reverse          ri      sr       Scroll text down
select_char_set         scs     Zj       Select character set
set0_des_seq            s0ds    s0       Shift into codeset 0
                                         (EUC set 0, ASCII)
set1_des_seq            s1ds    s1       Shift into codeset 1
set2_des_seq            s2ds    s2       Shift into codeset 2
set3_des_seq            s3ds    s3       Shift into codeset 3
                                         attributes #1-#6
set_a_background        setab   AB       Set background color
                                         using ANSI escape
set_a_foreground        setaf   AF       Set foreground color
                                         using ANSI escape
set_attributes          sgr     sa       Define the video
                                         attributes #1-#9
set_background          setb    Sb       Set current background color
set_bottom_margin       smgb    Zk       Set bottom margin at
                                         current line
set_bottom_margin_parm  smgbp   Zl       Set bottom margin at
                                         line #1 or #2
                                         lines from bottom
set_clock               sclk    SC       Set time-of-day clock
set_color_band          setcolor         YzChange to ribbon color #1
set_color_pair          scp     sp       Set current color-pair
set_foreground          setf    Sf       Set current foreground color1
set_left_margin         smgl    ML       Set left margin at current line
set_left_margin_parm    smglp   Zm       Set left (right) margin
                                         at column #1 (#2)
set_lr_margin           smglr   ML       Sets both left and right margins
set_page_length         slines  YZ       Set page length to #1 lines 
                                         (use tparm) of an inch
set_right_margin        smgr    MR       Set right margin at
                                         current column
set_right_margin_parm   smgrp   Zn       Set right margin at column #1
set_tab                 hts     st       Set a tab in all rows,
                                         current column
set_tb_margin           smgtb   MT       Sets both top and bottom margins
set_top_margin          smgt    Zo       Set top margin at current line
set_top_margin_parm     smgtp   Zp       Set top (bottom) margin
                                         at line #1 (#2)
set_window              wind    wi       Current window is lines
                                         #1-#2 cols #3-#4
start_bit_image         sbim    Zq       Start printing bit image graphics
start_char_set_def      scsd    Zr       Start definition of a character
                                         set
stop_bit_image          rbim    Zs       End printing bit image graphics
stop_char_set_def       rcsd    Zt       End definition of a character set
subscript_characters    subcs   Zu       List of ``subscript-able''
                                         characters
superscript_characters  supcs   Zv       List of ``superscript-able''
                                         characters
tab                     ht      ta       Tab to next 8-space hardware tab
                                         stop
these_cause_cr          docr    Zw       Printing any of these
                                         chars causes cr
to_status_line          tsl     ts       Go to status line, col #1
tone                    tone    TO       Select touch tone dialing
user0                   u0      u0       User string 0
user1                   u1      u1       User string 1
user2                   u2      u2       User string 2
user3                   u3      u3       User string 3
user4                   u4      u4       User string 4
user5                   u5      u5       User string 5
user6                   u6      u6       User string 6
user7                   u7      u7       User string 7
user8                   u8      u8       User string 8
user9                   u9      u9       User string 9
underline_char          uc      uc       Underscore one char
                                         and move past it
up_half_line            hu      hu       Half-line up (reverse
                                         1/2 linefeed)
wait_tone               wait    WA       Wait for dial tone
xoff_character          xoffc   XF       X-off character
xon_character           xonc    XN       X-on character
zero_motion             zerom   Zx       No motion for the
                                         subsequent character
.fi
.in -2
.sp

.SS "Sample Entry"
.sp
.LP
The following entry, which describes the AT&T 610 terminal, is among the more complex entries in the \fBterminfo\fR file as of this writing.
.sp
.in +2
.nf
610|610bct|ATT610|att610|AT&T610;80column;98key keyboard
   am, eslok, hs, mir, msgr, xenl, xon,
   cols#80, it#8, lh#2, lines#24, lw#8, nlab#8, wsl#80,
   acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
   bel=^G, blink=\eE[5m, bold=\eE[1m, cbt=\eE[Z,
   civis=\eE[?25l, clear=\eE[H\eE[J, cnorm=\eE[?25h\eE[?12l,
   cr=\er, csr=\eE[%i%p1%d;%p2%dr, cub=\eE[%p1%dD, cub1=\eb,
   cud=\eE[%p1%dB, cud1=\eE[B, cuf=\eE[%p1%dC, cuf1=\eE[C,
   cup=\eE[%i%p1%d;%p2%dH, cuu=\eE[%p1%dA, cuu1=\eE[A,
   cvvis=\eE[?12;25h, dch=\eE[%p1%dP, dch1=\eE[P, dim=\eE[2m,
   dl=\eE[%p1%dM, dl1=\eE[M, ed=\eE[J, el=\eE[K, el1=\eE[1K,
   flash=\eE[?5h$<200>\eE[?5l, fsl=\eE8, home=\eE[H, ht=\et,
   ich=\eE[%p1%d@, il=\eE[%p1%dL, il1=\eE[L, ind=\eED, .ind=\eED$<9>,
   invis=\eE[8m,
   is1=\eE[8;0 | \eE[?3;4;5;13;15l\eE[13;20l\eE[?7h\eE[12h\eE(B\eE)0,
   is2=\eE[0m^O, is3=\eE(B\eE)0, kLFT=\eE[\es@, kRIT=\eE[\esA,
   kbs=^H, kcbt=\eE[Z, kclr=\eE[2J, kcub1=\eE[D, kcud1=\eE[B,
   kcuf1=\eE[C, kcuu1=\eE[A, kf1=\eEOc, kf10=\eENp,
   kf11=\eENq, kf12=\eENr, kf13=\eENs, kf14=\eENt, kf2=\eEOd,
   kf3=\eEOe, kf4=\eEOf, kf5=\eEOg, kf6=\eEOh, kf7=\eEOi,
   kf8=\eEOj, kf9=\eENo, khome=\eE[H, kind=\eE[S, kri=\eE[T,
   ll=\eE[24H, mc4=\eE[?4i, mc5=\eE[?5i, nel=\eEE,
   pfxl=\eE[%p1%d;%p2%l%02dq%?%p1%{9}%<%t\es\es\esF%p1%1d\es\es\es\es\es
\es\es\es\es\es\es%%p2%s,
   pln=\eE[%p1%d;0;0;0q%p2%:-16.16s, rc=\eE8, rev=\eE[7m,
   ri=\eEM, rmacs=^O, rmir=\eE[4l, rmln=\eE[2p, rmso=\eE[m,
   rmul=\eE[m, rs2=\eEc\eE[?3l, sc=\eE7,
   sgr=\eE[0%?%p6%t;1%%?%p5%t;2%%?%p2%t;4%%?%p4%t;5%
%?%p3%p1% | %t;7%%?%p7%t;8%m%?%p9%t^N%e^O%,
   sgr0=\eE[m^O, smacs=^N, smir=\eE[4h, smln=\eE[p,
   smso=\eE[7m, smul=\eE[4m, tsl=\eE7\eE[25;%i%p1%dx,
.fi
.in -2

.SS "Types of Capabilities in the Sample Entry"
.sp
.LP
The sample entry shows the formats for the three types of \fBterminfo\fR capabilities listed:  Boolean, numeric, and string. All capabilities specified in the \fBterminfo\fR source file must be followed by commas, including the last capability in the source file. In \fBterminfo\fR source files, capabilities are referenced by their capability names (as shown in the previous tables).
.sp
.LP
Boolean capabilities are specified simply by their comma separated cap names.
.sp
.LP
Numeric capabilities are followed by the character `#' and then a positive integer value. Thus, in the sample, \fBcols\fR (which shows the number of columns available on a device) is assigned the value \fB80\fR for the AT&T 610. (Values for numeric capabilities may be specified in decimal, octal, or hexadecimal, using normal C programming language conventions.)
.sp
.LP
Finally, string-valued capabilities such as \fBel\fR (clear to end of line sequence) are listed by a two- to five-character capname, an `=', and a string ended by the next occurrence of a comma. A delay in milliseconds may appear anywhere in such a capability, preceded by \fB$\fR and enclosed in angle brackets, as in \fBel=\eEK$<3>\fR. Padding characters are supplied by \fBtput\fR. The delay can be any of the following:  a number, a number followed by an asterisk, such as \fB5*\fR, a number followed by a slash, such as \fB5/\fR, or a number followed by both, such as \fB5*/\fR. A `\fB*\fR\fB\&'\fR shows that the padding required is proportional to the number of lines affected by the operation, and the amount given is the per-affected-unit padding required. (In the case of insert characters, the factor is still the number of lines affected. This is always 1 unless the device has \fBin\fR and the software uses it.) When a `\fB*\fR\fB\&'\fR is specified, it is sometimes useful to give a delay of the form \fB3.5\fR to specify a delay per unit to tenths of milliseconds. (Only one decimal place is allowed.)
.sp
.LP
A `/' indicates that the padding is mandatory. If a device has \fBxon\fR defined, the padding information is advisory and will only be used for cost estimates or when the device is in raw mode. Mandatory padding will be transmitted regardless of the setting of \fBxon\fR. If padding (whether advisory or mandatory) is specified for \fBbel\fR or \fBflash\fR, however, it will always be used, regardless of whether \fBxon\fR is specified.
.sp
.LP
\fBterminfo\fR offers notation for encoding special characters. Both \fB\eE\fR and \fB\ee\fR map to an ESCAPE character, \fI^x\fR maps to a control \fIx\fR for any appropriate \fIx\fR, and the sequences \fB\en, \el, \er, \et, \eb, \ef\fR, and \fB\es\fR give a newline, linefeed, return, tab, backspace, formfeed, and space, respectively. Other escapes include: \fB\e^\fR for caret (^); \fB\e\e\fR for backslash (\e); \fB\e\fR, for comma (,); \fB\e:\fR for colon (:); and \fB\e0\fR for null. (\fB\e0\fR will actually produce \fB\e200\fR, which does not terminate a string but behaves as a null character on most devices, providing CS7 is specified. (See \fBstty\fR(1)). Finally, characters may be given as three octal digits after a backslash (for example, \e123).
.sp
.LP
Sometimes individual capabilities must be commented out. To do this, put a period before the capability name. For example, see the second \fBind\fR in the example above. Note that capabilities are defined in a left-to-right order and, therefore, a prior definition will override a later definition.
.SS "Preparing Descriptions"
.sp
.LP
The most effective way to prepare a device description is by imitating the description of a similar device in \fBterminfo\fR and building up a description gradually, using partial descriptions with \fBvi\fR to check that they are correct. Be aware that a very unusual device may expose deficiencies in the ability of the \fBterminfo\fR file to describe it or the inability of \fBvi\fR to work with that device. To test a new device description, set the environment variable \fBTERMINFO\fR to the pathname of a directory containing the compiled description you are working on and programs will look there rather than in \fB/usr/share/lib/terminfo\fR. To get the padding for insert-line correct (if the device manufacturer did not document it) a severe test is to comment out \fBxon\fR, edit a large file at 9600 baud with \fBvi\fR, delete 16 or so lines from the middle of the screen, and then press the \fBu\fR key several times quickly. If the display is corrupted, more padding is usually needed. A similar test can be used for insert-character.
.SS "Section 1-1: Basic Capabilities"
.sp
.LP
The number of columns on each line for the device is given by the \fBcols\fR numeric capability. If the device has a screen, then the number of lines on the screen is given by the \fBlines\fR capability. If the device wraps around to the beginning of the next line when it reaches the right margin, then it should have the \fBam\fR capability. If the terminal can clear its screen, leaving the cursor in the home position, then this is given by the \fBclear\fR string capability. If the terminal overstrikes (rather than clearing a position when a character is struck over) then it should have the \fBos\fR capability. If the device is a printing terminal, with no soft copy unit, specify both \fBhc\fR and \fBos\fR. If there is a way to move the cursor to the left edge of the current row, specify this as \fBcr\fR. (Normally this will be carriage return, control M.) If there is a way to produce an audible signal (such as a bell or a beep), specify it as \fBbel\fR. If, like most devices, the device uses the xon-xoff flow-control protocol, specify \fBxon\fR.
.sp
.LP
If there is a way to move the cursor one position to the left (such as backspace), that capability should be given as \fBcub1\fR. Similarly, sequences to move to the right, up, and down should be given as \fBcuf1\fR, \fBcuu1\fR, and \fBcud1\fR, respectively. These local cursor motions must not alter the text they pass over; for example, you would not normally use ``\fBcuf1\fR=\es'' because the space would erase the character moved over.
.sp
.LP
A very important point here is that the local cursor motions encoded in \fBterminfo\fR are undefined at the left and top edges of a screen terminal. Programs should never attempt to backspace around the left edge, unless \fBbw\fR is specified, and should never attempt to go up locally off the top. To scroll text up, a program goes to the bottom left corner of the screen and sends the \fBind\fR (index) string.
.sp
.LP
To scroll text down, a program goes to the top left corner of the screen and sends the \fBri\fR (reverse index) string. The strings \fBind\fR and \fBri\fR are undefined when not on their respective corners of the screen.
.sp
.LP
Parameterized versions of the scrolling sequences are \fBindn\fR and \fBrin\fR. These versions have the same semantics as \fBind\fR and \fBri\fR, except that they take one parameter and scroll the number of lines specified by that parameter. They are also undefined except at the appropriate edge of the screen.
.sp
.LP
The \fBam\fR capability tells whether the cursor sticks at the right edge of the screen when text is output, but this does not necessarily apply to a \fBcuf1\fR from the last column. Backward motion from the left edge of the screen is possible only when \fBbw\fR is specified. In this case, \fBcub1\fR will move to the right edge of the previous row. If \fBbw\fR is not given, the effect is undefined. This is useful for drawing a box around the edge of the screen, for example. If the device has switch selectable automatic margins, \fBam\fR should be specified in the \fBterminfo\fR source file. In this case, initialization strings should turn on this option, if possible. If the device has a command that moves to the first column of the next line, that command can be given as \fBnel\fR (newline). It does not matter if the command clears the remainder of the current line, so if the device has no \fBcr\fR and \fBlf\fR it may still be possible to craft a working \fBnel\fR out of one or both of them.
.sp
.LP
These capabilities suffice to describe hardcopy and screen terminals. Thus the AT&T 5320 hardcopy terminal is described as follows:
.sp
.in +2
.nf
5320|att5320|AT&T 5320 hardcopy terminal,
   am, hc, os,
   cols#132,
   bel=^G, cr=\er, cub1=\eb, cnd1=\en,
   dch1=\eE[P, dl1=\eE[M,
   ind=\en,
.fi
.in -2
.sp

.sp
.LP
while the Lear Siegler ADM\(mi3 is described as
.sp
.in +2
.nf
adm3 | lsi adm3,
   am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H,
   cud1=^J, ind=^J, lines#24,
.fi
.in -2
.sp

.SS "Section 1-2: Parameterized Strings"
.sp
.LP
Cursor addressing and other strings requiring parameters are described by a parameterized string capability, with \fBprintf\fR-like escapes (\fB%\fR\fIx\fR) in it. For example, to address the cursor, the \fBcup\fR capability is given, using two parameters: the row and column to address to. (Rows and columns are numbered from zero and refer to the physical screen visible to the user, not to any unseen memory.) If the terminal has memory relative cursor addressing, that can be indicated by \fBmrcup\fR.
.sp
.LP
The parameter mechanism uses a stack and special \fB%\fR codes to manipulate the stack in the manner of Reverse Polish Notation (postfix). Typically a sequence will push one of the parameters onto the stack and then print it in some format. Often more complex operations are necessary. Operations are in postfix form with the operands in the usual order. That is, to subtract 5 from the first parameter, one would use \fB%p1%{5}%\(mi\fR.
.sp
.LP
The \fB%\fR encodings have the following meanings:
.sp
.ne 2
.mk
.na
\fB\fB%%\fR\fR
.ad
.sp .6
.RS 4n
outputs `%'
.RE

.sp
.ne 2
.mk
.na
\fB\fB%[[:]\fR\fIflags\fR][\fIwidth\fR[\fI\&.precision\fR]][\fBdoxXs\fR]\fR
.ad
.sp .6
.RS 4n
as in \fBprintf\fR, flags are \fB[\(mi+#]\fR and space
.RE

.sp
.ne 2
.mk
.na
\fB\fB%c\fR\fR
.ad
.sp .6
.RS 4n
print pop gives %c
.RE

.sp
.ne 2
.mk
.na
\fB\fB%p[1-9]\fR\fR
.ad
.sp .6
.RS 4n
push \fIi\fRth parm
.RE

.sp
.ne 2
.mk
.na
\fB\fB%P[a-z]\fR\fR
.ad
.sp .6
.RS 4n
set dynamic variable [a-z] to pop
.RE

.sp
.ne 2
.mk
.na
\fB\fB%g[a-z]\fR\fR
.ad
.sp .6
.RS 4n
get dynamic variable [a-z] and push it
.RE

.sp
.ne 2
.mk
.na
\fB\fB%P[A-Z]\fR\fR
.ad
.sp .6
.RS 4n
set static variable [a-z] to pop
.RE

.sp
.ne 2
.mk
.na
\fB\fB%g[A-Z]\fR\fR
.ad
.sp .6
.RS 4n
get static variable [a-z] and push it
.RE

.sp
.ne 2
.mk
.na
\fB\fB%'\fR\fIc\fR'\fR
.ad
.sp .6
.RS 4n
push char constant \fIc\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB%{\fR\fInn\fR}\fR
.ad
.sp .6
.RS 4n
push decimal constant \fInn\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fB%l\fR\fR
.ad
.sp .6
.RS 4n
push strlen(pop)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%+ %\(mi %* %/ %m\fR\fR
.ad
.sp .6
.RS 4n
arithmetic (\fB%m\fR is mod):  push(pop integer2 op pop integer1)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%& %| %^\fR\fR
.ad
.sp .6
.RS 4n
bit operations:  push(pop integer2 op pop integer1)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%= %> %<\fR\fR
.ad
.sp .6
.RS 4n
logical operations:  push(pop integer2 op pop integer1)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%A %O\fR\fR
.ad
.sp .6
.RS 4n
logical operations:  and, or
.RE

.sp
.ne 2
.mk
.na
\fB\fB%! %~\fR\fR
.ad
.sp .6
.RS 4n
unary operations:  push(op pop)
.RE

.sp
.ne 2
.mk
.na
\fB\fB%i\fR\fR
.ad
.sp .6
.RS 4n
(for ANSI terminals) add 1 to first parm, if one parm present, or first two parms, if more than one parm present
.RE

.sp
.ne 2
.mk
.na
\fB\fB%?\fR \fBexpr\fR %t \fIthenpart\fR %e \fIelsepart\fR %\fR
.ad
.sp .6
.RS 4n
if-then-else, \fB%e\fR \fIelsepart\fR is optional; else-if's are possible ala Algol 68: \fB%? c\fR(1) %t b(1) %e c(2) %t b(2) %e c(3) %t b(3) %e c(4) %t b(4) %e b(5)% c(\fIi\fR) are conditions, b(\fIi\fR) are bodies.
.RE

.sp
.LP
If the ``\fB\(mi\fR\&'' flag is used with ``\fB%\fR[doxXs]'', then a colon (\fB:\fR) must be placed between the ``\fB%\fR'' and the ``\fB\(mi\fR\&'' to differentiate the flag from the binary ``\fB%\(mi\fR'' operator, for example ``\fB%:\(mi16.16s\fR''.
.sp
.LP
Consider the Hewlett-Packard 2645, which, to get to row 3 and column 12, needs to be sent \fB\eE&a12c03Y\fR padded for 6 milliseconds. Note that the order of the rows and columns is inverted here, and that the row and column are zero-padded as two digits. Thus its \fBcup\fR capability is: \fBcup=\eE&a%p2%2.2dc%p1%2.2dY$<6>\fR
.sp
.LP
The Micro-Term ACT-IV needs the current row and column sent preceded by a \fB^T\fR, with the row and column simply encoded in binary, ``\fBcup=^T%p1%c%p2%c\fR''. Devices that use ``\fB%c\fR'' need to be able to backspace the cursor (\fBcub1\fR), and to move the cursor up one line on the screen (\fBcuu1\fR). This is necessary because it is not always safe to transmit \fB\en\fR, \fB^D\fR, and \fB\er\fR, as the system may change or discard them. (The library routines dealing with \fBterminfo\fR set tty modes so that tabs are never expanded, so \fB\et\fR is safe to send. This turns out to be essential for the Ann Arbor 4080.)
.sp
.LP
A final example is the LSI ADM-3a, which uses row and column offset by a blank character, thus ``\fBcup=\eE=%p1%'\es'%+%c%p2%'\es'%+%c\fR''. After sending ``\fB\eE=\fR\&'', this pushes the first parameter, pushes the ASCII value for a space (32), adds them (pushing the sum on the stack in place of the two previous values), and outputs that value as a character. Then the same is done for the second parameter. More complex arithmetic is possible using the stack.
.SS "Section 1-3: Cursor Motions"
.sp
.LP
If the terminal has a fast way to home the cursor (to very upper left corner of screen) then this can be given as \fBhome\fR; similarly a fast way of getting to the lower left-hand corner can be given as \fBll\fR; this may involve going up with \fBcuu1\fR from the home position, but a program should never do this itself (unless \fBll\fR does) because it can make no assumption about the effect of moving up from the home position. Note that the home position is the same as addressing to (0,0): to the top left corner of the screen, not of memory. (Thus, the \fB\eEH\fR sequence on Hewlett-Packard terminals cannot be used for \fBhome\fR without losing some of the other features on the terminal.)
.sp
.LP
If the device has row or column absolute-cursor addressing, these can be given as single parameter capabilities \fBhpa\fR (horizontal position absolute) and \fBvpa\fR (vertical position absolute). Sometimes these are shorter than the more general two-parameter sequence (as with the Hewlett-Packard 2645) and can be used in preference to \fBcup\fR. If there are parameterized local motions (for example, move \fIn\fR spaces to the right) these can be given as \fBcud\fR, \fBcub\fR, \fBcuf\fR, and \fBcuu\fR with a single parameter indicating how many spaces to move. These are primarily useful if the device does not have \fBcup\fR, such as the Tektronix 4025.
.sp
.LP
If the device needs to be in a special mode when running a program that uses these capabilities, the codes to enter and exit this mode can be given as \fBsmcup\fR and \fBrmcup\fR. This arises, for example, from terminals, such as the Concept, with more than one page of memory. If the device has only memory relative cursor addressing and not screen relative cursor addressing, a one screen-sized window must be fixed into the device for cursor addressing to work properly. This is also used for the Tektronix 4025, where \fBsmcup\fR sets the command character to be the one used by \fBterminfo\fR. If the \fBsmcup\fR sequence will not restore the screen after an \fBrmcup\fR sequence is output (to the state prior to outputting \fBrmcup\fR), specify \fBnrrmc\fR.
.SS "Section 1-4: Area Clears"
.sp
.LP
If the terminal can clear from the current position to the end of the line, leaving the cursor where it is, this should be given as \fBel\fR. If the terminal can clear from the beginning of the line to the current position inclusive, leaving the cursor where it is, this should be given as \fBel1\fR. If the terminal can clear from the current position to the end of the display, then this should be given as \fBed\fR. \fBed\fR is only defined from the first column of a line. (Thus, it can be simulated by a request to delete a large number of lines, if a true \fBed\fR is not available.)
.SS "Section 1-5: Insert/Delete Line"
.sp
.LP
If the terminal can open a new blank line before the line where the cursor is, this should be given as \fBil1\fR; this is done only from the first position of a line. The cursor must then appear on the newly blank line. If the terminal can delete the line which the cursor is on, then this should be given as \fBdl1\fR; this is done only from the first position on the line to be deleted. Versions of \fBil1\fR and \fBdl1\fR which take a single parameter and insert or delete that many lines can be given as \fBil\fR and \fBdl\fR.
.sp
.LP
If the terminal has a settable destructive scrolling region (like the VT100) the command to set this can be described with the \fBcsr\fR capability, which takes two parameters: the top and bottom lines of the scrolling region. The cursor position is, alas, undefined after using this command. It is possible to get the effect of insert or delete line using this command \(em the \fBsc\fR and \fBrc\fR (save and restore cursor) commands are also useful. Inserting lines at the top or bottom of the screen can also be done using \fBri\fR or \fBind\fR on many terminals without a true insert/delete line, and is often faster even on terminals with those features.
.sp
.LP
To determine whether a terminal has destructive scrolling regions or non-destructive scrolling regions, create a scrolling region in the middle of the screen, place data on the bottom line of the scrolling region, move the cursor to the top line of the scrolling region, and do a reverse index (\fBri\fR) followed by a delete line (\fBdl1\fR) or index (\fBind\fR). If the data that was originally on the bottom line of the scrolling region was restored into the scrolling region by the \fBdl1\fR or \fBind\fR, then the terminal has non-destructive scrolling regions. Otherwise, it has destructive scrolling regions. Do not specify \fBcsr\fR if the terminal has non-destructive scrolling regions, unless \fBind\fR, \fBri\fR, \fBindn\fR, \fBrin\fR, \fBdl\fR, and \fBdl1\fR all simulate destructive scrolling.
.sp
.LP
If the terminal has the ability to define a window as part of memory, which all commands affect, it should be given as the parameterized string \fBwind\fR. The four parameters are the starting and ending lines in memory and the starting and ending columns in memory, in that order.
.sp
.LP
If the terminal can retain display memory above, then the \fBda\fR capability should be given; if display memory can be retained below, then \fBdb\fR should be given. These indicate that deleting a line or scrolling a full screen may bring non-blank lines up from below or that scrolling back with \fBri\fR may bring down non-blank lines.
.SS "Section 1-6: Insert/Delete Character"
.sp
.LP
There are two basic kinds of intelligent terminals with respect to insert/delete character operations which can be described using \fBterminfo.\fR The most common insert/delete character operations affect only the characters on the current line and shift characters off the end of the line rigidly. Other terminals, such as the Concept 100 and the Perkin Elmer Owl, make a distinction between typed and untyped blanks on the screen, shifting upon an insert or delete only to an untyped blank on the screen which is either eliminated, or expanded to two untyped blanks. You can determine the kind of terminal you have by clearing the screen and then typing text separated by cursor motions. Type ``\fBabc def\fR'' using local cursor motions (not spaces) between the \fBabc\fR and the \fBdef\fR. Then position the cursor before the \fBabc\fR and put the terminal in insert mode. If typing characters causes the rest of the line to shift rigidly and characters to fall off the end, then your terminal does not distinguish between blanks and untyped positions. If the \fBabc\fR shifts over to the \fBdef\fR which then move together around the end of the current line and onto the next as you insert, you have the second type of terminal, and should give the capability \fBin\fR, which stands for ``insert null.'' While these are two logically separate attributes (one line versus multiline insert mode, and special treatment of untyped spaces) we have seen no terminals whose insert mode cannot be described with the single attribute.
.sp
.LP
\fBterminfo\fR can describe both terminals that have an insert mode and terminals which send a simple sequence to open a blank position on the current line. Give as \fBsmir\fR the sequence to get into insert mode. Give as \fBrmir\fR the sequence to leave insert mode. Now give as \fBich1\fR any sequence needed to be sent just before sending the character to be inserted. Most terminals with a true insert mode will not give \fBich1\fR; terminals that send a sequence to open a screen position should give it here. (If your terminal has both, insert mode is usually preferable to \fBich1\fR. Do not give both unless the terminal actually requires both to be used in combination.) If post-insert padding is needed, give this as a number of milliseconds padding in \fBip\fR (a string option). Any other sequence which may need to be sent after an insert of a single character may also be given in \fBip\fR. If your terminal needs both to be placed into an `insert mode' and a special code to precede each inserted character, then both \fBsmir\fR/rmir and \fBich1\fR can be given, and both will be used. The \fBich\fR capability, with one parameter, \fIn\fR, will insert \fIn\fR blanks.
.sp
.LP
If padding is necessary between characters typed while not in insert mode, give this as a number of milliseconds padding in \fBrmp\fR.
.sp
.LP
It is occasionally necessary to move around while in insert mode to delete characters on the same line (for example, if there is a tab after the insertion position). If your terminal allows motion while in insert mode you can give the capability \fBmir\fR to speed up inserting in this case. Omitting \fBmir\fR will affect only speed. Some terminals (notably Datamedia's) must not have \fBmir\fR because of the way their insert mode works.
.sp
.LP
Finally, you can specify \fBdch1\fR to delete a single character, \fBdch\fR with one parameter, \fIn\fR, to delete \fIn\fR characters, and delete mode by giving \fBsmdc\fR and \fBrmdc\fR to enter and exit delete mode (any mode the terminal needs to be placed in for \fBdch1\fR to work).
.sp
.LP
A command to erase \fIn\fR characters (equivalent to outputting \fIn\fR blanks without moving the cursor) can be given as \fBech\fR with one parameter.
.SS "Section 1-7: Highlighting, Underlining, and Visible Bells"
.sp
.LP
Your device may have one or more kinds of display attributes that allow you to highlight selected characters when they appear on the screen. The following display modes (shown with the names by which they are set) may be available: a blinking screen (\fBblink\fR), bold or extra-bright characters (\fBbold\fR), dim or half-bright characters (\fBdim\fR), blanking or invisible text (\fBinvis\fR), protected text (\fBprot\fR), a reverse-video screen (\fBrev\fR), and an alternate character set (\fBsmacs\fR to enter this mode and \fBrmacs\fR to exit it). (If a command is necessary before you can enter alternate character set mode, give the sequence in \fBenacs\fR or "enable alternate-character-set" mode.) Turning on any of these modes singly may or may not turn off other modes.
.sp
.LP
\fBsgr0\fR should be used to turn off all video enhancement capabilities. It should always be specified because it represents the only way to turn off some capabilities, such as \fBdim\fR or \fBblink\fR.
.sp
.LP
You should choose one display method as \fIstandout mode\fR and use it to highlight error messages and other kinds of text to which you want to draw attention. Choose a form of display that provides strong contrast but that is easy on the eyes. (We recommend reverse-video plus half-bright or reverse-video alone.) The sequences to enter and exit standout mode are given as \fBsmso\fR and \fBrmso\fR, respectively. If the code to change into or out of standout mode leaves one or even two blank spaces on the screen, as the TVI 912 and Teleray 1061 do, then \fBxmc\fR should be given to tell how many spaces are left.
.sp
.LP
Sequences to begin underlining and end underlining can be specified as \fBsmul\fR and \fBrmul ,\fR respectively. If the device has a sequence to underline the current character and to move the cursor one space to the right (such as the Micro-Term MIME), this sequence can be specified as \fBuc\fR.
.sp
.LP
Terminals with the ``magic cookie'' glitch (\fBxmc\fR\fB)\fR deposit special ``cookies'' when they receive mode-setting sequences, which affect the display algorithm rather than having extra bits for each character. Some terminals, such as the Hewlett-Packard 2621, automatically leave standout mode when they move to a new line or the cursor is addressed. Programs using standout mode should exit standout mode before moving the cursor or sending a newline, unless the \fBmsgr\fR capability, asserting that it is safe to move in standout mode, is present.
.sp
.LP
If the terminal has a way of flashing the screen to indicate an error quietly (a bell replacement), then this can be given as \fBflash\fR; it must not move the cursor. A good flash can be done by changing the screen into reverse video, pad for 200 ms, then return the screen to normal video.
.sp
.LP
If the cursor needs to be made more visible than normal when it is not on the bottom line (to make, for example, a non-blinking underline into an easier to find block or blinking underline) give this sequence as \fBcvvis\fR. The boolean \fBchts\fR should also be given. If there is a way to make the cursor completely invisible, give that as \fBcivis\fR. The capability \fBcnorm\fR should be given which undoes the effects of either of these modes.
.sp
.LP
If your terminal generates underlined characters by using the underline character (with no special sequences needed) even though it does not otherwise overstrike characters, then you should specify the capability \fBul\fR. For devices on which a character overstriking another leaves both characters on the screen, specify the capability \fBos\fR. If overstrikes are erasable with a blank, then this should be indicated by specifying \fBeo\fR.
.sp
.LP
If there is a sequence to set arbitrary combinations of modes, this should be given as \fBsgr\fR (set attributes), taking nine parameters. Each parameter is either \fB0\fR or non-zero, as the corresponding attribute is on or off. The nine parameters are, in order: standout, underline, reverse, blink, dim, bold, blank, protect, alternate character set. Not all modes need to be supported by \fBsgr\fR; only those for which corresponding separate attribute commands exist should be supported. For example, let's assume that the terminal in question needs the following escape sequences to turn on various modes.
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i) 
cw(1.83i) cw(1.83i) cw(1.83i) 
.
tparm
parameterattributeescape sequence
_
none\eE[0m
p1standout\eE[0;4;7m
p2underline\eE[0;3m
p3reverse\eE[0;4m
p4 blink\eE[0;5m
p5dim\eE[0;7m
p6bold\eE[0;3;4m
p7invis\eE[0;8m
p8protectnot available
p9altcharset^O (off) ^N (on)
.TE

.sp
.LP
Note that each escape sequence requires a \fB0\fR to turn off other modes before turning on its own mode.  Also note that, as suggested above, \fIstandout\fR is set up to be the combination of \fIreverse\fR and \fIdim\fR. Also, because this terminal has no \fIbold\fR mode, \fIbold\fR is set up as the combination of \fIreverse\fR and \fIunderline\fR. In addition, to allow combinations, such as \fIunderline+blink\fR, the sequence to use would be \fB\eE[0;3;5m\fR\&. The terminal doesn't have \fIprotect\fR mode, either, but that cannot be simulated in any way, so \fBp8\fR is ignored. The \fIaltcharset\fR mode is different in that it is either \fB^O\fR or \fB^N\fR, depending on whether it is off or on. If all modes were to be turned on, the sequence would be \fB\eE[0;3;4;5;7;8m^N\fR\&.
.sp
.LP
Now look at when different sequences are output. For example, \fB;3\fR is output when either \fBp2\fR or \fBp6\fR is true, that is, if either \fIunderline\fR or \fIbold\fR modes are turned on. Writing out the above sequences, along with their dependencies, gives the following:
.sp

.sp
.TS
tab();
cw(1.51i) cw(1.99i) cw(1.99i) 
lw(1.51i) lw(1.99i) lw(1.99i) 
.
sequencewhen to outputterminfo translation
_
\eE[0always\eE[0
;3if \fBp2\fR or \fBp6\fR%?%p2%p6%|%t;3%
;4if \fBp1\fR or \fBp3\fR or \fBp6\fR%?%p1%p3%|%p6%|%t;4%
;5if \fBp4\fR%?%p4%t;5%
;7if \fBp1\fR or \fBp5\fR%?%p1%p5%|%t;7%
;8if \fBp7\fR%?%p7%t;8%
malwaysm
^N or ^Oif \fBp9 ^N\fR, else \fB^O\fR%?%p9%t^N%e^O%
.TE

.sp
.LP
Putting this all together into the \fBsgr\fR sequence gives:
.sp
.LP
\fBsgr=\eE[0%?%p2%p6%|%t;3%%?%p1%p3%|%p6% |%t;4%%?%p5%t;5%%?%p1%p5% |%t;7%%?%p7%t;8%m%?%p9%t^N%e^O%,\fR
.sp
.LP
Remember that \fBsgr\fR and \fBsgr0\fR must always be specified.
.SS "Section 1-8: Keypad"
.sp
.LP
If the device has a keypad that transmits sequences when the keys are pressed, this information can also be specified. Note that it is not possible to handle devices where the keypad only works in local (this applies, for example, to the unshifted Hewlett-Packard 2621 keys). If the keypad can be set to transmit or not transmit, specify these sequences as \fBsmkx\fR and \fBrmkx\fR. Otherwise the keypad is assumed to always transmit.
.sp
.LP
The sequences sent by the left arrow, right arrow, up arrow, down arrow, and home keys can be given as \fBkcub1, kcuf1, kcuu1, kcud1,\fRand \fBkhome\fR, respectively. If there are function keys such as f0, f1, ..., f63, the sequences they send can be specified as \fBkf0, kf1, ..., kf63\fR. If the first 11 keys have labels other than the default f0 through f10, the labels can be given as \fBlf0, lf1, ..., lf10\fR. The codes transmitted by certain other special keys can be given: \fBkll\fR (home down), \fBkbs\fR (backspace), \fBktbc\fR (clear all tabs), \fBkctab\fR (clear the tab stop in this column), \fBkclr\fR (clear screen or erase key), \fBkdch1\fR (delete character), \fBkdl1\fR (delete line), \fBkrmir\fR (exit insert mode), \fBkel\fR (clear to end of line), \fBked\fR (clear to end of screen), \fBkich1\fR (insert character or enter insert mode), \fBkil1\fR (insert line), \fBknp\fR (next page), \fBkpp\fR (previous page), \fBkind\fR (scroll forward/down), \fBkri\fR (scroll backward/up), \fBkhts\fR (set a tab stop in this column). In addition, if the keypad has a 3 by 3 array of keys including the four arrow keys, the other five keys can be given as \fBka1\fR, \fBka3\fR, \fBkb2\fR, \fBkc1\fR, and \fBkc3\fR. These keys are useful when the effects of a 3 by 3 directional pad are needed. Further keys are defined above in the capabilities list.
.sp
.LP
Strings to program function keys can be specified as \fBpfkey\fR, \fBpfloc\fR, and \fBpfx\fR. A string to program screen labels should be specified as \fBpln\fR. Each of these strings takes two parameters: a function key identifier and a string to program it with. \fBpfkey\fR causes pressing the given key to be the same as the user typing the given string; \fBpfloc\fR causes the string to be executed by the terminal in local mode; and \fBpfx\fR causes the string to be transmitted to the computer. The capabilities \fBnlab\fR, \fBlw\fR and \fBlh\fR define the number of programmable screen labels and their width and height. If there are commands to turn the labels on and off, give them in \fBsmln\fR and \fBrmln\fR. \fBsmln\fR is normally output after one or more \fBpln\fR sequences to make sure that the change becomes visible.
.SS "Section 1-9: Tabs and Initialization"
.sp
.LP
If the device has hardware tabs, the command to advance to the next tab stop can be given as \fBht\fR (usually control I). A ``backtab'' command that moves leftward to the next tab stop can be given as \fBcbt\fR. By convention, if tty modes show that tabs are being expanded by the computer rather than being sent to the device, programs should not use \fBht\fR or \fBcbt\fR (even if they are present) because the user may not have the tab stops properly set. If the device has hardware tabs that are initially set every \fIn\fR spaces when the device is powered up, the numeric parameter \fBit\fR is given, showing the number of spaces the tabs are set to. This is normally used by \fBtput\fR \fBinit\fR (see \fBtput\fR(1)) to determine whether to set the mode for hardware tab expansion and whether to set the tab stops. If the device has tab stops that can be saved in nonvolatile memory, the \fBterminfo\fR description can assume that they are properly set. If there are commands to set and clear tab stops, they can be given as \fBtbc\fR (clear all tab stops) and \fBhts\fR (set a tab stop in the current column of every row).
.sp
.LP
Other capabilities include: \fBis1\fR, \fBis2\fR, and \fBis3\fR, initialization strings for the device; \fBiprog\fR, the path name of a program to be run to initialize the device; and \fBif\fR, the name of a file containing long initialization strings. These strings are expected to set the device into modes consistent with the rest of the \fBterminfo\fR description. They must be sent to the device each time the user logs in and be output in the following order: run the program \fBiprog\fR; output \fBis1\fR; output \fBis2\fR; set the margins using \fBmgc\fR, \fBsmgl\fR and \fBsmgr\fR; set the tabs using \fBtbc\fR and \fBhts\fR; print the file \fBif\fR; and finally output \fBis3\fR. This is usually done using the \fBinit\fR option of \fBtput\fR.
.sp
.LP
Most initialization is done with \fBis2\fR. Special device modes can be set up without duplicating strings by putting the common sequences in \fBis2\fR and special cases in \fBis1\fR and \fBis3\fR. Sequences that do a reset from a totally unknown state can be given as \fBrs1\fR, \fBrs2\fR, \fBrf\fR, and \fBrs3\fR, analogous to \fBis1\fR, \fBis2\fR, \fBis3\fR, and \fBif\fR. (The method using files, \fBif\fR and \fBrf\fR, is used for a few terminals, from \fB/usr/share/lib/tabset/*\fR; however, the recommended method is to use the initialization and reset strings.) These strings are output by \fBtput\fR reset, which is used when the terminal gets into a wedged state. Commands are normally placed in \fBrs1\fR, \fBrs2\fR, \fBrs3\fR, and \fBrf\fR only if they produce annoying effects on the screen and are not necessary when logging in. For example, the command to set a terminal into 80-column mode would normally be part of \fBis2\fR, but on some terminals it causes an annoying glitch on the screen and is not normally needed because the terminal is usually already in 80-column mode.
.sp
.LP
If a more complex sequence is needed to set the tabs than can be described by using \fBtbc\fR and \fBhts\fR, the sequence can be placed in \fBis2\fR or \fBif\fR.
.sp
.LP
Any margin can be cleared with \fBmgc\fR. (For instructions on how to specify commands to set and clear margins, see "Margins" below under "PRINTER CAPABILITIES".)
.SS "Section 1-10: Delays"
.sp
.LP
Certain capabilities control padding in the \fBtty\fR driver. These are primarily needed by hard-copy terminals, and are used by \fBtput\fR \fBinit\fR to set tty modes appropriately. Delays embedded in the capabilities \fBcr\fR, \fBind\fR, \fBcub1\fR, \fBff\fR, and \fBtab\fR can be used to set the appropriate delay bits to be set in the tty driver. If \fBpb\fR (padding baud rate) is given, these values can be ignored at baud rates below the value of \fBpb\fR.
.SS "Section 1-11: Status Lines"
.sp
.LP
If the terminal has an extra ``status line'' that is not normally used by software, this fact can be indicated. If the status line is viewed as an extra line below the bottom line, into which one can cursor address normally (such as the Heathkit h19's 25th line, or the 24th line of a VT100 which is set to a 23-line scrolling region), the capability \fBhs\fR should be given. Special strings that go to a given column of the status line and return from the status line can be given as \fBtsl\fR and \fBfsl\fR. (\fBfsl\fR must leave the cursor position in the same place it was before \fBtsl\fR. If necessary, the \fBsc\fR and \fBrc\fR strings can be included in \fBtsl\fR and \fBfsl\fR to get this effect.) The capability \fBtsl\fR takes one parameter, which is the column number of the status line the cursor is to be moved to.
.sp
.LP
If escape sequences and other special commands, such as tab, work while in the status line, the flag \fBeslok\fR can be given. A string which turns off the status line (or otherwise erases its contents) should be given as \fBdsl\fR. If the terminal has commands to save and restore the position of the cursor, give them as \fBsc\fR and \fBrc\fR. The status line is normally assumed to be the same width as the rest of the screen, for example, \fBcols\fR. If the status line is a different width (possibly because the terminal does not allow an entire line to be loaded) the width, in columns, can be indicated with the numeric parameter \fBwsl\fR.
.SS "Section 1-12: Line Graphics"
.sp
.LP
If the device has a line drawing alternate character set, the mapping of glyph to character would be given in \fBacsc\fR. The definition of this string is based on the alternate character set used in the DEC VT100 terminal, extended slightly with some characters from the AT&T 4410v1 terminal.
.sp

.sp
.TS
tab();
cw(2.75i) cw(2.75i) 
lw(2.75i) lw(2.75i) 
.
Glyph Namevt100+ Character
_
arrow pointing right+
arrow pointing left,
arrow pointing down\&.
solid square block0
lantern symbolI
arrow pointing up\(mi
diamond`
checker board (stipple)a
degree symbolf
plus/minusg
board of squaresh
lower right cornerj
upper right cornerk
upper left cornerl
lower left cornerm
plusn
scan line 1o
horizontal lineq
scan line 9s
left teet
right teeu
bottom teev
top teew
vertical linex
bullet~
.TE

.sp
.LP
The best way to describe a new device's line graphics set is to add a third column to the above table with the characters for the new device that produce the appropriate glyph when the device is in the alternate character set mode. For example,
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i) 
lw(1.83i) lw(1.83i) lw(1.83i) 
.
Glyph Namevt100+ CharNew tty Char
_
upper left cornerlR
lower left cornermF
upper right cornerkT
lower right cornerjG
horizontal lineq,
vertical linex\&.
.TE

.sp
.LP
Now write down the characters left to right, as in ``\fBacsc=lRmFkTjGq\e,x.\fR''.
.sp
.LP
In addition, \fBterminfo\fR allows you to define multiple character sets. See Section 2-5 for details.
.SS "Section 1-13: Color Manipulation"
.sp
.LP
Let us define two methods of color manipulation:  the Tektronix method and the HP method. The Tektronix method uses a set of N predefined colors (usually 8) from which a user can select "current" foreground and background colors. Thus a terminal can support up to N colors mixed into N*N color-pairs to be displayed on the screen at the same time. When using an HP method the user cannot define the foreground independently of the background, or vice-versa. Instead, the user must define an entire color-pair at once. Up to M color-pairs, made from 2*M different colors, can be defined this way. Most existing color terminals belong to one of these two classes of terminals.
.sp
.LP
The numeric variables \fBcolors\fR and \fBpairs\fR define the number of colors and color-pairs that can be displayed on the screen at the same time. If a terminal can change the definition of a color (for example, the Tektronix 4100 and 4200 series terminals), this should be specified with \fBccc\fR (can change color). To change the definition of a color (Tektronix 4200 method), use \fBinitc\fR (initialize color). It requires four arguments:  color number (ranging from 0 to \fBcolors\fR\(mi1) and three RGB (red, green, and blue) values or three HLS colors (Hue, Lightness, Saturation). Ranges of RGB and HLS values are terminal dependent.
.sp
.LP
Tektronix 4100 series terminals only use HLS color notation. For such terminals (or dual-mode terminals to be operated in HLS mode) one must define a boolean variable \fBhls\fR; that would instruct the \fBcurses init_color\fR routine to convert its RGB arguments to HLS before sending them to the terminal. The last three arguments to the \fBinitc\fR string would then be HLS values.
.sp
.LP
If a terminal can change the definitions of colors, but uses a color notation different from RGB and HLS, a mapping to either RGB or HLS must be developed.
.sp
.LP
To set current foreground or background to a given color, use \fBsetaf\fR (set ANSI foreground) and \fBsetab\fR (set ANSI background). They require one parameter:  the number of the color. To initialize a color-pair (HP method), use \fBinitp\fR (initialize pair). It requires seven parameters:  the number of a color-pair (range=0 to \fBpairs\fR\(mi1), and six RGB values:  three for the foreground followed by three for the background. (Each of these groups of three should be in the order RGB.) When \fBinitc\fR or \fBinitp\fR are used, RGB or HLS arguments should be in the order "red, green, blue" or "hue, lightness, saturation"), respectively. To make a color-pair current, use \fBscp\fR (set color-pair). It takes one parameter, the number of a color-pair.
.sp
.LP
Some terminals (for example, most color terminal emulators for PCs) erase areas of the screen with current background color. In such cases, \fBbce\fR (background color erase) should be defined. The variable \fBop\fR (original pair) contains a sequence for setting the foreground and the background colors to what they were at the terminal start-up time. Similarly, \fBoc\fR (original colors) contains a control sequence for setting all colors (for the Tektronix method) or color-pairs (for the HP method) to the values they had at the terminal start-up time.
.sp
.LP
Some color terminals substitute color for video attributes. Such video attributes should not be combined with colors. Information about these video attributes should be packed into the \fBncv\fR (no color video) variable. There is a one-to-one correspondence between the nine least significant bits of that variable and the video attributes. The following table depicts this correspondence.
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i) 
lw(1.83i) lw(1.83i) lw(1.83i) 
.
AttributeBit PositionDecimal Value
_
A_STANDOUT01
A_UNDERLINE12
A_REVERSE24
A_BLINK38
A_DIM416
A_BOLD532
A_INVIS664
A_PROTECT7128
A_ALTCHARSET8256
.TE

.sp
.LP
When a particular video attribute should not be used with colors, the corresponding \fBncv\fR bit should be set to 1; otherwise it should be set to zero. To determine the information to pack into the \fBncv\fR variable, you must add together the decimal values corresponding to those attributes that cannot coexist with colors. For example, if the terminal uses colors to simulate reverse video (bit number 2 and decimal value 4) and bold (bit number 5 and decimal value 32), the resulting value for \fBncv\fR will be 36 (4 + 32).
.SS "Section 1-14: Miscellaneous"
.sp
.LP
If the terminal requires other than a null (zero) character as a pad, then this can be given as \fBpad\fR. Only the first character of the \fBpad\fR string is used. If the terminal does not have a pad character, specify \fBnpc\fR.
.sp
.LP
If the terminal can move up or down half a line, this can be indicated with \fBhu\fR (half-line up) and \fBhd\fR (half-line down). This is primarily useful for superscripts and subscripts on hardcopy terminals. If a hardcopy terminal can eject to the next page (form feed), give this as \fBff\fR (usually control L).
.sp
.LP
If there is a command to repeat a given character a given number of times (to save time transmitting a large number of identical characters) this can be indicated with the parameterized string \fBrep\fR. The first parameter is the character to be repeated and the second is the number of times to repeat it. Thus, \fBtparm(repeat_char, 'x', 10)\fR is the same as \fBxxxxxxxxxx.\fR
.sp
.LP
If the terminal has a settable command character, such as the Tektronix 4025, this can be indicated with \fBcmdch\fR. A prototype command character is chosen which is used in all capabilities. This character is given in the \fBcmdch\fR capability to identify it. The following convention is supported on some systems: If the environment variable \fBCC\fR exists, all occurrences of the prototype character are replaced with the character in \fBCC\fR.
.sp
.LP
Terminal descriptions that do not represent a specific kind of known terminal, such as \fBswitch\fR, \fIdialup\fR, \fBpatch\fR, and \fInetwork\fR, should include the \fBgn\fR (generic) capability so that programs can complain that they do not know how to talk to the terminal. (This capability does not apply to \fIvirtual\fR terminal descriptions for which the escape sequences are known.) If the terminal is one of those supported by the system virtual terminal protocol, the terminal number can be given as \fBvt\fR. A line-turn-around sequence to be transmitted before doing reads should be specified in \fBrfi\fR.
.sp
.LP
If the device uses xon/xoff handshaking for flow control, give \fBxon\fR. Padding information should still be included so that routines can make better decisions about costs, but actual pad characters will not be transmitted. Sequences to turn on and off xon/xoff handshaking may be given in \fBsmxon\fR and \fBrmxon\fR. If the characters used for handshaking are not \fB^S\fR and \fB^Q\fR, they may be specified with \fBxonc\fR and \fBxoffc\fR.
.sp
.LP
If the terminal has a ``meta key'' which acts as a shift key, setting the 8th bit of any character transmitted, this fact can be indicated with \fBkm\fR. Otherwise, software will assume that the 8th bit is parity and it will usually be cleared. If strings exist to turn this ``meta mode'' on and off, they can be given as \fBsmm\fR and \fBrmm\fR.
.sp
.LP
If the terminal has more lines of memory than will fit on the screen at once, the number of lines of memory can be indicated with \fBlm\fR. A value of \fBlm\fR#0 indicates that the number of lines is not fixed, but that there is still more memory than fits on the screen.
.sp
.LP
Media copy strings which control an auxiliary printer connected to the terminal can be given as \fBmc0\fR: print the contents of the screen, \fBmc4\fR: turn off the printer, and \fBmc5\fR: turn on the printer. When the printer is on, all text sent to the terminal will be sent to the printer. A variation, \fBmc5p\fR, takes one parameter, and leaves the printer on for as many characters as the value of the parameter, then turns the printer off. The parameter should not exceed 255. If the text is not displayed on the terminal screen when the printer is on, specify \fBmc5i\fR (silent printer). All text, including \fBmc4\fR, is transparently passed to the printer while an \fBmc5p\fR is in effect.
.SS "Section 1-15: Special Cases"
.sp
.LP
The working model used by \fBterminfo\fR fits most terminals reasonably well. However, some terminals do not completely match that model, requiring special support by \fBterminfo\fR. These are not meant to be construed as deficiencies in the terminals; they are just differences between the working model and the actual hardware. They may be unusual devices or, for some reason, do not have all the features of the \fBterminfo\fR model implemented.
.sp
.LP
Terminals that cannot display tilde (~) characters, such as certain Hazeltine terminals, should indicate \fBhz\fR.
.sp
.LP
Terminals that ignore a linefeed immediately after an \fBam\fR wrap, such as the Concept 100, should indicate \fBxenl\fR. Those terminals whose cursor remains on the right-most column until another character has been received, rather than wrapping immediately upon receiving the right-most character, such as the VT100, should also indicate \fBxenl\fR.
.sp
.LP
If \fBel\fR is required to get rid of standout (instead of writing normal text on top of it), \fBxhp\fR should be given.
.sp
.LP
Those Teleray terminals whose tabs turn all characters moved over to blanks, should indicate \fBxt\fR (destructive tabs). This capability is also taken to mean that it is not possible to position the cursor on top of a ``magic cookie.'' Therefore, to erase standout mode, it is necessary, instead, to use delete and insert line.
.sp
.LP
Those Beehive Superbee terminals which do not transmit the escape or control\(miC characters, should specify \fBxsb\fR, indicating that the f1 key is to be used for escape and the f2 key for control C.
.SS "Section 1-16: Similar Terminals"
.sp
.LP
If there are two very similar terminals, one can be defined as being just like the other with certain exceptions. The string capability \fBuse\fR can be given with the name of the similar terminal. The capabilities given before \fBuse\fR override those in the terminal type invoked by \fBuse\fR. A capability can be canceled by placing \fIxx\fR\fB@\fR to the left of the capability definition, where \fIxx\fR is the capability. For example, the entry
.sp
.in +2
.nf
att4424-2|Teletype4424 in display function group ii,
rev@, sgr@, smul@, use=att4424,
.fi
.in -2
.sp

.sp
.LP
defines an AT&T4424 terminal that does not have the \fBrev\fR, \fBsgr\fR, and \fBsmul\fR capabilities, and hence cannot do highlighting. This is useful for different modes for a terminal, or for different user preferences. More than one \fBuse\fR capability may be given.
.SS "PART 2: PRINTER CAPABILITIES"
.sp
.LP
The \fBterminfo\fR database allows you to define capabilities of printers as well as terminals. To find out what capabilities are available for printers as well as for terminals, see the two lists under "DEVICE CAPABILITIES" that list capabilities by variable and by capability name.
.SS "Section 2-1: Rounding Values"
.sp
.LP
Because parameterized string capabilities work only with integer values, we recommend that \fBterminfo\fR designers create strings that expect numeric values that have been rounded. Application designers should note this and should always round values to the nearest integer before using them with a parameterized string capability.
.SS "Section 2-2: Printer Resolution"
.sp
.LP
A printer's resolution is defined to be the smallest spacing of characters it can achieve. In general printers have independent resolution horizontally and vertically. Thus the vertical resolution of a printer can be determined by measuring the smallest achievable distance between consecutive printing baselines, while the horizontal resolution can be determined by measuring the smallest achievable distance between the left-most edges of consecutive printed, identical, characters.
.sp
.LP
All printers are assumed to be capable of printing with a uniform horizontal and vertical resolution. The view of printing that \fBterminfo\fR currently presents is one of printing inside a uniform matrix: All characters are printed at fixed positions relative to each ``cell'' in the matrix; furthermore, each cell has the same size given by the smallest horizontal and vertical step sizes dictated by the resolution. (The cell size can be changed as will be seen later.)
.sp
.LP
Many printers are capable of ``proportional printing,'' where the horizontal spacing depends on the size of the character last printed. \fBterminfo\fR does not make use of this capability, although it does provide enough capability definitions to allow an application to simulate proportional printing.
.sp
.LP
A printer must not only be able to print characters as close together as the horizontal and vertical resolutions suggest, but also of ``moving'' to a position an integral multiple of the smallest distance away from a previous position. Thus printed characters can be spaced apart a distance that is an integral multiple of the smallest distance, up to the length or width of a single page.
.sp
.LP
Some printers can have different resolutions depending on different ``modes.'' In ``normal mode,'' the existing \fBterminfo\fR capabilities are assumed to work on columns and lines, just like a video terminal. Thus the old \fBlines\fR capability would give the length of a page in lines, and the \fBcols\fR capability would give the width of a page in columns. In ``micro mode,'' many \fBterminfo\fR capabilities work on increments of lines and columns. With some printers the micro mode may be concomitant with normal mode, so that all the capabilities work at the same time.
.SS "Section 2-3: Specifying Printer Resolution"
.sp
.LP
The printing resolution of a printer is given in several ways. Each specifies the resolution as the number of smallest steps per distance: 
.sp
.in +2
.nf
   Specification of Printer Resolution
    Characteristic Number of Smallest Steps

     orhi    Steps per inch horizontally
     orvi    Steps per inch vertically
     orc     Steps per column
     orl     Steps per line
.fi
.in -2
.sp

.sp
.LP
When printing in normal mode, each character printed causes movement to the next column, except in special cases described later; the distance moved is the same as the per-column resolution. Some printers cause an automatic movement to the next line when a character is printed in the rightmost position; the distance moved vertically is the same as the per-line resolution. When printing in micro mode, these distances can be different, and may be zero for some printers.
.sp
.in +2
.nf
    Specification of Printer Resolution
     Automatic Motion after Printing

     Normal Mode:

     orc     Steps moved horizontally
     orl     Steps moved vertically

     Micro Mode:

     mcs     Steps moved horizontally
     mls     Steps moved vertically
.fi
.in -2
.sp

.sp
.LP
Some printers are capable of printing wide characters. The distance moved when a wide character is printed in normal mode may be different from when a regular width character is printed. The distance moved when a wide character is printed in micro mode may also be different from when a regular character is printed in micro mode, but the differences are assumed to be related: If the distance moved for a regular character is the same whether in normal mode or micro mode (\fBmcs\fR=orc), then the distance moved for a wide character is also the same whether in normal mode or micro mode. This doesn't mean the normal character distance is necessarily the same as the wide character distance, just that the distances don't change with a change in normal to micro mode. However, if the distance moved for a regular character is different in micro mode from the distance moved in normal mode (\fBmcs\fR<\fBorc\fR), the micro mode distance is assumed to be the same for a wide character printed in micro mode, as the table below shows. 
.sp
.in +2
.nf
    Specification of Printer Resolution
     Automatic Motion after Printing Wide Character

     Normal Mode or Micro Mode (mcs = orc):
     sp
     widcs   Steps moved horizontally

     Micro Mode (mcs < orc):

     mcs     Steps moved horizontally
.fi
.in -2
.sp

.sp
.LP
There may be control sequences to change the number of columns per inch (the character pitch) and to change the number of lines per inch (the line pitch). If these are used, the resolution of the printer changes, but the type of change depends on the printer: 
.sp
.in +2
.nf
    Specification of Printer Resolution
     Changing the Character/Line Pitches

     cpi     Change character pitch
     cpix    If set, cpi changes orhi, otherwise changes
     orc
     lpi     Change line pitch
     lpix    If set, lpi changes orvi, otherwise changes
     orl
     chr     Change steps per column
     cvr     Change steps per line
.fi
.in -2
.sp

.sp
.LP
The \fBcpi\fR and \fBlpi\fR string capabilities are each used with a single argument, the pitch in columns (or characters) and lines per inch, respectively. The \fBchr\fR and \fBcvr\fR string capabilities are each used with a single argument, the number of steps per column and line, respectively.
.sp
.LP
Using any of the control sequences in these strings will imply a change in some of the values of \fBorc\fR, \fBorhi\fR, \fBorl\fR, and \fBorvi\fR. Also, the distance moved when a wide character is printed, \fBwidcs\fR, changes in relation to \fBorc\fR. The distance moved when a character is printed in micro mode, \fBmcs\fR, changes similarly, with one exception:  if the distance is 0 or 1, then no change is assumed (see items marked with  * in the following table).
.sp
.LP
Programs that use \fBcpi\fR, \fBlpi\fR, \fBchr\fR, or \fBcvr\fR should recalculate the printer resolution (and should recalculate other values\(em see "Effect of Changing Printing Resolution" under "Dot-Mapped Graphics").
.sp
.in +2
.nf
    Specification of Printer Resolution
     Effects of Changing the Character/Line Pitches

   Before            After

Using cpi with cpix clear:
 $bold orhi '$   orhi
 $bold orc '$    $bold orc = bold orhi over V sub italic cpi$

 Using cpi with cpix set:
 $bold orhi '$   $bold orhi = bold orc cdot V sub italic cpi$
 $bold orc '$    $bold orc$

 Using lpi with lpix clear:
 $bold orvi '$   $bold orvi$
 $bold orl '$    $bold orl = bold orvi over V sub italic lpi$

 Using lpi with lpix set:
 $bold orvi '$   $bold orvi = bold orl cdot V sub italic lpi$
 $bold orl '$    $bold orl$

 Using chr:
 $bold orhi '$   $bold orhi$
 $bold orc '$    $V sub italic chr$

 Using cvr:
 $bold orvi '$   $bold orvi$
 $bold orl '$    $V sub italic cvr$

 Using cpi or chr:
 $bold widcs '$  $bold widcs = bold {widcs '} bold orc over { bold {orc '} }$
 $bold mcs '$    $bold mcs = bold {mcs '} bold orc over { bold {orc '} }$
.fi
.in -2
.sp

.sp
.LP
$V sub italic cpi$, $V sub italic lpi$, $V sub italic chr$, and $V sub italic cvr$ are the arguments used with \fBcpi\fR, \fBlpi\fR, \fBchr\fR, and \fBcvr\fR, respectively. The prime marks (\|'\|) indicate the old values.
.SS "Section 2-4: Capabilities that Cause Movement"
.sp
.LP
In the following descriptions, ``movement'' refers to the motion of the ``current position.'' With video terminals this would be the cursor; with some printers this is the carriage position. Other printers have different equivalents. In general, the current position is where a character would be displayed if printed.
.sp
.LP
\fBterminfo\fR has string capabilities for control sequences that cause movement a number of full columns or lines. It also has equivalent string capabilities for control sequences that cause movement a number of smallest steps.
.sp
.in +2
.nf
String Capabilities for Motion

     mcub1   Move 1 step left
     mcuf1   Move 1 step right
     mcuu1   Move 1 step up
     mcud1   Move 1 step down
     mcub    Move N steps left
     mcuf    Move N steps right
     mcuu    Move N steps up
     mcud    Move N steps down
     mhpa    Move N steps from the left
     mvpa    Move N steps from the top
.fi
.in -2
.sp

.sp
.LP
The latter six strings are each used with a single argument, \fIN\fR.
.sp
.LP
Sometimes the motion is limited to less than the width or length of a page. Also, some printers don't accept absolute motion to the left of the current position. \fBterminfo\fR has capabilities for specifying these limits.
.sp
.in +2
.nf
Limits to Motion

     mjump     Limit on use of mcub1, mcuf1, mcuu1,  mcud1
     maddr      Limit on use of mhpa, mvpa
     xhpa        If set, hpa and mhpa can't move left
     xvpa        If set, vpa and mvpa can't move up
.fi
.in -2
.sp

.sp
.LP
If a printer needs to be in a ``micro mode'' for the motion capabilities described above to work, there are string capabilities defined to contain the control sequence to enter and exit this mode. A boolean is available for those printers where using a carriage return causes an automatic return to normal mode.
.sp
.in +2
.nf
   Entering/Exiting Micro Mode

     smicm   Enter micro mode
     rmicm   Exit micro mode
     crxm    Using cr exits micro mode
.fi
.in -2
.sp

.sp
.LP
The movement made when a character is printed in the rightmost position varies among printers. Some make no movement, some move to the beginning of the next line, others move to the beginning of the same line. \fBterminfo\fRhas boolean capabilities for describing all three cases.
.sp
.in +2
.nf
               What Happens After Character
                Printed in Rightmost Position

     sam     Automatic move to beginning of same line
.fi
.in -2
.sp

.sp
.LP
Some printers can be put in a mode where the normal direction of motion is reversed. This mode can be especially useful when there are no capabilities for leftward or upward motion, because those capabilities can be built from the motion reversal capability and the rightward or downward motion capabilities. It is best to leave it up to an application to build the leftward or upward capabilities, though, and not enter them in the \fBterminfo\fR database. This allows several reverse motions to be strung together without intervening wasted steps that leave and reenter reverse mode.
.sp
.in +2
.nf
Entering/Exiting Reverse Modes

     slm     Reverse sense of horizontal motions
     rlm     Restore sense of horizontal motions
     sum     Reverse sense of vertical motions
     rum     Restore sense of vertical motions

     While sense of horizontal motions reversed:
     mcub1   Move 1 step right
     mcuf1   Move 1 step left
     mcub    Move N steps right
     mcuf    Move N steps left
     cub1    Move 1 column right
     cuf1    Move 1 column left
     cub     Move N columns right
     cuf     Move N columns left

     While sense of vertical motions reversed:
     mcuu1   Move 1 step down
     mcud1   Move 1 step up
     mcuu    Move N steps down
     mcud    Move N steps up
     cuu1    Move 1 line down
     cud1    Move 1 line up
     cuu     Move N lines down
     cud     Move N lines up
.fi
.in -2
.sp

.sp
.LP
The reverse motion modes should not affect the \fBmvpa\fR and \fBmhpa\fR absolute motion capabilities. The reverse vertical motion mode should, however, also reverse the action of the line ``wrapping'' that occurs when a character is printed in the right-most position. Thus printers that have the standard \fBterminfo\fR capability \fBam\fR defined should experience motion to the beginning of the previous line when a character is printed in the right-most position under reverse vertical motion mode.
.sp
.LP
The action when any other motion capabilities are used in reverse motion modes is not defined; thus, programs must exit reverse motion modes before using other motion capabilities.
.sp
.LP
Two miscellaneous capabilities complete the list of new motion capabilities. One of these is needed for printers that move the current position to the beginning of a line when certain control characters, such as ``line-feed'' or ``form-feed,'' are used. The other is used for the capability of suspending the motion that normally occurs after printing a character.
.sp
.in +2
.nf
Miscellaneous Motion Strings

     docr    List of control characters causing cr
     zerom   Prevent auto motion after printing next single character
.fi
.in -2
.sp

.SS "Margins"
.sp
.LP
\fBterminfo\fR provides two strings for setting margins on terminals:  one for the left and one for the right margin. Printers, however, have two additional margins, for the top and bottom margins of each page. Furthermore, some printers require not using motion strings to move the current position to a margin and then fixing the margin there, but require the specification of where a margin should be regardless of the current position. Therefore \fBterminfo\fR offers six additional strings for defining margins with printers.
.sp
.in +2
.nf
Setting Margins

     smgl    Set left margin at current column
     smgr    Set right margin at current column
     smgb    Set bottom margin at current line
     smgt    Set top margin at current line
     smgbp   Set bottom margin at line N
     smglp   Set left margin at column N
     smgrp   Set right margin at column N
     smgtp   Set top margin at line N
.fi
.in -2
.sp

.sp
.LP
The last four strings are used with one or more arguments that give the position of the margin or margins to set. If both of \fBsmglp\fR and \fBsmgrp\fR are set, each is used with a single argument, \fIN,\fR that gives the column number of the left and right margin, respectively. If both of \fBsmgtp\fR and \fBsmgbp\fR are set, each is used to set the top and bottom margin, respectively: \fBsmgtp\fR is used with a single argument, \fIN,\fR the line number of the top margin; however, \fBsmgbp\fR is used with two arguments, \fIN\fR and \fIM,\fR that give the line number of the bottom margin, the first counting from the top of the page and the second counting from the bottom. This accommodates the two styles of specifying the bottom margin in different manufacturers' printers. When coding a \fBterminfo\fR entry for a printer that has a settable bottom margin, only the first or second parameter should be used, depending on the printer. When writing an application that uses \fBsmgbp\fR to set the bottom margin, both arguments must be given.
.sp
.LP
If only one of \fBsmglp\fR and \fBsmgrp\fR is set, then it is used with two arguments, the column number of the left and right margins, in that order. Likewise, if only one of \fBsmgtp\fR and \fBsmgbp\fR is set, then it is used with two arguments that give the top and bottom margins, in that order, counting from the top of the page. Thus when coding a \fBterminfo\fR entry for a printer that requires setting both left and right or top and bottom margins simultaneously, only one of \fBsmglp\fR and \fBsmgrp\fR or \fBsmgtp\fR and \fBsmgbp\fR should be defined; the other should be left blank. When writing an application that uses these string capabilities, the pairs should be first checked to see if each in the pair is set or only one is set, and should then be used accordingly.
.sp
.LP
In counting lines or columns, line zero is the top line and column zero is the left-most column. A zero value for the second argument with \fBsmgbp\fR means the bottom line of the page.
.sp
.LP
All margins can be cleared with \fBmgc\fR.
.SS "Shadows, Italics, Wide Characters"
.sp
.LP
Five new sets of strings describe the capabilities printers have of enhancing printed text.
.sp
.in +2
.nf
Enhanced Printing

     sshm    Enter shadow-printing mode
     rshm    Exit shadow-printing mode
     sitm    Enter italicizing mode
     ritm    Exit italicizing mode
     swidm   Enter wide character mode
     rwidm   Exit wide character mode
     ssupm   Enter superscript mode
     rsupd
     m   Exit superscript mode
     supcs   List of characters available as superscripts
     ssubm   Enter subscript mode
     rsubm   Exit subscript mode
     subcs   List of characters available as subscripts
.fi
.in -2
.sp

.sp
.LP
If a printer requires the \fBsshm\fR control sequence before every character to be shadow-printed, the \fBrshm\fR string is left blank. Thus programs that find a control sequence in \fBsshm\fR but none in \fBrshm\fR should use the \fBsshm\fR control sequence before every character to be shadow-printed; otherwise, the \fBsshm\fR control sequence should be used once before the set of characters to be shadow-printed, followed by \fBrshm\fR. The same is also true of each of the \fBsitm\fR/\fBritm\fR, \fBswidm\fR/\fBrwidm\fR, \fBssupm\fR/\fBrsupm\fR, and \fBssubm\fR/ \fBrsubm\fR pairs.
.sp
.LP
Note that \fBterminfo\fR also has a capability for printing emboldened text (\fBbold\fR). While shadow printing and emboldened printing are similar in that they ``darken'' the text, many printers produce these two types of print in slightly different ways. Generally, emboldened printing is done by overstriking the same character one or more times. Shadow printing likewise usually involves overstriking, but with a slight movement up and/or to the side so that the character is ``fatter.''
.sp
.LP
It is assumed that enhanced printing modes are independent modes, so that it would be possible, for instance, to shadow print italicized subscripts.
.sp
.LP
As mentioned earlier, the amount of motion automatically made after printing a wide character should be given in \fBwidcs\fR.
.sp
.LP
If only a subset of the printable ASCII characters can be printed as superscripts or subscripts, they should be listed in \fBsupcs\fR or \fBsubcs\fR strings, respectively. If the \fBssupm\fR or \fBssubm\fR strings contain control sequences, but the corresponding \fBsupcs\fR or \fBsubcs\fR strings are empty, it is assumed that all printable ASCII characters are available as superscripts or subscripts.
.sp
.LP
Automatic motion made after printing a superscript or subscript is assumed to be the same as for regular characters. Thus, for example, printing any of the following three examples will result in equivalent motion:
.sp
.LP
\fBBi  B\fR(i)  B^i
.sp
.LP
Note that the existing \fBmsgr\fR boolean capability describes whether motion control sequences can be used while in ``standout mode.'' This capability is extended to cover the enhanced printing modes added here. \fBmsgr\fR should be set for those printers that accept any motion control sequences without affecting shadow, italicized, widened, superscript, or subscript printing. Conversely, if \fBmsgr\fR is not set, a program should end these modes before attempting any motion.
.SS "Section 2-5: Alternate Character Sets"
.sp
.LP
In addition to allowing you to define line graphics (described in Section 1-12), \fBterminfo\fR lets you define alternate character sets. The following capabilities cover printers and terminals with multiple selectable or definable character sets.
.sp
.in +2
.nf
Alternate Character Sets

     scs     Select character set N
     scsd    Start definition of character set N, M characters
     defc    Define character A, B dots wide, descender D
     rcsd    End definition of character set N
     csnm    List of character set names
     daisy   Printer has manually changed print-wheels
.fi
.in -2
.sp

.sp
.LP
The \fBscs\fR, \fBrcsd\fR, and \fBcsnm\fR strings are used with a single argument, \fIN\fR, a number from 0 to 63 that identifies the character set. The \fBscsd\fR string is also used with the argument \fIN\fR and another, \fIM\fR, that gives the number of characters in the set. The \fBdefc\fR string is used with three arguments: \fIA\fR gives the ASCII code representation for the character, \fIB\fR gives the width of the character in dots, and \fID\fR is zero or one depending on whether the character is a ``descender'' or not. The \fBdefc\fR string is also followed by a string of ``image-data'' bytes that describe how the character looks (see below).
.sp
.LP
Character set 0 is the default character set present after the printer has been initialized. Not every printer has 64 character sets, of course; using \fBscs\fR with an argument that doesn't select an available character set should cause a null result from \fBtparm\fR.
.sp
.LP
If a character set has to be defined before it can be used, the \fBscsd\fR control sequence is to be used before defining the character set, and the \fBrcsd\fR is to be used after. They should also cause a null result from \fBtparm\fR when used with an argument \fIN\fR that doesn't apply. If a character set still has to be selected after being defined, the \fBscs\fR control sequence should follow the \fBrcsd\fR control sequence. By examining the results of using each of the \fBscs\fR, \fBscsd\fR, and \fBrcsd\fR strings with a character set number in a call to \fBtparm\fR, a program can determine which of the three are needed.
.sp
.LP
Between use of the \fBscsd\fR and \fBrcsd\fR strings, the \fBdefc\fR string should be used to define each character. To print any character on printers covered by \fBterminfo\fR, the ASCII code is sent to the printer. This is true for characters in an alternate set as well as ``normal'' characters. Thus the definition of a character includes the ASCII code that represents it. In addition, the width of the character in dots is given, along with an indication of whether the character should descend below the print line (such as the lower case letter ``g'' in most character sets). The width of the character in dots also indicates the number of image-data bytes that will follow the \fBdefc\fR string. These image-data bytes indicate where in a dot-matrix pattern ink should be applied to ``draw'' the character; the number of these bytes and their form are defined below under ``Dot-Mapped Graphics.''
.sp
.LP
It's easiest for the creator of \fBterminfo\fR entries to refer to each character set by number; however, these numbers will be meaningless to the application developer. The \fBcsnm\fR string alleviates this problem by providing names for each number.
.sp
.LP
When used with a character set number in a call to \fBtparm\fR, the \fBcsnm\fR string will produce the equivalent name. These names should be used as a reference only. No naming convention is implied, although anyone who creates a \fBterminfo\fR entry for a printer should use names consistent with the names found in user documents for the printer. Application developers should allow a user to specify a character set by number (leaving it up to the user to examine the \fBcsnm\fR string to determine the correct number), or by name, where the application examines the \fBcsnm\fR string to determine the corresponding character set number.
.sp
.LP
These capabilities are likely to be used only with dot-matrix printers. If they are not available, the strings should not be defined. For printers that have manually changed print-wheels or font cartridges, the boolean \fBdaisy\fR is set.
.SS "Section 2-6: Dot-Matrix Graphics"
.sp
.LP
Dot-matrix printers typically have the capability of reproducing ``raster-graphics'' images. Three new numeric capabilities and three new string capabilities can help a program draw raster-graphics images independent of the type of dot-matrix printer or the number of pins or dots the printer can handle at one time.
.sp
.in +2
.nf
Dot-Matrix Graphics

     npins   Number of pins, N, in print-head
     spinv   Spacing of pins vertically in pins per inch
     spinh   Spacing of dots horizontally in dots per inch
     porder  Matches software bits to print-head pins
     sbim    Start printing bit image graphics, B bits wide
     rbim    End printing bit image graphics
.fi
.in -2
.sp

.sp
.LP
The \fBsbim\fR sring is used with a single argument, \fIB\fR, the width of the image in dots.
.sp
.LP
The model of dot-matrix or raster-graphics that \fBterminfo\fR presents is similar to the technique used for most dot-matrix printers: each pass of the printer's print-head is assumed to produce a dot-matrix that is \fIN\fR dots high and \fIB\fR dots wide. This is typically a wide, squat, rectangle of dots. The height of this rectangle in dots will vary from one printer to the next; this is given in the \fBnpins\fR numeric capability. The size of the rectangle in fractions of an inch will also vary; it can be deduced from the \fBspinv\fR and \fBspinh\fR numeric capabilities. With these three values an application can divide a complete raster-graphics image into several horizontal strips, perhaps interpolating to account for different dot spacing vertically and horizontally.
.sp
.LP
The \fBsbim\fR and \fBrbim\fR strings are used to start and end a dot-matrix image, respectively. The \fBsbim\fR string is used with a single argument that gives the width of the dot-matrix in dots. A sequence of ``image-data bytes'' are sent to the printer after the \fBsbim\fR string and before the \fBrbim\fR string. The number of bytes is a integral multiple of the width of the dot-matrix; the multiple and the form of each byte is determined by the \fBporder\fR string as described below.
.sp
.LP
The \fBporder\fR string is a comma separated list of pin numbers optionally followed by an numerical offset. The offset, if given, is separated from the list with a semicolon. The position of each pin number in the list corresponds to a bit in an 8-bit data byte. The pins are numbered consecutively from 1 to \fBnpins\fR, with 1 being the top pin. Note that the term ``pin'' is used loosely here; ``ink-jet'' dot-matrix printers don't have pins, but can be considered to have an equivalent method of applying a single dot of ink to paper. The bit positions in \fBporder\fR are in groups of 8, with the first position in each group the most significant bit and the last position the least significant bit. An application produces 8-bit bytes in the order of the groups in \fBporder\fR.
.sp
.LP
An application computes the ``image-data bytes'' from the internal image, mapping vertical dot positions in each print-head pass into 8-bit bytes, using a 1 bit where ink should be applied and 0 where no ink should be applied. This can be reversed (0 bit for ink, 1 bit for no ink) by giving a negative pin number. If a position is skipped in \fBporder\fR, a 0 bit is used. If a position has a lower case `x' instead of a pin number, a 1 bit is used in the skipped position. For consistency, a lower case `o' can be used to represent a 0 filled, skipped bit. There must be a multiple of 8 bit positions used or skipped in \fBporder\fR; if not, 0 bits are used to fill the last byte in the least significant bits. The offset, if given, is added to each data byte; the offset can be negative.
.sp
.LP
Some examples may help clarify the use of the \fBporder\fR string. The AT&T 470, AT&T 475 and C.Itoh 8510 printers provide eight pins for graphics. The pins are identified top to bottom by the 8 bits in a byte, from least significant to most. The \fBporder\fR strings for these printers would be \fB8,7,6,5,4,3,2,1\fR. The AT&T 478 and AT&T 479 printers also provide eight pins for graphics. However, the pins are identified in the reverse order. The \fBporder\fR strings for these printers would be \fB1,2,3,4,5,6,7,8\fR. The AT&T 5310, AT&T 5320, DEC LA100, and DEC LN03 printers provide six pins for graphics. The pins are identified top to bottom by the decimal values 1, 2, 4, 8, 16 and 32. These correspond to the low six bits in an 8-bit byte, although the decimal values are further offset by the value 63. The \fBporder\fR string for these printers would be \fB,,6,5,4,3,2,1;63\fR, or alternately \fBo,o,6,5,4,3,2,1;63\fR.
.SS "Section 2-7: Effect of Changing Printing Resolution"
.sp
.LP
If the control sequences to change the character pitch or the line pitch are used, the pin or dot spacing may change:
.sp
.in +2
.nf
    Dot-Matrix Graphics
     Changing the Character/Line Pitches

     cpi     Change character pitch
     cpix    If set, cpi changes spinh
     lpi     Change line pitch
     lpix    If set, lpi changes spinv
.fi
.in -2
.sp

.sp
.LP
Programs that use \fBcpi\fR or \fBlpi\fR should recalculate the dot spacing:
.sp
.in +2
.nf
Dot-Matrix Graphics
     Effects of Changing the Character/Line Pitches

     Before               After

Using cpi with cpix clear:
 $bold spinh '$    $bold spinh$

Using cpi with cpix set:
 $bold spinh '$    $bold spinh = bold spinh ' cdot bold orhi over 
                          { bold {orhi '} }$
     
Using lpi with lpix clear:
 $bold spinv '$    $bold spinv$

Using lpi with lpix set:
 $bold spinv '$    $bold spinv = bold {spinv '} cdot bold orhi over 
                          { bold {orhi '}}$

Using chr:
 $bold spinh '$    $bold spinh$

Using cvr:
 $bold spinv '$    $bold spinv$
.fi
.in -2
.sp

.sp
.LP
\fBorhi\fR' and \fBorhi\fR are the values of the horizontal resolution in steps per inch, before using \fBcpi\fR and after using \fBcpi\fR, respectively. Likewise, \fBorvi'\fR and \fBorvi\fR are the values of the vertical resolution in steps per inch, before using \fBlpi\fR and after using \fBlpi\fR, respectively. Thus, the changes in the dots per inch for dot-matrix graphics follow the changes in steps per inch for printer resolution.
.SS "Section 2-8: Print Quality"
.sp
.LP
Many dot-matrix printers can alter the dot spacing of printed text to produce near ``letter quality'' printing or ``draft quality'' printing. Usually it is important to be able to choose one or the other because the rate of printing generally falls off as the quality improves. There are three new strings used to describe these capabilities.
.sp
.in +2
.nf
Print Quality

     snlq    Set near-letter quality print
     snrmq   Set normal quality print
     sdrfq   Set draft quality print
.fi
.in -2
.sp

.sp
.LP
The capabilities are listed in decreasing levels of quality. If a printer doesn't have all three levels, one or two of the strings should be left blank as appropriate.
.SS "Section 2-9: Printing Rate and Buffer Size"
.sp
.LP
Because there is no standard protocol that can be used to keep a program synchronized with a printer, and because modern printers can buffer data before printing it, a program generally cannot determine at any time what has been printed. Two new numeric capabilities can help a program estimate what has been printed.
.sp
.in +2
.nf
Print Rate/Buffer Size

     cps     Nominal print rate in characters per second
     bufsz   Buffer capacity in characters
.fi
.in -2
.sp

.sp
.LP
\fBcps\fR is the nominal or average rate at which the printer prints characters; if this value is not given, the rate should be estimated at one-tenth the prevailing baud rate. \fBbufsz\fR is the maximum number of subsequent characters buffered before the guaranteed printing of an earlier character, assuming proper flow control has been used. If this value is not given it is assumed that the printer does not buffer characters, but prints them as they are received.
.sp
.LP
As an example, if a printer has a 1000-character buffer, then sending the letter ``a'' followed by 1000 additional characters is guaranteed to cause the letter ``a'' to print. If the same printer prints at the rate of 100 characters per second, then it should take 10 seconds to print all the characters in the buffer, less if the buffer is not full. By keeping track of the characters sent to a printer, and knowing the print rate and buffer size, a program can synchronize itself with the printer.
.sp
.LP
Note that most printer manufacturers advertise the maximum print rate, not the nominal print rate. A good way to get a value to put in for \fBcps\fR is to generate a few pages of text, count the number of printable characters, and then see how long it takes to print the text.
.sp
.LP
Applications that use these values should recognize the variability in the print rate. Straight text, in short lines, with no embedded control sequences will probably print at close to the advertised print rate and probably faster than the rate in \fBcps\fR. Graphics data with a lot of control sequences, or very long lines of text, will print at well below the advertised rate and below the rate in \fBcps\fR. If the application is using \fBcps\fR to decide how long it should take a printer to print a block of text, the application should pad the estimate. If the application is using \fBcps\fR to decide how much text has already been printed, it should shrink the estimate. The application will thus err in favor of the user, who wants, above all, to see all the output in its correct place.
.SH FILES
.sp
.ne 2
.mk
.na
\fB\fB/usr/share/lib/terminfo/?/*\fR\fR
.ad
.sp .6
.RS 4n
compiled terminal description database
.RE

.sp
.ne 2
.mk
.na
\fB\fB/usr/share/lib/.COREterm/?/*\fR\fR
.ad
.sp .6
.RS 4n
subset of compiled terminal description database
.RE

.sp
.ne 2
.mk
.na
\fB\fB/usr/share/lib/tabset/*\fR\fR
.ad
.sp .6
.RS 4n
tab settings for some terminals, in a format appropriate to be output to the terminal (escape sequences that set margins and tabs)
.RE

.SH SEE ALSO
.sp
.LP
\fBls\fR(1), \fBpg\fR(1), \fBstty\fR(1), \fBtput\fR(1), \fBtty\fR(1), \fBvi\fR(1), \fBinfocmp\fR(1M), \fBtic\fR(1M), \fBprintf\fR(3C), \fBcurses\fR(3CURSES), \fBcurses\fR(3XCURSES)
.SH NOTES
.sp
.LP
The most effective way to prepare a terminal description is by imitating the description of a similar terminal in \fBterminfo\fR and to build up a description gradually, using partial descriptions with a screen oriented editor, such as \fBvi\fR, to check that they are correct. To easily test a new terminal description the environment variable \fBTERMINFO\fR  can be set to the pathname of a directory containing the compiled description, and programs will look there rather than in \fB/usr/share/lib/terminfo\fR.
