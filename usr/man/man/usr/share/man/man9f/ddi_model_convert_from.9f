'\" te
.\"  Copyright (c) 2001 Sun Microsystems, Inc.  All Rights Reserved.
.TH ddi_model_convert_from 9F "8 Feb 2001" "SunOS 5.11" "Kernel Functions for Drivers"
.SH NAME
ddi_model_convert_from \- determine data model type mismatch
.SH SYNOPSIS
.LP
.nf
#include <sys/ddi.h>
#include <sys/sunddi.h>

\fB uint_t\fR\fBddi_model_convert_from\fR(\fBuint_t\fR \fImodel\fR);
.fi

.SH INTERFACE LEVEL
.sp
.LP
Solaris DDI specific (Solaris DDI).
.SH PARAMETERS
.sp
.ne 2
.mk
.na
\fB\fImodel\fR \fR
.ad
.RS 10n
.rt  
The data model type of the current thread.
.RE

.SH DESCRIPTION
.sp
.LP
\fBddi_model_convert_from()\fR is used to determine if the current thread uses a different \fBC\fR Language Type Model than the device driver. The 64-bit version of Solaris will require a 64-bit kernel to support both 64-bit and 32-bit user mode programs. The difference between a 32-bit program and a 64-bit program is in its \fBC\fR Language Type Model: a 32-bit program is \fBILP32\fR (integer, longs, and pointers are 32-bit) and a 64-bit program is \fBLP64\fR (longs and pointers are 64-bit). There are a number of driver entry points such as \fBioctl\fR(9E) and \fBmmap\fR(9E) where it is necessary to identify the \fBC\fR Language Type Model of the user-mode originator of an kernel event. For example any data which flows between programs and the device driver or vice versa need to be identical in format. A 64-bit device driver may need to modify the format of the data before sending it to a 32-bit application. \fBddi_model_convert_from()\fR is used to determine if data that is passed between the device driver and the application requires reformatting to any non-native data model.
.SH RETURN VALUES
.sp
.ne 2
.mk
.na
\fB\fBDDI_MODEL_ILP32\fR \fR
.ad
.RS 20n
.rt  
A conversion to/from \fBILP32\fR is necessary.
.RE

.sp
.ne 2
.mk
.na
\fB\fBDDI_MODEL_NONE\fR \fR
.ad
.RS 20n
.rt  
No conversion is necessary. Current thread and driver use the same data model.
.RE

.SH CONTEXT
.sp
.LP
\fBddi_model_convert_from()\fR can be called from any context.
.SH EXAMPLES
.LP
\fBExample 1 \fR: Using \fBddi_model_convert_from()\fR in the \fBioctl()\fR entry point to support both 32-bit and 64-bit applications.
.sp
.LP
The following is an example how to use \fBddi_model_convert_from()\fR in the \fBioctl()\fR entry point to support both 32-bit and 64-bit applications.

.sp
.in +2
.nf
struct passargs32 {
        int len;
        caddr32_t addr;
};
 
struct passargs {
        int len;
        caddr_t addr;
};
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp) {
        struct passargs pa;
 
        switch (ddi_model_convert_from(mode & FMODELS)) {
            case DDI_MODEL_ILP32:
            {
                struct passargs32 pa32;

                ddi_copyin(arg, &pa32, sizeof (struct passargs32), mode);
                pa.len = pa32.len;
                pa.address = pa32.address;
                break;
            }
            case DDI_MODEL_NONE:
                ddi_copyin(arg, &pa, sizeof (struct passargs), mode);
                break;
        }

        do_ioctl(&pa);
        .\|.\|.\|.
}
.fi
.in -2

.SH SEE ALSO
.sp
.LP
\fBioctl\fR(9E), \fBmmap\fR(9E), \fBddi_mmap_get_model\fR(9F) 
.sp
.LP
\fIWriting Device Drivers\fR 
