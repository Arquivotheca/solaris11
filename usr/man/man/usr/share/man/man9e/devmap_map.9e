'\" te
.\"  Copyright (c) 1996, Sun Microsystems, Inc.  All Rights Reserved
.TH devmap_map 9E "7 Jan 1997" "SunOS 5.11" "Driver Entry Points"
.SH NAME
devmap_map \- device mapping create entry point
.SH SYNOPSIS
.LP
.nf
#include <sys/ddi.h>
#include <sys/sunddi.h>



\fBint prefix\fR\fBdevmap_map\fR(\fBdevmap_cookie_t\fR \fIdhp\fR, \fBdev_t\fR \fIdev\fR, 
     \fBuint_t\fR \fIflags\fR, \fBoffset_t\fR \fIoff\fR, \fBsize_t\fR \fIlen\fR, \fBvoid **\fR\fIpvtp\fR);
.fi

.SH INTERFACE LEVEL
.sp
.LP
Solaris DDI specific (Solaris DDI).
.SH ARGUMENTS
.sp
.ne 2
.mk
.na
\fB\fIdhp\fR \fR
.ad
.RS 10n
.rt  
An opaque mapping handle that the system uses to describe the mapping currently being created.
.RE

.sp
.ne 2
.mk
.na
\fB\fIdev\fR \fR
.ad
.RS 10n
.rt  
The device whose memory is to be mapped.
.RE

.sp
.ne 2
.mk
.na
\fB\fIflags\fR \fR
.ad
.RS 10n
.rt  
Flags indicating type of mapping. Possible values are: 
.sp
.ne 2
.mk
.na
\fB\fBMAP_PRIVATE\fR \fR
.ad
.RS 16n
.rt  
Changes are private.
.RE

.sp
.ne 2
.mk
.na
\fB\fBMAP_SHARED\fR \fR
.ad
.RS 16n
.rt  
Changes should be shared.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fIoff\fR \fR
.ad
.RS 10n
.rt  
User offset within the logical device memory at which the mapping begins.
.RE

.sp
.ne 2
.mk
.na
\fB\fIlen\fR \fR
.ad
.RS 10n
.rt  
Length (in bytes) of the memory to be mapped.
.RE

.sp
.ne 2
.mk
.na
\fB\fIpvtp\fR \fR
.ad
.RS 10n
.rt  
A pointer to be filled in by device drivers with the driver private mapping data.
.RE

.SH DESCRIPTION
.sp
.LP
The \fBdevmap_map()\fR entry point is an optional routine that allows drivers to perform additional processing or to allocate private resources during the mapping setup time.  For example, in order for device drivers to support context switching, the drivers allocate private mapping data and associate the private data with the mapping parameters in the \fBdevmap_map()\fR entry point.
.sp
.LP
The system calls \fBdevmap_map()\fR after the user mapping to device physical memory has been established. (For example, after the  \fBdevmap\fR(9E) entry point is called.)
.sp
.LP
\fBdevmap_map()\fR receives a pointer to the driver private data  for this mapping in \fIpvtp\fR. The system expects the driver to allocate its private data and set  \fI*pvtp\fR to the allocated data.  The driver must store \fIoff\fR and \fIlen\fR, which define the range of the mapping, in its private data.  Later, when the system calls \fBdevmap_unmap\fR(9E), the driver will use the \fIoff\fR and  \fIlen\fR stored in \fIpvtp\fR to check if the entire mapping, or just a part of it, is being unmapped. If only a part of the mapping is being unmapped, the driver must allocate  a new private data for the remaining mapping before freeing the old private data.  The driver will receive \fI*pvtp\fR in subsequent event notification callbacks.
.sp
.LP
If the driver support context switching,  it should store the mapping handle  \fIdhp\fR in its private data \fI*pvtp\fR for later use in \fBdevmap_unload\fR(9F). 
.sp
.LP
For a driver that supports context switching, \fIflags\fR indicates whether or not the driver should allocate a private context  for the mapping.  For example, a driver may allocate a memory region to store the device context if \fIflags\fR is set to  \fBMAP_PRIVATE\fR. 
.SH RETURN VALUES
.sp
.LP
\fBdevmap_map()\fR returns the following values:
.sp
.ne 2
.mk
.na
\fB\fB0\fR \fR
.ad
.RS 12n
.rt  
Successful completion.
.RE

.sp
.ne 2
.mk
.na
\fBNon-zero\fR
.ad
.RS 12n
.rt  
An error occurred.
.RE

.SH EXAMPLES
.LP
\fBExample 1 \fR \fBdevmap_map()\fRimplementation
.sp
.LP
The following shows an example implementation for \fBdevmap_map()\fR.

.sp
.in +2
.nf
static int
xxdevmap_map(devmap_cookie_t dhp, dev_t dev, uint_t flags, \e
     offset_t off,size_t len, void **pvtp)
{
	struct xx_resources  *pvt;
	struct xx_context *this_context;
	struct xx_softc *softc;
	softc = ddi_get_soft_state(statep, getminor(dev));

	this_context = get_context(softc, off, len);

	/* allocate resources for the mapping  - Device dependent */
	pvt = kmem_zalloc(sizeof (struct xx_resources), KM_SLEEP);

	pvt->off = off;
	pvt->len = len;
	pvt->dhp = dhp;
	pvt->ctx = this_context;
	*pvtp = pvt;
}
.fi
.in -2

.SH SEE ALSO
.sp
.LP
\fBdevmap_unmap\fR(9E), \fBdevmap_unload\fR(9F), \fBdevmap_callback_ctl\fR(9S) 
.sp
.LP
\fIWriting Device Drivers\fR 
