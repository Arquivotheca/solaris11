'\" te
.\" Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
.\" Copyright 1989 AT&T
.TH streamio 7I "12 Jul 2010" "SunOS 5.11" "Ioctl Requests"
.SH NAME
streamio \- STREAMS ioctl commands
.SH SYNOPSIS
.LP
.nf
#include <sys/types.h>
#include <stropts.h>
#include <sys/conf.h>

\fBint\fR \fBioctl\fR(\fBint\fR \fIfildes\fR, \fBint\fR \fIcommand\fR, \fB\&... /*arg*/\fR);
.fi

.SH DESCRIPTION
.sp
.LP
STREAMS (see \fBIntro\fR(3)) \fBioctl\fR commands are a subset of the \fBioctl\fR(2) commands and perform a variety of control functions on streams.
.sp
.LP
The \fIfildes\fR argument is an open file descriptor that refers to a stream.  The \fIcommand\fR argument determines the control function to be performed as described below. The \fIarg\fR argument represents additional information that is needed by this command. The type of \fIarg\fR depends upon the command, but it is generally an integer or a pointer to a command-specific data structure.  The \fIcommand\fR and \fIarg\fR arguments are interpreted by the STREAM head. Certain combinations of these arguments may be passed to a module or driver in the stream.
.sp
.LP
Since these STREAMS commands are \fBioctls\fR, they are subject to the errors described in \fBioctl\fR(2). In addition to those errors, the call will fail with \fBerrno\fR set to \fBEINVAL,\fR without processing a control function, if the STREAM referenced by \fIfildes\fR is linked below a multiplexor, or if \fIcommand\fR is not a valid value for a stream.
.sp
.LP
Also, as described in \fBioctl\fR(2), STREAMS modules and drivers can detect errors. In this case, the module or driver sends an error message to the STREAM head containing an error value. This causes subsequent calls to fail with \fBerrno\fR set to this value.
.SH IOCTLS
.sp
.LP
The following \fBioctl\fR commands, with error values indicated, are applicable to all STREAMS files:
.sp
.ne 2
.mk
.na
\fB\fBI_PUSH\fR\fR
.ad
.RS 15n
.rt  
Pushes the module whose name is pointed to by \fIarg\fR onto the top of the current stream, just below the STREAM head. If the STREAM is a pipe, the module will be inserted between the stream heads of both ends of the pipe. It then calls the open routine of the newly-pushed module. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 11n
.rt  
Invalid module name.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 11n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 11n
.rt  
Open routine of new module failed.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 11n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOTSUP\fR\fR
.ad
.RS 11n
.rt  
Pushing a module is not supported on this stream.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_POP\fR\fR
.ad
.RS 15n
.rt  
Removes the module just below the STREAM head of the STREAM pointed to by \fIfildes\fR. To remove a module from a pipe requires that the module was pushed on the side it is being removed from. \fIarg\fR should be  \fB0\fR in an \fBI_POP\fR request. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 11n
.rt  
No module present in the stream.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 11n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEPERM\fR\fR
.ad
.RS 11n
.rt  
Attempt to pop through an anchor by an unprivileged process.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOTSUP\fR\fR
.ad
.RS 11n
.rt  
Removal is not supported.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_ANCHOR\fR\fR
.ad
.RS 15n
.rt  
Positions the stream anchor to be at the stream's module directly below the stream head. Once this has been done, only a privileged process may pop modules below the anchor on the stream. \fIarg\fR must be \fB0\fR in an \fBI_ANCHOR\fR request. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Request to put an anchor on a pipe.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_LOOK\fR\fR
.ad
.RS 15n
.rt  
Retrieves the name of the module just below the stream head of the stream pointed to by \fIfildes\fR, and places it in a null terminated character string pointed at by \fIarg\fR. The buffer pointed to by \fIarg\fR should be at least \fBFMNAMESZ\fR+1 bytes long. This requires the declaration \fB#include <sys/conf.h>\fR. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
No module present in stream.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_FLUSH\fR\fR
.ad
.RS 15n
.rt  
This request flushes all input and/or output queues, depending on the value of \fIarg\fR. Legal \fIarg\fR values are:
.sp
.ne 2
.mk
.na
\fBFLUSHR\fR
.ad
.RS 11n
.rt  
Flush read queues.
.RE

.sp
.ne 2
.mk
.na
\fBFLUSHW\fR
.ad
.RS 11n
.rt  
Flush write queues.
.RE

.sp
.ne 2
.mk
.na
\fBFLUSHRW\fR
.ad
.RS 11n
.rt  
Flush read and write queues.
.RE

If a pipe or FIFO does not have any modules pushed, the read queue of the stream head on either end is flushed depending on the value of \fIarg\fR.
.sp
If \fBFLUSHR\fR is set and \fIfildes\fR is a pipe, the read queue for that end of the pipe is flushed and the write queue for the other end is flushed. If \fIfildes\fR is a FIFO, both queues are flushed.
.sp
If \fBFLUSHW\fR is set and \fIfildes\fR is a pipe and the other end of the pipe exists, the read queue for the other end of the pipe is flushed and the write queue for this end is flushed. If \fIfildes\fR is a FIFO, both queues of the FIFO are flushed.
.sp
If \fBFLUSHRW\fR is set, all read queues are flushed, that is, the read queue for the FIFO and the read queue on both ends of the pipe are flushed.
.sp
Correct flush handling of a pipe or FIFO with modules pushed is achieved via the \fBpipemod\fR module.  This module should be the first module pushed onto a pipe so that it is at the midpoint of the pipe itself.
.sp
On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBENOSR\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate buffers for flush message due to insufficient stream memory resources.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Invalid \fIarg\fR value.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_FLUSHBAND\fR\fR
.ad
.RS 15n
.rt  
Flushes a particular band of messages. \fIarg\fR points to a \fBbandinfo\fR structure that has the following members:
.sp
.in +2
.nf
unsigned char bi_pri;
int bi_flag;
.fi
.in -2

The \fBbi_flag\fR field may be one of \fBFLUSHR\fR, \fBFLUSHW\fR, or \fBFLUSHRW\fR as described earlier.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_SETSIG\fR\fR
.ad
.RS 15n
.rt  
Informs the stream head that the user wishes the kernel to issue the \fBSIGPOLL\fR signal (see \fBsignal\fR(3C)) when a particular event has occurred on the stream associated with \fIfildes\fR. \fBI_SETSIG\fR supports an asynchronous processing capability in streams. The value of \fIarg\fR is a bitmask that specifies the events for which the user should be signaled. It is the bitwise OR of any combination of the following constants:
.sp
.ne 2
.mk
.na
\fB\fBS_INPUT\fR\fR
.ad
.RS 13n
.rt  
Any message other than an \fBM_PCPROTO\fR has arrived on a stream head read queue. This event is maintained for compatibility with previous releases. This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_RDNORM\fR\fR
.ad
.RS 13n
.rt  
An ordinary (non-priority) message has arrived on a stream head read queue. This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_RDBAND\fR\fR
.ad
.RS 13n
.rt  
A priority band message (band > 0) has arrived on a stream head read queue. This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_HIPRI\fR\fR
.ad
.RS 13n
.rt  
A high priority message is present on the stream head read queue. This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_OUTPUT\fR\fR
.ad
.RS 13n
.rt  
The write queue just below the stream head is no longer full. This notifies the user that there is room on the queue for sending (or writing) data downstream.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_WRNORM\fR\fR
.ad
.RS 13n
.rt  
This event is the same as \fBS_OUTPUT\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_WRBAND\fR\fR
.ad
.RS 13n
.rt  
A priority band greater than 0 of a queue downstream exists and is writable.  This notifies the user that there is room on the queue for sending (or writing) priority data downstream.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_MSG\fR\fR
.ad
.RS 13n
.rt  
A STREAMS signal message that contains the \fBSIGPOLL\fR signal has reached the front of the stream head read queue.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_ERROR\fR\fR
.ad
.RS 13n
.rt  
An \fBM_ERROR\fR message has reached the stream head.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_HANGUP\fR\fR
.ad
.RS 13n
.rt  
An \fBM_HANGUP\fR message has reached the stream head.
.RE

.sp
.ne 2
.mk
.na
\fB\fBS_BANDURG\fR\fR
.ad
.RS 13n
.rt  
When used in conjunction with \fBS_RDBAND\fR, \fBSIGURG\fR is generated instead of \fBSIGPOLL\fR when a priority message reaches the front of the stream head read queue.
.RE

A user process may choose to be signaled only of high priority messages by setting the \fIarg\fR bitmask to the value \fBS_HIPRI\fR.
.sp
Processes that wish to receive \fBSIGPOLL\fR signals must explicitly register to receive them using \fBI_SETSIG\fR. If several processes register to receive this signal for the same event on the same stream, each process will be signaled when the event occurs.
.sp
If the value of \fIarg\fR is zero, the calling process will be unregistered and will not receive further \fBSIGPOLL\fR signals.  On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR value is invalid or \fIarg\fR is zero and process is not registered to receive the \fBSIGPOLL\fR signal.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
Allocation of a data structure to store the signal request failed.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_GETSIG\fR\fR
.ad
.RS 15n
.rt  
Returns the events for which the calling process is currently registered to be sent a \fBSIGPOLL\fR signal.  The events are returned as a bitmask pointed to by \fIarg\fR, where the events are those specified in the description of \fBI_SETSIG\fR above. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Process not registered to receive the \fBSIGPOLL\fR signal.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_FIND\fR\fR
.ad
.RS 15n
.rt  
Compares the names of all modules currently present in the stream to the name pointed to by \fIarg\fR, and returns 1 if the named module is present in the stream. It returns 0 if the named module is not present. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR does not contain a valid module name.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_PEEK\fR\fR
.ad
.RS 15n
.rt  
Allows a user to retrieve the information in the first message on the stream head read queue without taking the message off the queue. \fBI_PEEK\fR is analogous to \fBgetmsg\fR(2) except that it does not remove the message from the queue. \fIarg\fR points to a \fBstrpeek\fR structure, which contains the following members:
.sp
.in +2
.nf
struct strbuf ctlbuf;
struct strbuf	databuf;
long flags;
.fi
.in -2

The \fBmaxlen\fR field in the \fBctlbuf\fR and \fBdatabuf\fR \fBstrbuf\fR structures (see \fBgetmsg\fR(2)) must be set to the number of bytes of control information and/or data information, respectively, to retrieve. \fBflags\fR may be set to \fBRS_HIPRI\fR or \fB0\fR. If \fBRS_HIPRI\fR is set, \fBI_PEEK\fR will look for a high priority message on the stream head read queue. Otherwise, \fBI_PEEK\fR will look for the first message on the stream head read queue.
.sp
\fBI_PEEK\fR returns \fB1\fR if a message was retrieved, and returns \fB0\fR if no message was found on the stream head read queue. It does not wait for a message to arrive. On return, \fBctlbuf\fR specifies information in the control buffer, \fBdatabuf\fR specifies information in the data buffer, and \fBflags\fR contains the value \fBRS_HIPRI\fR or \fB0\fR. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 11n
.rt  
\fIarg\fR points, or the buffer area specified in \fBctlbuf\fR or \fBdatabuf\fR is, outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEBADMSG\fR\fR
.ad
.RS 11n
.rt  
Queued message to be read is not valid for \fBI_PEEK\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 11n
.rt  
Illegal value for \fBflags\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOSR\fR\fR
.ad
.RS 11n
.rt  
Unable to allocate buffers to perform the I_PEEK due to insufficient STREAMS  memory resources.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_SRDOPT\fR\fR
.ad
.RS 15n
.rt  
Sets the read mode (see \fBread\fR(2)) using the value of the argument \fIarg\fR. Legal \fIarg\fR values are:
.sp
.ne 2
.mk
.na
\fBRNORM\fR
.ad
.RS 9n
.rt  
Byte-stream mode, the default.
.RE

.sp
.ne 2
.mk
.na
\fBRMSGD\fR
.ad
.RS 9n
.rt  
Message-discard mode.
.RE

.sp
.ne 2
.mk
.na
\fBRMSGN\fR
.ad
.RS 9n
.rt  
Message-nondiscard mode.
.RE

In addition, the stream head's treatment of control messages may be changed by setting the following flags in \fIarg\fR:
.sp
.ne 2
.mk
.na
\fBRPROTNORM\fR
.ad
.RS 13n
.rt  
Reject \fBread()\fR with \fBEBADMSG\fR if a control message is at the front of the stream head read queue.
.RE

.sp
.ne 2
.mk
.na
\fBRPROTDAT\fR
.ad
.RS 13n
.rt  
Deliver the control portion of a message as data when a user issues \fBread()\fR. This is the default behavior.
.RE

.sp
.ne 2
.mk
.na
\fBRPROTDIS\fR
.ad
.RS 13n
.rt  
Discard the control portion of a message, delivering any data portion, when a user issues a \fBread\fR(\|).
.RE

On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not one of the above legal values, or \fIarg\fR is the bitwise inclusive \fBOR\fR of \fBRMSGD\fR and \fBRMSGN\fR.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_GRDOPT\fR\fR
.ad
.RS 15n
.rt  
Returns the current read mode setting in an \fBint\fR pointed to by the argument \fIarg\fR. Read modes are described in \fBread\fR(\|). On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_NREAD\fR\fR
.ad
.RS 15n
.rt  
Counts the number of data bytes in data blocks in the first message on the stream head read queue, and places this value in the location pointed to by \fIarg\fR. The return value for the command is the number of messages on the stream head read queue. For example, if zero is returned in \fIarg\fR, but the \fBioctl\fR return value is greater than zero, this indicates that a zero-length message is next on the queue. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_FDINSERT\fR\fR
.ad
.RS 15n
.rt  
Creates a message from specified buffer(s), adds information about another stream and sends the message downstream. The message contains a control part and an optional data part. The data and control parts to be sent are distinguished by placement in separate buffers, as described below.
.sp
The \fIarg\fR argument points to a \fBstrfdinsert\fR structure, which contains the following members:
.sp
.in +2
.nf
struct  strbuf  ctlbuf;
struct  strbuf	databuf;
t_uscalar_t  flags;
int  fildes;
int  offset;
.fi
.in -2

The \fBlen\fR member in the \fBctlbuf strbuf\fR structure (see \fBputmsg\fR(2)) must be set to the size of a  \fBt_uscalar_t\fR plus the number of bytes of control information to be sent with the message. The \fBfildes\fR member specifies the file descriptor of the other stream, and the \fBoffset\fR member, which must be suitably aligned for use as a \fBt_uscalar_t\fR, specifies the offset from the start of the control buffer where \fBI_FDINSERT\fR will store a  \fBt_uscalar_t\fR whose interpretation is specific to the stream end. The \fBlen\fR member in the \fBdatabuf strbuf\fR structure must be set to the number of bytes of data information to be sent with the message, or to 0 if no data part is to be sent.
.sp
The \fBflags\fR member specifies the type of message to be created. A normal message is created if \fBflags\fR is set to 0, and a high-priority message is created if \fBflags\fR is set to \fBRS_HIPRI\fR. For non-priority messages,  \fBI_FDINSERT\fR will block if the stream write queue is full due to internal flow control conditions. For priority messages,  \fBI_FDINSERT\fR does not block on this condition. For non-priority messages,  \fBI_FDINSERT\fR does not block when the write queue is full and  \fBO_NDELAY\fR or  \fBO_NONBLOCK\fR is set. Instead, it fails and sets \fBerrno\fR to \fBEAGAIN\fR.
.sp
\fBI_FDINSERT\fR also blocks, unless prevented by lack of internal resources, waiting for the availability of message blocks in the stream, regardless of priority or whether \fBO_NDELAY\fR or \fBO_NONBLOCK\fR has been specified. No partial message is sent.
.sp
The \fBioctl()\fR function with the \fBI_FDINSERT\fR command will fail if:
.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
A non-priority message is specified, the \fBO_NDELAY\fR or \fBO_NONBLOCK\fR flag is set, and the stream write queue is full due to internal flow control conditions.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOSR\fR\fR
.ad
.RS 10n
.rt  
Buffers can not be allocated for the message that is to be created.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
The \fIarg\fR argument points, or the buffer area specified in \fBctlbuf\fR or \fBdatabuf\fR is, outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
One of the following: The \fBfildes\fR member of the \fBstrfdinsert\fR structure is not a valid, open stream file descriptor; the size of a  \fBt_uscalar_t\fR plus \fBoffset\fR is greater than the \fBlen\fR member for the buffer specified through \fBctlptr\fR; the \fBoffset\fR member does not specify a properly-aligned location in the data buffer; or an undefined value is stored in \fBflags\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on the \fBfildes\fR argument of the \fBioctl\fR call or the \fBfildes\fR member of the \fBstrfdinsert\fR structure.
.RE

.sp
.ne 2
.mk
.na
\fB\fBERANGE\fR\fR
.ad
.RS 10n
.rt  
The \fBlen\fR field for the buffer specified through \fBdatabuf\fR does not fall within the range specified by the maximum and minimum packet sizes of the topmost stream module; or the \fBlen\fR member for the buffer specified through \fBdatabuf\fR is larger than the maximum configured size of the data part of a message; or the \fBlen\fR member for the buffer specified through \fBctlbuf\fR is larger than the maximum configured size of the control part of a message.
.RE

\fBI_FDINSERT\fR can also fail if an error message was received by the stream head of the stream corresponding to the \fBfildes\fR member of the \fBstrfdinsert\fR structure. In this case, \fBerrno\fR will be set to the value in the message.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_STR\fR\fR
.ad
.RS 15n
.rt  
Constructs an internal \fBSTREAMS\fR ioctl message from the data pointed to by \fIarg\fR, and sends that message downstream.
.sp
This mechanism is provided to send user \fBioctl\fR requests to downstream modules and drivers. It allows information to be sent with the \fBioctl\fR, and will return to the user any information sent upstream by the downstream recipient. \fBI_STR\fR blocks until the system responds with either a positive or negative acknowledgement message, or until the request times out after some period of time. If the request times out, it fails with \fBerrno\fR set to \fBETIME\fR.
.sp
To send requests downstream, \fIarg\fR must point to a \fBstrioctl\fR structure which contains the following members:
.sp
.in +2
.nf
int  ic_cmd;
int  ic_timout;
int  ic_len;
char  *ic_dp;
.fi
.in -2

\fBic_cmd\fR is the internal \fBioctl\fR command intended for a downstream module or driver and \fBic_timout\fR is the number of seconds (-1 = infinite, 0 = use default, >0 = as specified) an \fBI_STR\fR request will wait for acknowledgement before timing out. \fBic_len\fR is the number of bytes in the data argument and \fBic_dp\fR is a pointer to the data argument. The \fBic_len\fR field has two uses: on input, it contains the length of the data argument passed in, and on return from the command, it contains the number of bytes being returned to the user (the buffer pointed to by \fBic_dp\fR should be large enough to contain the maximum amount of data that any module or the driver in the stream can return).
.sp
At most one \fBI_STR\fR can be active on a stream.  Further \fBI_STR\fR calls will block until the active \fBI_STR\fR completes via  a  positive  or negative acknowlegment, a timeout, or an error condition at the stream head.  By setting  the \fBic_timout\fR  field  to  0, the  user is requesting STREAMS to provide  the  \fBDEFAULT\fR timeout. The default timeout is specific to the STREAMS implementation and may vary depending on which release of Solaris you are using. For Solaris 8 (and earlier versions), the default timeout is fifteen seconds. The \fBO_NDELAY\fR and \fBO_NONBLOCK\fR (see \fBopen\fR(2)) flags have no effect on this call.
.sp
The stream head will convert the information pointed to by the \fBstrioctl\fR structure to an internal \fBioctl\fR command message and send it downstream. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBENOSR\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate buffers for the \fBioctl\fR message due to insufficient STREAMS memory resources.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
Either \fIarg\fR points outside the allocated address space, or the buffer area specified by \fBic_dp\fR and \fBic_len\fR (separately for data sent and data returned) is outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fBic_len\fR is less than 0 or \fBic_len\fR is larger than the maximum configured size of the data part of a message or \fBic_timout\fR is less than -1.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBETIME\fR\fR
.ad
.RS 10n
.rt  
A downstream \fBioctl\fR timed out before acknowledgement was received.
.RE

An \fBI_STR\fR can also fail while waiting for an acknowledgement if a message indicating an error or a hangup is received at the stream head. In addition, an error code can be returned in the positive or negative acknowledgement message, in the event the ioctl command sent downstream fails. For these cases, \fBI_STR\fR will fail with \fBerrno\fR set to the value in the message.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_SWROPT\fR\fR
.ad
.RS 15n
.rt  
Sets the write mode using the value of the argument \fIarg\fR. Legal bit settings for \fIarg\fR are:
.sp
.ne 2
.mk
.na
\fB\fBSNDZERO\fR\fR
.ad
.RS 11n
.rt  
Send a zero-length message downstream when a write of 0 bytes occurs.
.RE

To not send a zero-length message when a write of 0 bytes occurs, this bit must not be set in \fIarg\fR.
.sp
On failure, \fBerrno\fR may be set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not the above legal value.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_GWROPT\fR\fR
.ad
.RS 15n
.rt  
Returns the current write mode setting, as described above, in the \fBint\fR that is pointed to by the argument \fIarg\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_SENDFD\fR\fR
.ad
.RS 15n
.rt  
Requests the stream associated with \fIfildes\fR to send a message, containing a file pointer, to the stream head at the other end of a stream pipe. The file pointer corresponds to \fIarg\fR, which must be an open file descriptor.
.sp
\fBI_SENDFD\fR converts \fIarg\fR into the corresponding system file pointer. It allocates a message block and inserts the file pointer in the block.  The user id and group id associated with the sending process are also inserted. This message is placed directly on the read queue (see \fBIntro\fR(3)) of the stream head at the other end of the stream pipe to which it is connected.  On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
The sending stream is unable to allocate a message block to contain the file pointer.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
The read queue of the receiving stream head is full and cannot accept the message sent by \fBI_SENDFD.\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBEBADF\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not a valid, open file descriptor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR is not connected to a stream pipe.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_RECVFD\fR\fR
.ad
.RS 15n
.rt  
Retrieves the file descriptor associated with the message sent by an \fBI_SENDFD\fR \fBioctl\fR over a stream pipe. \fIarg\fR is a pointer to a data buffer large enough to hold an \fBstrrecvfd\fR data structure containing the following members: 
.sp
.in +2
.nf
int  fd;
uid_t  uid;
gid_t  gid;
.fi
.in -2

\fBfd\fR is an integer file descriptor. \fBuid\fR and \fBgid\fR are the user id and group id, respectively, of the sending stream.
.sp
If \fBO_NDELAY\fR and \fBO_NONBLOCK\fR are clear (see \fBopen\fR(2)), \fBI_RECVFD\fR will block until a message is present at the stream head. If \fBO_NDELAY\fR or \fBO_NONBLOCK\fR is set, \fBI_RECVFD\fR will fail with \fBerrno\fR set to \fBEAGAIN\fR if no message is present at the stream head.
.sp
If the message at the stream head is a message sent by an \fBI_SENDFD\fR, a new user file descriptor is allocated for the file pointer contained in the message. The new file descriptor is placed in the \fBfd\fR field of the \fBstrrecvfd\fR structure. The structure is copied into the user data buffer pointed to by \fIarg\fR. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 13n
.rt  
A message is not present at the stream head read queue, and the \fBO_NDELAY\fR or \fBO_NONBLOCK\fR flag is set.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEBADMSG\fR\fR
.ad
.RS 13n
.rt  
The message at the stream head read queue is not a message containing a passed file descriptor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 13n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEMFILE\fR\fR
.ad
.RS 13n
.rt  
\fBNOFILES\fR file descriptors are currently open.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 13n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEOVERFLOW\fR\fR
.ad
.RS 13n
.rt  
\fIuid\fR or \fIgid\fR is too large to be stored in the structure pointed to by \fIarg\fR.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_LIST\fR\fR
.ad
.RS 15n
.rt  
Allows the user to list all the module names on the stream, up to and including the topmost driver name. If \fIarg\fR is \fINULL\fR, the return value is the number of modules, including the driver, that are on the stream pointed to by \fIfildes\fR. This allows the user to allocate enough space for the module names. If \fIarg\fR is non-null, it should point to an \fBstr_list\fR structure that has the following members:
.sp
.in +2
.nf
int sl_nmods;
struct  str_mlist  *sl_modlist;
.fi
.in -2

The \fBstr_mlist\fR structure has the following member:
.sp
.in +2
.nf
char l_name[FMNAMESZ+1];
.fi
.in -2

The \fBsl_nmods\fR member indicates the number of entries the process has allocated in the array.  Upon return, the \fBsl_modlist\fR member of the \fBstr_list\fR structure contains the list of module names, and the number of entries that have been filled into the \fBsl_modlist\fR array is found in the \fBsl_nmods\fR member (the number includes the number of modules including the driver).  The return value from \fBioctl()\fR is 0.  The entries are filled in starting at the top of the stream and continuing downstream until either the end of the stream is reached, or the number of requested modules (\fBsl_nmods\fR) is satisfied. On failure, \fBerrno\fR may be set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
The \fBsl_nmods\fR member is less than 1.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate buffers
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_ATMARK\fR\fR
.ad
.RS 15n
.rt  
Allows the user to see if the current message on the stream head read queue is ``marked'' by some module downstream. \fIarg\fR determines how the checking is done when there may be multiple marked messages on the stream head read queue. It may take the following values:
.sp
.ne 2
.mk
.na
\fB\fBANYMARK\fR\fR
.ad
.RS 12n
.rt  
Check if the message is marked.
.RE

.sp
.ne 2
.mk
.na
\fB\fBLASTMARK\fR\fR
.ad
.RS 12n
.rt  
Check if the message is the last one marked on the queue.
.RE

The return value is \fB1\fR if the mark condition is satisfied and \fB0\fR otherwise. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Invalid \fIarg\fR value.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_CKBAND\fR\fR
.ad
.RS 15n
.rt  
Check if the message of a given priority band exists on the stream head read queue. This returns \fB1\fR if a message of a given priority exists, \fB0\fR if not, or \fB\(mi1\fR on error. \fIarg\fR should be an integer containing the value of the priority band in question. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Invalid \fIarg\fR value.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_GETBAND\fR\fR
.ad
.RS 15n
.rt  
Returns the priority band of the first message on the stream head read queue in the integer referenced by \fIarg\fR. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBENODATA\fR\fR
.ad
.RS 11n
.rt  
No message on the stream head read queue.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_CANPUT\fR\fR
.ad
.RS 15n
.rt  
Check if a certain band is writable. \fIarg\fR is set to the priority band in question. The return value is \fB0\fR if the priority band \fIarg\fR is flow controlled, \fB1\fR if the band is writable, or \fB\(mi1\fR on error. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Invalid \fIarg\fR value.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_SETCLTIME\fR\fR
.ad
.RS 15n
.rt  
Allows the user to set the time the stream head will delay when a stream is closing and there are data on the write queues.  Before closing each module and driver, the stream head will delay for the specified amount of time to allow the data to drain. Note, however, that the module or driver may itself delay in its close routine; this delay is independent of the stream head's delay and is not settable. If, after the delay, data are still present, data will be flushed. \fIarg\fR is a pointer to an integer containing the number of milliseconds to delay, rounded up to the nearest legal value on the system.  The default is fifteen seconds. On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Invalid \fIarg\fR value.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_GETCLTIME\fR\fR
.ad
.RS 15n
.rt  
Returns the close time delay in the integer pointed by \fIarg\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_SERROPT\fR\fR
.ad
.RS 15n
.rt  
Sets the error mode using the value of the argument \fIarg\fR.
.sp
Normally stream head errors are persistent; once they are set due to an \fBM_ERROR\fR or \fBM_HANGUP\fR, the error condition will remain until the stream is closed. This option can be used to set the stream head into non-persistent error mode i.e. once the error has been returned in response to a \fBread\fR(2), \fBgetmsg\fR(2), \fBioctl\fR(2), \fBwrite\fR(2), or  \fBputmsg\fR(2) call the error condition will be cleared. The error mode can be controlled independently for read and write side errors. Legal \fIarg\fR values are either none or one of:
.sp
.ne 2
.mk
.na
\fB\fBRERRNORM\fR\fR
.ad
.RS 18n
.rt  
Persistent read errors, the default.
.RE

.sp
.ne 2
.mk
.na
\fB\fBRERRNONPERSIST\fR\fR
.ad
.RS 18n
.rt  
Non-persistent read errors.
.RE

\fBOR'ed\fR with either none or one of:
.sp
.ne 2
.mk
.na
\fB\fBWERRNORM\fR\fR
.ad
.RS 18n
.rt  
Persistent write errors, the default.
.RE

.sp
.ne 2
.mk
.na
\fB\fBWERRNONPERSIST\fR\fR
.ad
.RS 18n
.rt  
Non-persistent write errors.
.sp
When no value is specified e.g. for the read side error behavior then the behavior for that side will be left unchanged.
.RE

On failure, \fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not one of the above legal values.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB\fBI_GERROPT\fR\fR
.ad
.RS 15n
.rt  
Returns the current error mode setting in an \fBint\fR pointed to by the argument \fIarg\fR. Error modes are described above for \fBI_SERROPT\fR. On failure,\fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
\fB\fBEFAULT\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.LP
The following four commands are used for connecting and disconnecting multiplexed STREAMS configurations.
.sp
.ne 2
.mk
.na
\fB\fBI_LINK\fR\fR
.ad
.RS 13n
.rt  
Connects two streams, where \fIfildes\fR is the file descriptor of the stream connected to the multiplexing driver, and \fIarg\fR is the file descriptor of the stream connected to another driver. The stream designated by \fIarg\fR gets connected below the multiplexing driver. \fBI_LINK\fR requires the multiplexing driver to send an acknowledgement message to the stream head regarding the linking operation. This call returns a multiplexor ID number (an identifier used to disconnect the multiplexor, see \fBI_UNLINK\fR) on success, and -1 on failure. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBETIME\fR\fR
.ad
.RS 10n
.rt  
Time out before acknowledgement message was received at stream head.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
Temporarily unable to allocate storage to perform the \fBI_LINK.\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOSR\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate storage to perform the \fBI_LINK\fR due to insufficient \fBSTREAMS\fR memory resources.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEBADF\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not a valid, open file descriptor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR stream does not support multiplexing.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not a stream, or is already linked under a multiplexor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
The specified link operation would cause a ``cycle'' in the resulting configuration; that is, a driver would be linked into the multiplexing configuration in more than one place.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Either the upper or lower stream has a major number >= the maximum major number on the system.
.RE

An \fBI_LINK\fR can also fail while waiting for the multiplexing driver to acknowledge the link request, if a message indicating an error or a hangup is received at the stream head of \fIfildes\fR. In addition, an error code can be returned in the positive or negative acknowledgement message.  For these cases, \fBI_LINK\fR will fail with \fBerrno\fR set to the value in the message.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_UNLINK\fR\fR
.ad
.RS 13n
.rt  
Disconnects the two streams specified by \fIfildes\fR and \fIarg\fR. \fIfildes\fR is the file descriptor of the stream connected to the multiplexing driver. \fIarg\fR is the multiplexor ID number that was returned by the \fBI_LINK\fR. If \fIarg\fR is -1, then all streams that were linked to \fIfildes\fR are disconnected.  As in \fBI_LINK\fR, this command requires the multiplexing driver to acknowledge the unlink. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBETIME\fR\fR
.ad
.RS 10n
.rt  
Time out before acknowledgement message was received at stream head.
.RE

.sp
.ne 2
.mk
.na
\fB\fBENOSR\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate storage to perform the \fBI_UNLINK\fR due to insufficient STREAMS memory resources.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is an invalid multiplexor ID number or \fIfildes\fR is not the stream on which the \fBI_LINK\fR that returned \fIarg\fR was performed.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

An  \fBI_UNLINK\fR can also fail while waiting for the multiplexing driver to acknowledge the link request, if a message indicating an error or a hangup is received at the stream head of \fIfildes\fR. In addition, an error code can be returned in the positive or negative acknowledgement message. For these cases,  \fBI_UNLINK\fR will fail with \fBerrno\fR set to the value in the message.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_PLINK\fR\fR
.ad
.RS 13n
.rt  
Connects two streams, where \fIfildes\fR is the file descriptor of the stream connected to the multiplexing driver, and \fIarg\fR is the file descriptor of the stream connected to another driver. The stream designated by \fIarg\fR gets connected via a persistent link below the multiplexing driver. \fBI_PLINK\fR requires the multiplexing driver to send an acknowledgement message to the stream head regarding the linking operation. This call creates a persistent link that continues to exist even if the file descriptor \fIfildes\fR associated with the upper stream to the multiplexing driver is closed. This call returns a multiplexor ID number (an identifier that may be used to disconnect the multiplexor, see \fBI_PUNLINK\fR) on success, and -1 on failure. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBETIME\fR\fR
.ad
.RS 10n
.rt  
Time out before acknowledgement message was received at the stream head.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate STREAMS storage to perform the  \fBI_PLINK.\fR
.RE

.sp
.ne 2
.mk
.na
\fB\fBEBADF\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not a valid, open file descriptor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR does not support multiplexing.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIarg\fR is not a stream or is already linked under a multiplexor.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
The specified link operation would cause a ``cycle'' in the resulting configuration; that is, if a driver would be linked into the multiplexing configuration in more than one place.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

An \fBI_PLINK\fR can also fail while waiting for the multiplexing driver to acknowledge the link request, if a message indicating an error on a hangup is received at the stream head of \fIfildes\fR. In addition, an error code can be returned in the positive or negative acknowledgement message.  For these cases, \fBI_PLINK\fR will fail with \fBerrno\fR set to the value in the message.
.RE

.sp
.ne 2
.mk
.na
\fB\fBI_PUNLINK\fR\fR
.ad
.RS 13n
.rt  
Disconnects the two streams specified by \fIfildes\fR and \fIarg\fR that are connected with a persistent link. \fIfildes\fR is the file descriptor of the stream connected to the multiplexing driver. \fIarg\fR is the multiplexor ID number that was returned by \fBI_PLINK\fR when a stream was linked below the multiplexing driver. If \fIarg\fR is  \fBMUXID_ALL\fR then all streams that are persistent links to \fIfildes\fR are disconnected. As in  \fBI_PLINK,\fR this command requires the multiplexing driver to acknowledge the unlink. On failure, \fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
\fB\fBENXIO\fR\fR
.ad
.RS 10n
.rt  
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
\fB\fBETIME\fR\fR
.ad
.RS 10n
.rt  
Time out before acknowledgement message was received at the stream head.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEAGAIN\fR\fR
.ad
.RS 10n
.rt  
Unable to allocate buffers for the acknowledgement message.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
Invalid multiplexor ID number.
.RE

.sp
.ne 2
.mk
.na
\fB\fBEINVAL\fR\fR
.ad
.RS 10n
.rt  
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

An \fBI_PUNLINK\fR can also fail while waiting for the multiplexing driver to acknowledge the link request if a message indicating an error or a hangup is received at the stream head of \fIfildes\fR. In addition, an error code can be returned in the positive or negative acknowledgement message.  For these cases, \fBI_PUNLINK\fR will fail with \fBerrno\fR set to the value in the message.
.RE

.SH RETURN VALUES
.sp
.LP
Unless specified otherwise above, the return value from \fBioctl()\fR is \fB0\fR upon success and  \fB\(mi1\fR upon failure, with \fIerrno\fR set as indicated.
.SH SEE ALSO
.sp
.LP
\fBstrconf\fR(1), \fBIntro\fR(3), \fBclose\fR(2), \fBfcntl\fR(2), \fBgetmsg\fR(2), \fBioctl\fR(2), \fBopen\fR(2), \fBpoll\fR(2), \fBputmsg\fR(2), \fBread\fR(2), \fBwrite\fR(2), \fBsignal\fR(3C), \fBsignal.h\fR(3HEAD)
.sp
.LP
\fISTREAMS Programming Guide\fR
