'\" te
.\"  Copyright (c) 1999, Sun Microsystems, Inc.  All Rights Reserved
.TH econvert 3C "3 May 1999" "SunOS 5.11" "Standard C Library Functions"
.SH NAME
econvert, fconvert, gconvert, seconvert, sfconvert, sgconvert, qeconvert, qfconvert, qgconvert \- output conversion
.SH SYNOPSIS
.LP
.nf
#include <floatingpoint.h>

\fBchar *\fR\fBeconvert\fR(\fBdouble\fR \fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint *\fR\fIdecpt\fR, \fBint *\fR\fIsign\fR,
     \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBfconvert\fR(\fBdouble\fR \fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint *\fR\fIdecpt\fR, \fBint *\fR\fIsign\fR,
     \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBgconvert\fR(\fBdouble\fR \fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint\fR \fItrailing\fR, \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBseconvert\fR(\fBsingle *\fR\fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint *\fR\fIdecpt\fR, \fBint *\fR\fIsign\fR,
     \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBsfconvert\fR(\fBsingle *\fR\fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint *\fR\fIdecpt\fR, \fBint *\fR\fIsign\fR,
     \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBsgconvert\fR(\fBsingle *\fR\fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint\fR \fItrailing\fR, \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBqeconvert\fR(\fBquadruple *\fR\fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint *\fR\fIdecpt\fR, \fBint *\fR\fIsign\fR,
     \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBqfconvert\fR(\fBquadruple *\fR\fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint *\fR\fIdecpt\fR, \fBint *\fR\fIsign\fR
     \fBchar *\fR\fIbuf\fR);
.fi

.LP
.nf
\fBchar *\fR\fBqgconvert\fR(\fBquadruple *\fR\fIvalue\fR, \fBint\fR \fIndigit\fR, \fBint\fR \fItrailing\fR, \fBchar *\fR\fIbuf\fR);
.fi

.SH DESCRIPTION
.sp
.LP
The \fBeconvert()\fR function converts the \fIvalue\fR to a null-terminated string of \fIndigit\fR \fBASCII\fR digits in \fIbuf\fR and returns a pointer to \fIbuf\fR. \fIbuf\fR should contain at least \fIndigit+1\fR characters. The position of the decimal point relative to the beginning of the string is stored indirectly through \fIdecpt\fR. Thus \fIbuf\fR == "314" and \fI*decpt\fR == 1 corresponds to the numerical value 3.14, while \fIbuf\fR == "314" and \fI*decpt\fR == \(mi1 corresponds to the numerical value .0314. If the sign of the result is negative, the word pointed to by \fIsign\fR is nonzero; otherwise it is zero. The least significant digit is rounded.
.sp
.LP
The \fBfconvert()\fR function works much like \fBeconvert()\fR, except that the correct digit has been rounded as if for  \fBsprintf(%w.nf)\fR output with \fIn\fR=\fIndigit\fR digits to the right of the decimal point. \fIndigit\fR can be negative to indicate rounding to the left of the decimal point. The return value is a pointer to \fIbuf\fR. \fIbuf\fR should contain at least \fI310+max(0,ndigit)\fR characters to accomodate any double-precision \fIvalue\fR.
.sp
.LP
The \fBgconvert()\fR function converts the \fIvalue\fR to a null-terminated \fBASCII\fR string in \fIbuf\fR and returns a pointer to \fIbuf\fR. It produces \fIndigit\fR significant digits in fixed-decimal format, like  \fBsprintf(%w.nf)\fR, if possible, and otherwise in floating-decimal format, like  \fBsprintf(%w.ne)\fR; in either case \fIbuf\fR is ready for printing, with sign and exponent. The result corresponds to that obtained by 
.sp
.in +2
.nf
(void) sprintf(buf,``%w.ng'',value) ;
.fi
.in -2

.sp
.LP
If \fItrailing\fR = 0, trailing zeros and a trailing point are suppressed, as in  \fBsprintf(%g)\fR. If \fItrailing\fR != 0, trailing zeros and a trailing point are retained, as in  \fBsprintf(%#g)\fR.
.sp
.LP
The \fBseconvert()\fR, \fBsfconvert()\fR, and \fBsgconvert()\fR functions are single-precision versions of these functions, and are more efficient than the corresponding double-precision versions. A pointer rather than the value itself is passed to avoid C's usual conversion of single-precision arguments to double.
.sp
.LP
The \fBqeconvert()\fR, \fBqfconvert()\fR, and \fBqgconvert()\fR functions are quadruple-precision versions of these functions. The \fBqfconvert()\fR function can overflow the  \fIdecimal_record\fR field  \fIds\fR if \fIvalue\fR is too large. In that case, \fIbuf\fR[0] is set to zero.
.sp
.LP
The \fBecvt()\fR, \fBfcvt()\fR and \fBgcvt()\fR functions are versions of \fBeconvert()\fR, \fBfconvert()\fR, and \fBgconvert()\fR, respectively, that are documented on the \fBecvt\fR(3C) manual page.  They constitute the default implementation of these functions and conform to the X/Open CAE Specification, System Interfaces and Headers, Issue 4, Version 2. 
.SH USAGE
.sp
.LP
\fBIEEE\fR Infinities and NaNs are treated similarly by these functions. ``NaN'' is returned for NaN, and ``Inf'' or ``Infinity'' for Infinity.  The longer form is produced when \fIndigit\fR >= 8.
.SH ATTRIBUTES
.sp
.LP
See \fBattributes\fR(5) for descriptions of the following attributes: 
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
MT-LevelMT-Safe
.TE

.SH SEE ALSO
.sp
.LP
\fBecvt\fR(3C),\fBsprintf\fR(3C), \fBattributes\fR(5)
