'\" te
.\" Copyright (c) 2000, 2001, 2002, 2003, 2004 by Martin C. Shepherd. All Rights Reserved.
.\" Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, provided that the above copyright notice(s) and this permission notice appear in all copies of the Software and that both the above copyright notice(s) and this permission notice appear in supporting documentation.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder.
.\" Portions Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
.TH tecla 5 "20 May 2004" "SunOS 5.11" "Standards, Environments, and Macros"
.SH NAME
tecla, teclarc \- User interface provided by the tecla library.
.SH DESCRIPTION
.sp
.LP
This man page describes the command-line editing features that are available to users of programs that read keyboard input via the tecla library. Users of the \fBtcsh shell\fR will find the default key bindings very familiar. Users of the \fBbash\fR shell will also find it quite familiar, but with a few minor differences, most notably in how forward and backward searches through the list of historical commands are performed. There are two major editing modes, one with \fBemacs\fR-like key bindings and another with \fBvi\fR-like key bindings. By default \fBemacs\fR mode is enabled, but \fBvi\fR(1) mode can alternatively be selected via the user's configuration file. This file can also be used to change the bindings of individual keys to suit the user's preferences. By default, tab completion is provided. If the application hasn't reconfigured this to complete other types of symbols, then tab completion completes file names.
.SS "Key Sequence Notation"
.sp
.LP
In the rest of this man page, and also in all tecla configuration files, key sequences are expressed as follows.
.sp
.ne 2
.mk
.na
\fB\fB^A\fR or \fBC-a\fR\fR
.ad
.RS 13n
.rt  
This is a 'CONTROL-A', entered by pressing the CONTROL key at the same time as the 'A' key.
.RE

.sp
.ne 2
.mk
.na
\fB\fB\E\fR or \fBM-\fR\fR
.ad
.RS 13n
.rt  
In key sequences, both of these notations can be entered either by pressing the ESCAPE key, then the following key, or by pressing the META key at the same time as the following key. Thus the key sequence \fBM-p\fR can be typed in two ways, by pressing the ESCAPE key, followed by pressing 'P', or by pressing the META key at the same time as 'P'.
.RE

.sp
.ne 2
.mk
.na
\fBup\fR
.ad
.RS 13n
.rt  
This refers to the up-arrow key.
.RE

.sp
.ne 2
.mk
.na
\fBdown\fR
.ad
.RS 13n
.rt  
This refers to the down-arrow key.
.RE

.sp
.ne 2
.mk
.na
\fBleft\fR
.ad
.RS 13n
.rt  
This refers to the left-arrow key.
.RE

.sp
.ne 2
.mk
.na
\fBright\fR
.ad
.RS 13n
.rt  
This refers to the right-arrow key.
.RE

.sp
.ne 2
.mk
.na
\fBa\fR
.ad
.RS 13n
.rt  
This is just a normal 'A' key.
.RE

.SS "The Tecla Configuration File"
.sp
.LP
By default, tecla looks for a file called \fB\&.teclarc\fR in your home directory (ie. \fB~/.teclarc\fR). If it finds this file, it reads it, interpreting each line as defining a new key binding or an editing configuration option. Since the \fBemacs\fR key-bindings are installed by default, if you want to use the non-default \fBvi\fR editing mode, the most important item to go in this file is the following line:
.sp
.in +2
.nf
edit-mode vi
.fi
.in -2

.sp
.LP
This will re-configure the default bindings for \fBvi\fR-mode. The complete set of arguments that this command accepts are:
.sp
.ne 2
.mk
.na
\fBvi\fR
.ad
.RS 9n
.rt  
Install key bindings like those of the \fBvi\fR editor.
.RE

.sp
.ne 2
.mk
.na
\fBemacs\fR
.ad
.RS 9n
.rt  
Install key bindings like those of the \fBemacs\fR editor. This is the default.
.RE

.sp
.ne 2
.mk
.na
\fBnone\fR
.ad
.RS 9n
.rt  
Use just the native line editing facilities provided by the terminal driver.
.RE

.sp
.LP
To prevent the terminal bell from being rung, such as when an unrecognized control-sequence is typed, place the following line in the configuration file:
.sp
.in +2
.nf
nobeep
.fi
.in -2

.sp
.LP
An example of a key binding line in the configuration file is the following.
.sp
.in +2
.nf
bind M-[2~ insert-mode
.fi
.in -2

.sp
.LP
On many keyboards, the above key sequence is generated when one presses the insert key, so with this key binding, one can toggle between the \fBemacs\fR-mode insert and overwrite modes by hitting one key. One could also do it by typing out the above sequence of characters one by one. As explained above, the \fBM-\fR part of this sequence can be typed either by pressing the ESCAPE key before the following key, or by pressing the META key at the same time as the following key. Thus if you had set the above key binding, and the insert key on your keyboard didn't generate the above key sequence, you could still type it in either of the following 2 ways.
.RS +4
.TP
1.
Hit the ESCAPE key momentarily, then press '[', then '2', then finally '~'.
.RE
.RS +4
.TP
2.
Press the META key at the same time as pressing the '[' key, then press '2', then '~'.
.RE
.sp
.LP
If you set a key binding for a key sequence that is already bound to a function, the new binding overrides the old one. If in the new binding you omit the name of the new function to bind to the key sequence, the original binding becomes undefined.
.sp
.LP
Starting with versions of \fBlibtecla\fR later than 1.3.3 it is now possible to bind key sequences that begin with a printable character. Previously key sequences were required to start with a CONTROL or META character.
.sp
.LP
Note that the special keywords "up", "down", "left", and "right" refer to the arrow keys, and are thus not treated as key sequences. So, for example, to rebind the up and down arrow keys to use the history search mechanism instead of the simple history recall method, you could place the following in your configuration file:
.sp
.in +2
.nf
bind up history-search-backwards
bind down history-search-backwards
.fi
.in -2

.sp
.LP
To unbind an existing binding, you can do this with the bind command by omitting to name any action to rebind the key sequence to. For example, by not specifying an action function, the following command unbinds the default beginning-of-line action from the \fB^A\fR key sequence:
.sp
.in +2
.nf
bind ^A
.fi
.in -2

.sp
.LP
If you create a \fB~/.teclarc\fR configuration file, but it appears to have no effect on the program, check the documentation of the program to see if the author chose a different name for this file.
.SS "Filename and Tilde Completion"
.sp
.LP
With the default key bindings, pressing the TAB key (aka. \fB^I\fR) results in tecla attempting to complete the incomplete file name that precedes the cursor. Tecla searches backwards from the cursor, looking for the start of the file name, stopping when it hits either a space or the start of the line. If more than one file has the specified prefix, then tecla completes the file name up to the point at which the ambiguous matches start to differ, then lists the possible matches.
.sp
.LP
In addition to literally written file names, tecla can complete files that start with \fB~/\fR and \fB~user/\fR expressions and that contain \fB$envvar\fR expressions. In particular, if you hit TAB within an incomplete \fB~user\fR, expression, tecla will attempt to complete the username, listing any ambiguous matches.
.sp
.LP
The completion binding is implemented using the \fBcpl_complete_word()\fR function, which is also available separately to users of this library. See the \fBcpl_complete_word\fR(3TECLA) man page for more details.
.SS "Filename Expansion"
.sp
.LP
With the default key bindings, pressing \fB^X*\fR causes tecla to expand the file name that precedes the cursor, replacing \fB~/\fR and \fB~user/\fR expressions with the corresponding home directories, and replacing \fB$envvar\fR expressions with the value of the specified environment variable, then if there are any wildcards, replacing the so far expanded file name with a space-separated list of the files which match the wild cards.
.sp
.LP
The expansion binding is implemented using the \fBef_expand_file()\fR function. See the \fBef_expand_file\fR(3TECLA) man page for more details.
.SS "Recalling Previously Typed Lines"
.sp
.LP
Every time that a new line is entered by the user, it is appended to a list of historical input lines maintained within the \fBGetLine\fR resource object. You can traverse up and down this list using the up and down arrow keys. Alternatively, you can do the same with the \fB^P\fR, and \fB^N\fR keys, and in \fBvi\fR command mode you can alternatively use the k and j characters. Thus pressing up-arrow once, replaces the current input line with the previously entered line. Pressing up-arrow again, replaces this with the line that was entered before it, etc.. Having gone back one or more lines into the history list, one can return to newer lines by pressing down-arrow one or more times. If you do this sufficient times, you will return to the original line that you were entering when you first hit up-arrow.
.sp
.LP
Note that in \fBvi\fR mode, all of the history recall functions switch the library into command mode.
.sp
.LP
In \fBemacs\fR mode the \fBM-p\fR and \fBM-n\fR keys work just like the \fB^P\fR and \fB^N\fR keys, except that they skip all but those historical lines which share the prefix that precedes the cursor. In \fBvi\fR command mode the upper case 'K' and 'J' characters do the same thing, except that the string that they search for includes the character under the cursor as well as what precedes it.
.sp
.LP
Thus for example, suppose that you were in \fBemacs\fR mode, and you had just entered the following list of commands in the order shown:
.sp
.in +2
.nf
ls ~/tecla/
cd ~/tecla
ls -l getline.c
\fBemacs\fR ~/tecla/getline.c
.fi
.in -2

.sp
.LP
If you next typed:
.sp
.in +2
.nf
ls
.fi
.in -2

.sp
.LP
and then hit \fBM-p\fR, then rather than returning the previously typed \fBemacs\fR line, which doesn't start with "ls", tecla would recall the "ls -l getline.c" line. Pressing \fBM-p\fR again would recall the "ls ~/tecla/" line.
.sp
.LP
Note that if the string that you are searching for, contains any of the special characters, *, ?, or '[', then it is interpretted as a pattern to be matched. Thus, cotinuing with the above example, after typing in the list of commands shown, if you then typed:
.sp
.in +2
.nf
*tecla*
.fi
.in -2

.sp
.LP
and hit \fBM-p\fR, then the "\fBemacs\fR ~/tecla/getline.c" line would be recalled first, since it contains the word tecla somewhere in the line, Similarly, hitting \fBM-p\fR again, would recall the "ls ~/tecla/" line, and hitting it once more would recall the "ls ~/tecla/" line. The pattern syntax is the same as that described for file name expansion, in the \fBef_expand_file\fR(3TECLA).
.SS "History Files"
.sp
.LP
Authors of programs that use the tecla library have the option of saving historical command-lines in a file before exiting, and subsequently reading them back in from this file when the program is next started. There is no standard name for this file, since it makes sense for each application to use its own history file, so that commands from different applications don't get mixed up.
.SS "International Character Sets"
.sp
.LP
Since \fBlibtecla\fR version 1.4.0, tecla has been 8-bit clean. This means that all 8-bit characters that are printable in the user's current locale are now displayed verbatim and included in the returned input line. Assuming that the calling program correctly contains a call like the following,
.sp
.in +2
.nf
setlocale(LC_CTYPE, "");
.fi
.in -2

.sp
.LP
then the current locale is determined by the first of the environment variables \fBLC_CTYPE\fR, \fBLC_ALL\fR, and \fBLANG\fR, that is found to contain a valid locale name. If none of these variables are defined, or the program neglects to call \fBsetlocale\fR, then the default C locale is used, which is US 7-bit ASCII. On most unix-like platforms, you can get a list of valid locales by typing the command:
.sp
.in +2
.nf
locale -a
.fi
.in -2

.sp
.LP
at the shell prompt.
.SS "Meta Keys and Locales"
.sp
.LP
Beware that in most locales other than the default C locale, META characters become printable, and they are then no longer considered to match \fBM-c\fR style key bindings. This allows international characters to be entered with the compose key without unexpectedly triggering META key bindings. You can still invoke META bindings, since there are actually two ways to do this. For example the binding \fBM-c\fR can also be invoked by pressing the ESCAPE key momentarily, then pressing the c key, and this will work regardless of locale. Moreover, many modern terminal emulators, such as gnome's gnome-terminal's and KDE's konsole terminals, already generate escape pairs like this when you use the META key, rather than a real meta character, and other emulators usually have a way to request this behavior, so you can continue to use the META key on most systems.
.sp
.LP
For example, although xterm terminal emulators generate real 8-bit meta characters by default when you use the META key, they can be configured to output the equivalent escape pair by setting their \fBEightBitInput\fR X resource to False. You can either do this by placing a line like the following in your \fB~/.Xdefaults\fR file,
.sp
.in +2
.nf
XTerm*EightBitInput: False
.fi
.in -2

.sp
.LP
or by starting an \fBxterm\fR with an \fB-xrm\fR '*EightBitInput: False' command-line argument. In recent versions of xterm you can toggle this feature on and off with the 'Meta Sends Escape' option in the menu that is displayed when you press the left mouse button and the CONTROL key within an xterm window. In CDE, dtterms can be similarly coerced to generate escape pairs in place of meta characters, by setting the \fBDtterm*KshMode\fR resource to True.
.SS "Entering International Characters"
.sp
.LP
If you don't have a keyboard that generates all of the international characters that you need, there is usually a compose key that will allow you to enter special characters, or a way to create one. For example, under X windows on unix-like systems, if your keyboard doesn't have a compose key, you can designate a redundant key to serve this purpose with the xmodmap command. For example, on many PC keyboards there is a microsoft-windows key, which is otherwise useless under Linux. On a laptop, for example, the \fBxev\fR program might report that pressing this key generates keycode 115. To turn this key into a COMPOSE  key, do the following:
.sp
.in +2
.nf
xmodmap -e 'keycode 115 = Multi_key'
.fi
.in -2

.sp
.LP
Type this key followed by a " character to enter an 'I' with a umlaut over it.
.SS "The Available Key Binding Functions"
.sp
.LP
The following is a list of the editing functions provided by the tecla library. The names in the leftmost column of the list can be used in configuration files to specify which function a given key or combination of keys should invoke. They are also used in the next two sections to list the default key bindings in \fBemacs\fR and \fBvi\fR modes.
.sp
.ne 2
.mk
.na
\fBuser-interrupt\fR
.ad
.RS 30n
.rt  
Send a SIGINT signal to the parent process.
.RE

.sp
.ne 2
.mk
.na
\fBsuspend\fR
.ad
.RS 30n
.rt  
Suspend the parent process.
.RE

.sp
.ne 2
.mk
.na
\fBstop-output\fR
.ad
.RS 30n
.rt  
Pause terminal output.
.RE

.sp
.ne 2
.mk
.na
\fBstart-output\fR
.ad
.RS 30n
.rt  
Resume paused terminal output.
.RE

.sp
.ne 2
.mk
.na
\fBliteral-next\fR
.ad
.RS 30n
.rt  
Arrange for the next character to be treated as a normal character. This allows control characters to be entered.
.RE

.sp
.ne 2
.mk
.na
\fBcursor-right\fR
.ad
.RS 30n
.rt  
Move the cursor one character right.
.RE

.sp
.ne 2
.mk
.na
\fBcursor-left\fR
.ad
.RS 30n
.rt  
Move the cursor one character left.
.RE

.sp
.ne 2
.mk
.na
\fBinsert-mode\fR
.ad
.RS 30n
.rt  
Toggle between insert mode and overwrite mode.
.RE

.sp
.ne 2
.mk
.na
\fBbeginning-of-line\fR
.ad
.RS 30n
.rt  
Move the cursor to the beginning of the line.
.RE

.sp
.ne 2
.mk
.na
\fBend-of-line\fR
.ad
.RS 30n
.rt  
Move the cursor to the end of the line.
.RE

.sp
.ne 2
.mk
.na
\fBdelete-line\fR
.ad
.RS 30n
.rt  
Delete the contents of the current line.
.RE

.sp
.ne 2
.mk
.na
\fBkill-line\fR
.ad
.RS 30n
.rt  
Delete everything that follows the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-kill-line\fR
.ad
.RS 30n
.rt  
Delete all characters between the cursor and the start of the line.
.RE

.sp
.ne 2
.mk
.na
\fBforward-word\fR
.ad
.RS 30n
.rt  
Move to the end of the word which follows the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBforward-to-word\fR
.ad
.RS 30n
.rt  
Move the cursor to the start of the word that follows the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-word\fR
.ad
.RS 30n
.rt  
Move to the start of the word which precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBgoto-column\fR
.ad
.RS 30n
.rt  
Move the cursor to the 1-relative column in the line specified by any preceding digit-argument sequences (see Entering Repeat Counts below).
.RE

.sp
.ne 2
.mk
.na
\fBfind-parenthesis\fR
.ad
.RS 30n
.rt  
If the cursor is currently over a parenthesis character, move it to the matching parenthesis character. If not over a parenthesis character move right to the next close parenthesis.
.RE

.sp
.ne 2
.mk
.na
\fBforward-delete-char\fR
.ad
.RS 30n
.rt  
Delete the character under the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-delete-char\fR
.ad
.RS 30n
.rt  
Delete the character which precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBlist-or-eof\fR
.ad
.RS 30n
.rt  
This is intended for binding to \fB^D\fR. When invoked when the cursor is within the line it displays all possible completions then redisplays the line unchanged. When invoked on an empty line, it signals end-of-input (EOF) to the caller of \fBgl_get_line()\fR.
.RE

.sp
.ne 2
.mk
.na
\fBdel-char-or-list-or-eof\fR
.ad
.RS 30n
.rt  
This is intended for binding to \fB^D\fR. When invoked when the cursor is within the line it invokes forward-delete-char. When invoked at the end of the line it displays all possible completions then redisplays the line unchanged. When invoked on an empty line, it signals end-of-input (EOF) to the caller of \fBgl_get_line()\fR.
.RE

.sp
.ne 2
.mk
.na
\fBforward-delete-word\fR
.ad
.RS 30n
.rt  
Delete the word which follows the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-delete-word\fR
.ad
.RS 30n
.rt  
Delete the word which precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBupcase-word\fR
.ad
.RS 30n
.rt  
Convert all of the characters of the word which follows the cursor, to upper case.
.RE

.sp
.ne 2
.mk
.na
\fBdowncase-word\fR
.ad
.RS 30n
.rt  
Convert all of the characters of the word which follows the cursor, to lower case.
.RE

.sp
.ne 2
.mk
.na
\fBcapitalize-word\fR
.ad
.RS 30n
.rt  
Capitalize the word which follows the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBchange-case\fR
.ad
.RS 30n
.rt  
If the next character is upper case, toggle it to lower case and vice versa.
.RE

.sp
.ne 2
.mk
.na
\fBredisplay\fR
.ad
.RS 30n
.rt  
Redisplay the line.
.RE

.sp
.ne 2
.mk
.na
\fBclear-screen\fR
.ad
.RS 30n
.rt  
Clear the terminal, then redisplay the current line.
.RE

.sp
.ne 2
.mk
.na
\fBtranspose-chars\fR
.ad
.RS 30n
.rt  
Swap the character under the cursor with the character just before the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBset-mark\fR
.ad
.RS 30n
.rt  
Set a mark at the position of the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBexchange-point-and-mark\fR
.ad
.RS 30n
.rt  
Move the cursor to the last mark that was set, and move the mark to where the cursor used to be.
.RE

.sp
.ne 2
.mk
.na
\fBkill-region\fR
.ad
.RS 30n
.rt  
Delete the characters that lie between the last mark that was set, and the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBcopy-region-as-kill\fR
.ad
.RS 30n
.rt  
Copy the text between the mark and the cursor to the cut buffer, without deleting the original text.
.RE

.sp
.ne 2
.mk
.na
\fByank\fR
.ad
.RS 30n
.rt  
Insert the text that was last deleted, just before the current position of the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBappend-yank\fR
.ad
.RS 30n
.rt  
Paste the current contents of the cut buffer, after the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBup-history\fR
.ad
.RS 30n
.rt  
Recall the next oldest line that was entered. Note that in \fBvi\fR mode you are left in command mode.
.RE

.sp
.ne 2
.mk
.na
\fBdown-history\fR
.ad
.RS 30n
.rt  
Recall the next most recent line that was entered. If no history recall session is currently active, the next line from a previous recall session is recalled. Note that in vi mode you are left in command mode.
.RE

.sp
.ne 2
.mk
.na
\fBhistory-search-backward\fR
.ad
.RS 30n
.rt  
Recall the next oldest line who's prefix matches the string which currently precedes the cursor (in \fBvi\fR command-mode the character under the cursor is also included in the search string). Note that in \fBvi\fR mode you are left in command mode.
.RE

.sp
.ne 2
.mk
.na
\fBhistory-search-forward\fR
.ad
.RS 30n
.rt  
Recall the next newest line who's prefix matches the string which currently precedes the cursor (in \fBvi\fR command-mode the character under the cursor is also included in the search string). Note that in \fBvi\fR mode you are left in command mode.
.RE

.sp
.ne 2
.mk
.na
\fBhistory-re-search-backward\fR
.ad
.RS 30n
.rt  
Recall the next oldest line who's prefix matches that established by the last invocation of either history-search-forward or history-search-backward.
.RE

.sp
.ne 2
.mk
.na
\fBhistory-re-search-forward\fR
.ad
.RS 30n
.rt  
Recall the next newest line who's prefix matches that established by the last invocation of either history-search-forward or history-search-backward.
.RE

.sp
.ne 2
.mk
.na
\fBcomplete-word\fR
.ad
.RS 30n
.rt  
Attempt to complete the incomplete word which precedes the cursor. Unless the host program has customized word completion, file name completion is attempted. In \fBvi\fR commmand mode the character under the cursor is also included in the word being completed, and you are left in \fBvi\fR insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBexpand-filename\fR
.ad
.RS 30n
.rt  
Within the command line, expand wild cards, tilde expressions and dollar expressions in the file name which immediately precedes the cursor. In \fBvi\fR commmand mode the character under the cursor is also included in the file name being expanded, and you are left in \fBvi\fR insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBlist-glob\fR
.ad
.RS 30n
.rt  
List any file names which match the wild-card, tilde and dollar expressions in the file name which immediately precedes the cursor, then redraw the input line unchanged.
.RE

.sp
.ne 2
.mk
.na
\fBlist-history\fR
.ad
.RS 30n
.rt  
Display the contents of the history list for the current history group. If a repeat count of \fB> 1\fR is specified, only that many of the most recent lines are displayed. See the Entering Repeat Counts section.
.RE

.sp
.ne 2
.mk
.na
\fBread-from-file\fR
.ad
.RS 30n
.rt  
Temporarily switch to reading input from the file who's name precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
\fBread-init-files\fR
.ad
.RS 30n
.rt  
Re-read \fBteclarc\fR configuration files.
.RE

.sp
.ne 2
.mk
.na
\fBbeginning-of-history\fR
.ad
.RS 30n
.rt  
Move to the oldest line in the history list. Note that in \fBvi\fR mode you are left in command mode.
.RE

.sp
.ne 2
.mk
.na
\fBend-of-history\fR
.ad
.RS 30n
.rt  
Move to the newest line in the history list (ie. the current line). Note that in \fBvi\fR mode this leaves you in command mode.
.RE

.sp
.ne 2
.mk
.na
\fBdigit-argument\fR
.ad
.RS 30n
.rt  
Enter a repeat count for the next key binding function. For details, see the Entering Repeat Counts section.
.RE

.sp
.ne 2
.mk
.na
\fBnewline\fR
.ad
.RS 30n
.rt  
Terminate and return the current contents of the line, after appending a newline character. The newline character is normally '\n', but will be the first character of the key sequence that invoked the newline action, if this happens to be a printable character. If the action was invoked by the '\n' newline character or the '\r' carriage return character, the line is appended to the history buffer.
.RE

.sp
.ne 2
.mk
.na
\fBrepeat-history\fR
.ad
.RS 30n
.rt  
Return the line that is being edited, then arrange for the next most recent entry in the history buffer to be recalled when tecla is next called. Repeatedly invoking this action causes successive historical input lines to be re-executed. Note that this action is equivalent to the \&'Operate' action in ksh.
.RE

.sp
.ne 2
.mk
.na
\fBring-bell\fR
.ad
.RS 30n
.rt  
Ring the terminal bell, unless the bell has been silenced via the nobeep configuration option (see The Tecla Configuration File section).
.RE

.sp
.ne 2
.mk
.na
\fBforward-copy-char\fR
.ad
.RS 30n
.rt  
Copy the next character into the cut buffer (NB. use repeat counts to copy more than one).
.RE

.sp
.ne 2
.mk
.na
\fBbackward-copy-char\fR
.ad
.RS 30n
.rt  
Copy the previous character into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBforward-copy-word\fR
.ad
.RS 30n
.rt  
Copy the next word into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-copy-word\fR
.ad
.RS 30n
.rt  
Copy the previous word into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBforward-find-char\fR
.ad
.RS 30n
.rt  
Move the cursor to the next occurrence of the next character that you type.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-find-char\fR
.ad
.RS 30n
.rt  
Move the cursor to the last occurrence of the next character that you type.
.RE

.sp
.ne 2
.mk
.na
\fBforward-to-char\fR
.ad
.RS 30n
.rt  
Move the cursor to the character just before the next occurrence of the next character that the user types.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-to-char\fR
.ad
.RS 30n
.rt  
Move the cursor to the character just after the last occurrence before the cursor of the next character that the user types.
.RE

.sp
.ne 2
.mk
.na
\fBrepeat-find-char\fR
.ad
.RS 30n
.rt  
Repeat the last backward-find-char, forward-find-char, backward-to-char or forward-to-char.
.RE

.sp
.ne 2
.mk
.na
\fBinvert-refind-char\fR
.ad
.RS 30n
.rt  
Repeat the last backward-find-char, forward-find-char, backward-to-char, or forward-to-char in the opposite direction.
.RE

.sp
.ne 2
.mk
.na
\fBdelete-to-column\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to the column that is specified by the repeat count.
.RE

.sp
.ne 2
.mk
.na
\fBdelete-to-parenthesis\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to and including the matching parenthesis, or next close parenthesis.
.RE

.sp
.ne 2
.mk
.na
\fBforward-delete-find\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to and including the following occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-delete-find\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to and including the preceding occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
\fBforward-delete-to\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to, but not including, the following occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-delete-to\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to, but not including, the preceding occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
\fBdelete-refind\fR
.ad
.RS 30n
.rt  
Repeat the last *-delete-find or *-delete-to action.
.RE

.sp
.ne 2
.mk
.na
\fBdelete-invert-refind\fR
.ad
.RS 30n
.rt  
Repeat the last *-delete-find or *-delete-to action, in the opposite direction.
.RE

.sp
.ne 2
.mk
.na
\fBcopy-to-column\fR
.ad
.RS 30n
.rt  
Copy the characters from the cursor up to the column that is specified by the repeat count, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBcopy-to-parenthesis\fR
.ad
.RS 30n
.rt  
Copy the characters from the cursor up to and including the matching parenthesis, or next close parenthesis, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBforward-copy-find\fR
.ad
.RS 30n
.rt  
Copy the characters from the cursor up to and including the following occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-copy-find\fR
.ad
.RS 30n
.rt  
Copy the characters from the cursor up to and including the preceding occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBforward-copy-to\fR
.ad
.RS 30n
.rt  
Copy the characters from the cursor up to, but not including, the following occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBbackward-copy-to\fR
.ad
.RS 30n
.rt  
Copy the characters from the cursor up to, but not including, the preceding occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
\fBcopy-refind\fR
.ad
.RS 30n
.rt  
Repeat the last *-copy-find or *-copy-to action.
.RE

.sp
.ne 2
.mk
.na
\fBcopy-invert-refind\fR
.ad
.RS 30n
.rt  
Repeat the last *-copy-find or *-copy-to action, in the opposite direction.
.RE

.sp
.ne 2
.mk
.na
\fBvi-mode\fR
.ad
.RS 30n
.rt  
Switch to \fBvi\fR mode from emacs mode.
.RE

.sp
.ne 2
.mk
.na
\fBemacs-mode\fR
.ad
.RS 30n
.rt  
Switch to \fBemacs\fR mode from \fBvi\fR mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-insert\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, switch to insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-overwrite\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, switch to overwrite mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-insert-at-bol\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, move the cursor to the start of the line and switch to insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-append-at-eol\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, move the cursor to the end of the line and switch to append mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-append\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, move the cursor one position right, and switch to insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-replace-char\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, replace the character under the cursor with the next character entered.
.RE

.sp
.ne 2
.mk
.na
\fBvi-forward-change-char\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the next character then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-backward-change-char\fR
.ad
.RS 30n
.rt  
From vi command mode, delete the preceding character then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-forward-change-word\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the next word then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-backward-change-word\fR
.ad
.RS 30n
.rt  
From vi command mode, delete the preceding word then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-rest-of-line\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete from the cursor to the end of the line, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-line\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the current line, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-to-bol\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete all characters between the cursor and the beginning of the line, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-to-column\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the characters from the cursor up to the column that is specified by the repeat count, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-to-parenthesis\fR
.ad
.RS 30n
.rt  
Delete the characters from the cursor up to and including the matching parenthesis, or next close parenthesis, then enter \fBvi\fR insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-forward-change-find\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the characters from the cursor up to and including the following occurence of the next character typed, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-backward-change-find\fR
.ad
.RS 30n
.rt  
From vi command mode, delete the characters from the cursor up to and including the preceding occurence of the next character typed, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-forward-change-to\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the characters from the cursor up to, but not including, the following occurence of the next character typed, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-backward-change-to\fR
.ad
.RS 30n
.rt  
From \fBvi\fR command mode, delete the characters from the cursor up to, but not including, the preceding occurence of the next character typed, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-refind\fR
.ad
.RS 30n
.rt  
Repeat the last vi-*-change-find or vi-*-change-to action.
.RE

.sp
.ne 2
.mk
.na
\fBvi-change-invert-refind\fR
.ad
.RS 30n
.rt  
Repeat the last vi-*-change-find or vi-*-change-to action, in the opposite direction.
.RE

.sp
.ne 2
.mk
.na
\fBvi-undo\fR
.ad
.RS 30n
.rt  
In \fBvi\fR mode, undo the last editing operation.
.RE

.sp
.ne 2
.mk
.na
\fBvi-repeat-change\fR
.ad
.RS 30n
.rt  
In \fBvi\fR command mode, repeat the last command that modified the line.
.RE

.SS "Default Key Bindings In \fBemacs\fR Mode"
.sp
.LP
The following default key bindings, which can be overriden by the tecla configuration file, are designed to mimic most of the bindings of the unix \fBtcsh shell\fR shell, when it is in \fBemacs\fR editing mode.
.sp
.LP
This is the default editing mode of the tecla library.
.sp
.LP
Under UNIX the terminal driver sets a number of special keys for certain functions. The tecla library attempts to use the same key bindings to maintain consistency. The key sequences shown for the following 6 bindings are thus just examples of what they will probably be set to. If you have used the stty command to change these keys, then the default bindings should match.
.sp
.ne 2
.mk
.na
\fB\fB^C\fR\fR
.ad
.RS 6n
.rt  
user-interrupt
.RE

.sp
.ne 2
.mk
.na
\fB\fB^\\fR\fR
.ad
.RS 6n
.rt  
abort
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Z\fR\fR
.ad
.RS 6n
.rt  
suspend
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Q\fR\fR
.ad
.RS 6n
.rt  
start-output
.RE

.sp
.ne 2
.mk
.na
\fB\fB^S\fR\fR
.ad
.RS 6n
.rt  
stop-output
.RE

.sp
.ne 2
.mk
.na
\fB\fB^V\fR\fR
.ad
.RS 6n
.rt  
literal-next
.RE

.sp
.LP
The cursor keys are refered to by name, as follows. This is necessary because different types of terminals generate different key sequences when their cursor keys are pressed.
.sp
.ne 2
.mk
.na
\fBright\fR
.ad
.RS 9n
.rt  
cursor-right
.RE

.sp
.ne 2
.mk
.na
\fBleft\fR
.ad
.RS 9n
.rt  
cursor-left
.RE

.sp
.ne 2
.mk
.na
\fBup\fR
.ad
.RS 9n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fBdown\fR
.ad
.RS 9n
.rt  
down-history
.RE

.sp
.LP
The remaining bindings don't depend on the terminal setttings.
.sp
.ne 2
.mk
.na
\fB\fB^F\fR\fR
.ad
.RS 21n
.rt  
cursor-right
.RE

.sp
.ne 2
.mk
.na
\fB\fB^B\fR\fR
.ad
.RS 21n
.rt  
cursor-left
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-i\fR\fR
.ad
.RS 21n
.rt  
insert-mode
.RE

.sp
.ne 2
.mk
.na
\fB\fB^A\fR\fR
.ad
.RS 21n
.rt  
beginning-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fB^E\fR\fR
.ad
.RS 21n
.rt  
end-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fB^U\fR\fR
.ad
.RS 21n
.rt  
delete-line
.RE

.sp
.ne 2
.mk
.na
\fB\fB^K\fR\fR
.ad
.RS 21n
.rt  
kill-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-f\fR\fR
.ad
.RS 21n
.rt  
forward-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-b\fR\fR
.ad
.RS 21n
.rt  
backward-word
.RE

.sp
.ne 2
.mk
.na
\fB\fB^D\fR\fR
.ad
.RS 21n
.rt  
del-char-or-list-or-eof
.RE

.sp
.ne 2
.mk
.na
\fB\fB^H\fR\fR
.ad
.RS 21n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fB^?\fR\fR
.ad
.RS 21n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d\fR\fR
.ad
.RS 21n
.rt  
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^H\fR\fR
.ad
.RS 21n
.rt  
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^?\fR\fR
.ad
.RS 21n
.rt  
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-u\fR\fR
.ad
.RS 21n
.rt  
upcase-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-l\fR\fR
.ad
.RS 21n
.rt  
downcase-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c\fR\fR
.ad
.RS 21n
.rt  
capitalize-word
.RE

.sp
.ne 2
.mk
.na
\fB\fB^R\fR\fR
.ad
.RS 21n
.rt  
redisplay
.RE

.sp
.ne 2
.mk
.na
\fB\fB^L\fR\fR
.ad
.RS 21n
.rt  
clear-screen
.RE

.sp
.ne 2
.mk
.na
\fB\fB^T\fR\fR
.ad
.RS 21n
.rt  
transpose-chars
.RE

.sp
.ne 2
.mk
.na
\fB\fB^@\fR\fR
.ad
.RS 21n
.rt  
set-mark
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X^X\fR\fR
.ad
.RS 21n
.rt  
exchange-point-and-mark
.RE

.sp
.ne 2
.mk
.na
\fB\fB^W\fR\fR
.ad
.RS 21n
.rt  
kill-region
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-w\fR\fR
.ad
.RS 21n
.rt  
copy-region-as-kill
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Y\fR\fR
.ad
.RS 21n
.rt  
yank
.RE

.sp
.ne 2
.mk
.na
\fB\fB^P\fR\fR
.ad
.RS 21n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fB^N\fR\fR
.ad
.RS 21n
.rt  
down-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-p\fR\fR
.ad
.RS 21n
.rt  
history-search-backward
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-n\fR\fR
.ad
.RS 21n
.rt  
history-search-forward
.RE

.sp
.ne 2
.mk
.na
\fB\fB^I\fR\fR
.ad
.RS 21n
.rt  
complete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X*\fR\fR
.ad
.RS 21n
.rt  
expand-filename
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X^F\fR\fR
.ad
.RS 21n
.rt  
read-from-file
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X^R\fR\fR
.ad
.RS 21n
.rt  
read-init-files
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Xg\fR\fR
.ad
.RS 21n
.rt  
list-glob
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Xh\fR\fR
.ad
.RS 21n
.rt  
list-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-<\fR\fR
.ad
.RS 21n
.rt  
beginning-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM->\fR\fR
.ad
.RS 21n
.rt  
end-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\fB\n\fR\fR
.ad
.RS 21n
.rt  
newline
.RE

.sp
.ne 2
.mk
.na
\fB\fB\r\fR\fR
.ad
.RS 21n
.rt  
newline
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-o\fR\fR
.ad
.RS 21n
.rt  
repeat-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^V\fR\fR
.ad
.RS 21n
.rt  
\fBvi\fR-mode
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-0, M-1, ... M-9\fR\fR
.ad
.RS 21n
.rt  
digit-argument (see below)
.RE

.sp
.LP
Note that \fB^I\fR is what the TAB key generates, and that \fB^@\fR can be generated not only by pressing the CONTROL key and the @ key simultaneously, but also by pressing the CONTROL key and the space bar at the same time.
.SS "Default Key Bindings in \fBvi\fR Mode"
.sp
.LP
The following default key bindings are designed to mimic the \fBvi\fR style of editing as closely as possible. This means that very few editing functions are provided in the initial character input mode, editing functions instead being provided by the \fBvi\fR command mode. The \fBvi\fR command mode is entered whenever the ESCAPE character is pressed, or whenever a key sequence that starts with a meta character is entered. In addition to mimicing \fBvi\fR, \fBlibtecla\fR provides bindings for tab completion, wild-card expansion of file names, and historical line recall.
.sp
.LP
To learn how to tell the tecla library to use \fBvi\fR mode instead of the default \fBemacs\fR editing mode, see the earlier section entitled The Tecla Configuration File.
.sp
.LP
Under UNIX the terminal driver sets a number of special keys for certain functions. The tecla library attempts to use the same key bindings to maintain consistency, binding them both in input mode and in command mode. The key sequences shown for the following 6 bindings are thus just examples of what they will probably be set to. If you have used the \fBstty\fR command to change these keys, then the default bindings should match.
.sp
.ne 2
.mk
.na
\fB\fB^C\fR\fR
.ad
.RS 8n
.rt  
user-interrupt
.RE

.sp
.ne 2
.mk
.na
\fB\fB^\\fR\fR
.ad
.RS 8n
.rt  
abort
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Z\fR\fR
.ad
.RS 8n
.rt  
suspend
.RE

.sp
.ne 2
.mk
.na
\fB\fB^Q\fR\fR
.ad
.RS 8n
.rt  
start-output
.RE

.sp
.ne 2
.mk
.na
\fB\fB^S\fR\fR
.ad
.RS 8n
.rt  
stop-output
.RE

.sp
.ne 2
.mk
.na
\fB\fB^V\fR\fR
.ad
.RS 8n
.rt  
literal-next
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^C\fR\fR
.ad
.RS 8n
.rt  
user-interrupt
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^\\fR\fR
.ad
.RS 8n
.rt  
abort
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^Z\fR\fR
.ad
.RS 8n
.rt  
suspend
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^Q\fR\fR
.ad
.RS 8n
.rt  
start-output
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^S\fR\fR
.ad
.RS 8n
.rt  
stop-output
.RE

.sp
.LP
Note that above, most of the bindings are defined twice, once as a raw control code like \fB^C\fR and then a second time as a META character like \fBM-^C\fR. The former is the binding for \fBvi\fR input mode, whereas the latter is the binding for \fBvi\fR command mode. Once in command mode all key sequences that the user types that they don't explicitly start with an ESCAPE or a META key, have their first key secretly converted to a META character before the key sequence is looked up in the key binding table. Thus, once in command mode, when you type the letter i, for example, the tecla library actually looks up the binding for \fBM-i\fR.
.sp
.LP
The cursor keys are refered to by name, as follows. This is necessary because different types of terminals generate different key sequences when their cursor keys are pressed.
.sp
.ne 2
.mk
.na
\fB\fBright\fR\fR
.ad
.RS 9n
.rt  
cursor-right
.RE

.sp
.ne 2
.mk
.na
\fB\fBleft\fR\fR
.ad
.RS 9n
.rt  
cursor-left
.RE

.sp
.ne 2
.mk
.na
\fB\fBup\fR\fR
.ad
.RS 9n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBdown\fR\fR
.ad
.RS 9n
.rt  
down-history
.RE

.sp
.LP
The cursor keys normally generate a key sequence that start with an ESCAPE character, so beware that using the arrow keys will put you into command mode (if you aren't already in command mode).
.sp
.LP
The following are the terminal-independent key bindings for \fBvi\fR input mode.
.sp
.ne 2
.mk
.na
\fB\fB^D\fR\fR
.ad
.RS 8n
.rt  
list-or-eof
.RE

.sp
.ne 2
.mk
.na
\fB\fB^G\fR\fR
.ad
.RS 8n
.rt  
list-glob
.RE

.sp
.ne 2
.mk
.na
\fB\fB^H\fR\fR
.ad
.RS 8n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fB^I\fR\fR
.ad
.RS 8n
.rt  
complete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fB\r\fR\fR
.ad
.RS 8n
.rt  
newline
.RE

.sp
.ne 2
.mk
.na
\fB\fB\n\fR\fR
.ad
.RS 8n
.rt  
newline
.RE

.sp
.ne 2
.mk
.na
\fB\fB^L\fR\fR
.ad
.RS 8n
.rt  
clear-screen
.RE

.sp
.ne 2
.mk
.na
\fB\fB^N\fR\fR
.ad
.RS 8n
.rt  
down-history
.RE

.sp
.ne 2
.mk
.na
\fB\fB^P\fR\fR
.ad
.RS 8n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fB^R\fR\fR
.ad
.RS 8n
.rt  
redisplay
.RE

.sp
.ne 2
.mk
.na
\fB\fB^U\fR\fR
.ad
.RS 8n
.rt  
backward-kill-line
.RE

.sp
.ne 2
.mk
.na
\fB\fB^W\fR\fR
.ad
.RS 8n
.rt  
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X*\fR\fR
.ad
.RS 8n
.rt  
expand-filename
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X^F\fR\fR
.ad
.RS 8n
.rt  
read-from-file
.RE

.sp
.ne 2
.mk
.na
\fB\fB^X^R\fR\fR
.ad
.RS 8n
.rt  
read-init-files
.RE

.sp
.ne 2
.mk
.na
\fB\fB^?\fR\fR
.ad
.RS 8n
.rt  
backward-delete-char
.RE

.sp
.LP
The following are the key bindings that are defined in \fBvi\fR command mode, this being specified by them all starting with a META character. As mentioned above, once in command mode the initial meta character is optional. For example, you might enter command mode by typing ESCAPE, and then press 'H' twice to move the cursor two positions to the left. Both 'H' characters get quietly converted to \fBM-h\fR before being compared to the key binding table, the first one because ESCAPE followed by a character is always converted to the equivalent META character, and the second because command mode was already active.
.sp
.ne 2
.mk
.na
\fB\fBM-\\fR\fR
.ad
.RS 21n
.rt  
cursor-right (META-space)
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-$\fR\fR
.ad
.RS 21n
.rt  
end-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-*\fR\fR
.ad
.RS 21n
.rt  
expand-filename
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-+\fR\fR
.ad
.RS 21n
.rt  
down-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM--\fR\fR
.ad
.RS 21n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-<\fR\fR
.ad
.RS 21n
.rt  
beginning-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM->\fR\fR
.ad
.RS 21n
.rt  
end-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^\fR\fR
.ad
.RS 21n
.rt  
beginning-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-\fR\fR
.ad
.RS 21n
.rt  
repeat-find-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-,\fR\fR
.ad
.RS 21n
.rt  
invert-refind-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-|\fR\fR
.ad
.RS 21n
.rt  
goto-column
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-~\fR\fR
.ad
.RS 21n
.rt  
change-case
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-.\fR\fR
.ad
.RS 21n
.rt  
vi-repeat-change
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-%\fR\fR
.ad
.RS 21n
.rt  
find-parenthesis
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-a\fR\fR
.ad
.RS 21n
.rt  
vi-append
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-A\fR\fR
.ad
.RS 21n
.rt  
vi-append-at-eol
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-b\fR\fR
.ad
.RS 21n
.rt  
backward-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-B\fR\fR
.ad
.RS 21n
.rt  
backward-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-C\fR\fR
.ad
.RS 21n
.rt  
vi-change-rest-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cb\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cB\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cc\fR\fR
.ad
.RS 21n
.rt  
vi-change-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-ce\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cE\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cw\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cW\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cF\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-find
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cf\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-find
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cT\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-to
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-ct\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-to
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c;\fR\fR
.ad
.RS 21n
.rt  
vi-change-refind
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c,\fR\fR
.ad
.RS 21n
.rt  
vi-change-invert-refind
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-ch\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c^H\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c^?\fR\fR
.ad
.RS 21n
.rt  
vi-backward-change-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-cl\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c\\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-char (META-c-space)
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c^\fR\fR
.ad
.RS 21n
.rt  
vi-change-to-bol
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c0\fR\fR
.ad
.RS 21n
.rt  
vi-change-to-bol
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c$\fR\fR
.ad
.RS 21n
.rt  
vi-change-rest-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c|\fR\fR
.ad
.RS 21n
.rt  
vi-change-to-column
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-c%\fR\fR
.ad
.RS 21n
.rt  
vi-change-to-parenthesis
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dh\fR\fR
.ad
.RS 21n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d^H\fR\fR
.ad
.RS 21n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d^?\fR\fR
.ad
.RS 21n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dl\fR\fR
.ad
.RS 21n
.rt  
forward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d\fR\fR
.ad
.RS 21n
.rt  
forward-delete-char (META-d-space)
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dd\fR\fR
.ad
.RS 21n
.rt  
delete-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-db\fR\fR
.ad
.RS 21n
.rt  
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dB\fR\fR
.ad
.RS 21n
.rt  
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-de\fR\fR
.ad
.RS 21n
.rt  
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dE\fR\fR
.ad
.RS 21n
.rt  
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dw\fR\fR
.ad
.RS 21n
.rt  
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dW\fR\fR
.ad
.RS 21n
.rt  
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dF\fR\fR
.ad
.RS 21n
.rt  
backward-delete-find
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-df\fR\fR
.ad
.RS 21n
.rt  
forward-delete-find
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dT\fR\fR
.ad
.RS 21n
.rt  
backward-delete-to
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-dt\fR\fR
.ad
.RS 21n
.rt  
forward-delete-to
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d;\fR\fR
.ad
.RS 21n
.rt  
delete-refind
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d,\fR\fR
.ad
.RS 21n
.rt  
delete-invert-refind
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d^\fR\fR
.ad
.RS 21n
.rt  
backward-kill-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d0\fR\fR
.ad
.RS 21n
.rt  
backward-kill-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d$\fR\fR
.ad
.RS 21n
.rt  
kill-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-D\fR\fR
.ad
.RS 21n
.rt  
kill-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d|\fR\fR
.ad
.RS 21n
.rt  
delete-to-column
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-d%\fR\fR
.ad
.RS 21n
.rt  
delete-to-parenthesis
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-e\fR\fR
.ad
.RS 21n
.rt  
forward-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-E\fR\fR
.ad
.RS 21n
.rt  
forward-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-f\fR\fR
.ad
.RS 21n
.rt  
forward-find-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-F\fR\fR
.ad
.RS 21n
.rt  
backward-find-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM--\fR\fR
.ad
.RS 21n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-h\fR\fR
.ad
.RS 21n
.rt  
cursor-left
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-H\fR\fR
.ad
.RS 21n
.rt  
beginning-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-i\fR\fR
.ad
.RS 21n
.rt  
vi-insert
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-I\fR\fR
.ad
.RS 21n
.rt  
vi-insert-at-bol
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-j\fR\fR
.ad
.RS 21n
.rt  
down-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-J\fR\fR
.ad
.RS 21n
.rt  
history-search-forward
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-k\fR\fR
.ad
.RS 21n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-K\fR\fR
.ad
.RS 21n
.rt  
history-search-backward
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-l\fR\fR
.ad
.RS 21n
.rt  
cursor-right
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-L\fR\fR
.ad
.RS 21n
.rt  
end-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-n\fR\fR
.ad
.RS 21n
.rt  
history-re-search-forward
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-N\fR\fR
.ad
.RS 21n
.rt  
history-re-search-backward
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-p\fR\fR
.ad
.RS 21n
.rt  
append-yank
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-P\fR\fR
.ad
.RS 21n
.rt  
yank
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-r\fR\fR
.ad
.RS 21n
.rt  
vi-replace-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-R\fR\fR
.ad
.RS 21n
.rt  
vi-overwrite
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-s\fR\fR
.ad
.RS 21n
.rt  
vi-forward-change-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-S\fR\fR
.ad
.RS 21n
.rt  
vi-change-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-t\fR\fR
.ad
.RS 21n
.rt  
forward-to-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-T\fR\fR
.ad
.RS 21n
.rt  
backward-to-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-u\fR\fR
.ad
.RS 21n
.rt  
vi-undo
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-w\fR\fR
.ad
.RS 21n
.rt  
forward-to-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-W\fR\fR
.ad
.RS 21n
.rt  
forward-to-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-x\fR\fR
.ad
.RS 21n
.rt  
forward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-X\fR\fR
.ad
.RS 21n
.rt  
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yh\fR\fR
.ad
.RS 21n
.rt  
backward-copy-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y^H\fR\fR
.ad
.RS 21n
.rt  
backward-copy-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y^?\fR\fR
.ad
.RS 21n
.rt  
backward-copy-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yl\fR\fR
.ad
.RS 21n
.rt  
forward-copy-char
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y\\fR\fR
.ad
.RS 21n
.rt  
forward-copy-char (META-y-space)
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-ye\fR\fR
.ad
.RS 21n
.rt  
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yE\fR\fR
.ad
.RS 21n
.rt  
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yw\fR\fR
.ad
.RS 21n
.rt  
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yW\fR\fR
.ad
.RS 21n
.rt  
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yb\fR\fR
.ad
.RS 21n
.rt  
backward-copy-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yB\fR\fR
.ad
.RS 21n
.rt  
backward-copy-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yf\fR\fR
.ad
.RS 21n
.rt  
forward-copy-find
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yF\fR\fR
.ad
.RS 21n
.rt  
backward-copy-find
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yt\fR\fR
.ad
.RS 21n
.rt  
forward-copy-to
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yT\fR\fR
.ad
.RS 21n
.rt  
backward-copy-to
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y;\fR\fR
.ad
.RS 21n
.rt  
copy-refind
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y,\fR\fR
.ad
.RS 21n
.rt  
copy-invert-refind
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y^\fR\fR
.ad
.RS 21n
.rt  
copy-to-bol
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y0\fR\fR
.ad
.RS 21n
.rt  
copy-to-bol
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y$\fR\fR
.ad
.RS 21n
.rt  
copy-rest-of-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-yy\fR\fR
.ad
.RS 21n
.rt  
copy-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-Y\fR\fR
.ad
.RS 21n
.rt  
copy-line
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y|\fR\fR
.ad
.RS 21n
.rt  
copy-to-column
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-y%\fR\fR
.ad
.RS 21n
.rt  
copy-to-parenthesis
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^E\fR\fR
.ad
.RS 21n
.rt  
emacs-mode
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^H\fR\fR
.ad
.RS 21n
.rt  
cursor-left
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^?\fR\fR
.ad
.RS 21n
.rt  
cursor-left
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^L\fR\fR
.ad
.RS 21n
.rt  
clear-screen
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^N\fR\fR
.ad
.RS 21n
.rt  
down-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^P\fR\fR
.ad
.RS 21n
.rt  
up-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^R\fR\fR
.ad
.RS 21n
.rt  
redisplay
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^D\fR\fR
.ad
.RS 21n
.rt  
list-or-eof
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^I\fR\fR
.ad
.RS 21n
.rt  
complete-word
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-\r\fR\fR
.ad
.RS 21n
.rt  
newline
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-\n\fR\fR
.ad
.RS 21n
.rt  
newline
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^X^R\fR\fR
.ad
.RS 21n
.rt  
read-init-files
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-^Xh\fR\fR
.ad
.RS 21n
.rt  
list-history
.RE

.sp
.ne 2
.mk
.na
\fB\fBM-0, M-1, ... M-9\fR\fR
.ad
.RS 21n
.rt  
digit-argument (see below)
.RE

.sp
.LP
Note that \fB^I\fR is what the TAB key generates.
.SS "Entering Repeat Counts"
.sp
.LP
Many of the key binding functions described previously, take an optional count, typed in before the target key sequence. This is interpreted as a repeat count by most bindings. A notable exception is the goto-column binding, which interprets the count as a column number.
.sp
.LP
By default you can specify this count argument by pressing the META key while typing in the numeric count. This relies on the digit-argument action being bound to 'META-0', 'META-1' etc. Once any one of these bindings has been activated, you can optionally take your finger off the META key to type in the rest of the number, since every numeric digit thereafter is treated as part of the number, unless it is preceded by the literal-next binding. As soon as a non-digit, or literal digit key is pressed the repeat count is terminated and either causes the just typed character to be added to the line that many times, or causes the next key binding function to be given that argument.
.sp
.LP
For example, in \fBemacs\fR mode, typing: 
.sp
.in +2
.nf
M-12a
.fi
.in -2

.sp
.LP
causes the letter 'a' to be added to the line 12 times, whereas 
.sp
.in +2
.nf
M-4M-c
.fi
.in -2

.sp
.LP
Capitalizes the next 4 words.
.sp
.LP
In \fBvi\fR command mode the meta modifier is automatically added to all characters typed in, so to enter a count in \fBvi\fR command-mode, just involves typing in the number, just as it does in the \fBvi\fR editor itself. So for example, in vi command mode, typing:
.sp
.in +2
.nf
4w2x
.fi
.in -2

.sp
.LP
moves the cursor four words to the right, then deletes two characters.
.sp
.LP
You can also bind digit-argument to other key sequences. If these end in a numeric digit, that digit gets appended to the current repeat count. If it doesn't end in a numeric digit, a new repeat count is started with a value of zero, and can be completed by typing in the number, after letting go of the key which triggered the digit-argument action.
.SH FILES
.sp
.ne 2
.mk
.na
\fB\fB/usr/lib/libtecla.so\fR\fR
.ad
.RS 27n
.rt  
The tecla library
.RE

.sp
.ne 2
.mk
.na
\fB\fB/usr/include/libtecla.h\fR\fR
.ad
.RS 27n
.rt  
The tecla header file
.RE

.sp
.ne 2
.mk
.na
\fB\fB~/.teclarc\fR\fR
.ad
.RS 27n
.rt  
The personal tecla customization file
.RE

.SH ATTRIBUTES
.sp
.LP
See \fBattributes\fR(5) for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i) 
lw(2.75i) |lw(2.75i) 
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
Availabilitylibrary/libtecla
_
Interface StabilityCommitted
.TE

.SH SEE ALSO
.sp
.LP
\fBvi\fR(1), \fBcpl_complete_word\fR(3TECLA), \fBef_expand_file\fR(3TECLA), \fBgl_get_line\fR(3TECLA), \fBgl_io_mode\fR(3TECLA), \fBlibtecla\fR(3LIB), \fBpca_lookup_file\fR(3TECLA), \fBattributes\fR(5)
