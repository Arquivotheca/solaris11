.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTODO 1"
.TH PERLTODO 1 "2004-06-08" "perl v5.8.4" "Perl Programmers Reference Guide"
.SH "NAME"
perltodo \- Perl TO\-DO List
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a list of wishes for Perl.  Send updates to
\&\fIperl5\-porters@perl.org\fR.  If you want to work on any of these
projects, be sure to check the perl5\-porters archives for past ideas,
flames, and propaganda.  This will save you time and also prevent you
from implementing something that Larry has already vetoed.  One set
of archives may be found at:
.PP
.Vb 1
\&    http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/
.Ve
.SH "To do during 5.6.x"
.IX Header "To do during 5.6.x"
.Sh "Support for I/O disciplines"
.IX Subsection "Support for I/O disciplines"
\&\f(CW\*(C`perlio\*(C'\fR provides this, but the interface could be a lot more
straightforward.
.Sh "Autoload bytes.pm"
.IX Subsection "Autoload bytes.pm"
When the lexer sees, for instance, \f(CW\*(C`bytes::length\*(C'\fR, it should
automatically load the \f(CW\*(C`bytes\*(C'\fR pragma.
.ie n .Sh "Make ""\eu{\s-1XXXX\s0}"" et al work"
.el .Sh "Make ``\eu{\s-1XXXX\s0}'' et al work"
.IX Subsection "Make u{XXXX} et al work"
Danger, Will Robinson! Discussing the semantics of \f(CW"\ex{F00}"\fR,
\&\f(CW"\exF00"\fR and \f(CW"\eU{F00}"\fR on P5P \fIwill\fR lead to a long and boring
flamewar.
.Sh "Create a char *sv_pvprintify(sv, \s-1STRLEN\s0 *lenp, \s-1UV\s0 flags)"
.IX Subsection "Create a char *sv_pvprintify(sv, STRLEN *lenp, UV flags)"
For displaying PVs with control characters, embedded nulls, and Unicode.
This would be useful for printing warnings, or data and regex dumping,
\&\fInot_a_number()\fR, and so on.
.PP
Requirements: should handle both byte and \s-1UTF\-8\s0 strings.  \fIisPRINT()\fR
characters printed as\-is, character less than 256 as \exHH, Unicode
characters as \ex{\s-1HHH\s0}.  Don't assume ASCII\-like, either, get somebody
on \s-1EBCDIC\s0 to test the output.
.PP
Possible options, controlled by the flags:
\&\- whitespace (other than ' ' of \fIisPRINT()\fR) printed as-is
\&\- use \fIisPRINT_LC()\fR instead of \fIisPRINT()\fR
\&\- print control characters like this: \*(L"\ecA\*(R"
\&\- print control characters like this: \*(L"^A\*(R"
\&\- non-PRINTables printed as '.' instead of \exHH
\&\- use \eOOO instead of \exHH
\&\- use the C/Perl\-metacharacters like \en, \et
\&\- have a maximum length for the produced string (read it from *lenp)
\&\- append a \*(L"...\*(R" to the produced string if the maximum length is exceeded
\&\- really fancy: print unicode characters as \eN{...}
.PP
\&\s-1NOTE:\s0 \fIpv_display()\fR, \fIpv_uni_display()\fR, \fIsv_uni_display()\fR are already
doing something like the above.
.Sh "Overloadable regex assertions"
.IX Subsection "Overloadable regex assertions"
This may or may not be possible with the current regular expression
engine. The idea is that, for instance, \f(CW\*(C`\eb\*(C'\fR needs to be
algorithmically computed if you're dealing with Thai text. Hence, the
\&\fB\eb\fR assertion wants to be overloaded by a function.
.Sh "Unicode"
.IX Subsection "Unicode"
.IP "\(bu" 4
Allow for long form of the General Category Properties, e.g
\&\f(CW\*(C`\ep{IsOpenPunctuation}\*(C'\fR, not just the abbreviated form, e.g.
\&\f(CW\*(C`\ep{IsPs}\*(C'\fR.
.IP "\(bu" 4
Allow for the metaproperties: \f(CW\*(C`XID Start\*(C'\fR, \f(CW\*(C`XID Continue\*(C'\fR,
\&\f(CW\*(C`NF*_NO\*(C'\fR, \f(CW\*(C`NF*_MAYBE\*(C'\fR (require the DerivedCoreProperties and
DerviceNormalizationProperties files).
.Sp
There are also multiple value properties still unimplemented:
\&\f(CW\*(C`Numeric Type\*(C'\fR, \f(CW\*(C`East Asian Width\*(C'\fR.
.IP "\(bu" 4
.Vb 1
\&    Case Mappings? http://www.unicode.org/unicode/reports/tr21/
.Ve
.Sp
Mostly implemented (all of 1:1, 1:N, N:1), only the \*(L"final sigma\*(R"
and locale-specific rules of SpecCase are not implemented.
.IP "\(bu" 4
\&\s-1UTF\-8\s0 identifier names should probably be canonicalized: \s-1NFC\s0?
.IP "\(bu" 4
\&\s-1UTF\-8\s0 in package names and sub names?  The first is problematic
because of the mapping to pathnames, ditto for the second one if
one does autosplitting, for example.  Some of this works already
in 5.8.0, but essentially it is unsupported.  Constructs to consider,
at the very least:
.Sp
.Vb 11
\&        use utf8;
\&        package UnicodePackage;
\&        sub new { bless {}, shift };
\&        sub UnicodeMethod1 { ... $_[0]->UnicodeMethod2(...) ... }
\&        sub UnicodeMethod2 { ... } # in here caller(0) should contain Unicode
\&        ...
\&        package main;
\&        my $x = UnicodePackage->new;
\&        print ref $x, "\en";  # should be Unicode
\&        $x->UnicodeMethod1(...);
\&        my $y = UnicodeMethod3 UnicodePackage ...;
.Ve
.Sp
In the above all \fIUnicodeXxx\fR contain (identifier\-worthy) characters
beyond the code point 255, for example 256.  Wherever package/class or
subroutine names can be returned needs to be checked for Unicodeness.
.PP
See \*(L"\s-1UNICODE\s0 \s-1REGULAR\s0 \s-1EXPRESSION\s0 \s-1SUPPORT\s0 \s-1LEVEL\s0\*(R" in perlunicode for what's
there and what's missing.  Almost all of Levels 2 and 3 is missing,
and as of 5.8.0 not even all of Level 1 is there.
They have some tricks Perl doesn't yet implement, such as character
class subtraction.
.PP
.Vb 1
\&        http://www.unicode.org/unicode/reports/tr18/
.Ve
.Sh "Work out exit/die semantics for threads"
.IX Subsection "Work out exit/die semantics for threads"
There are some suggestions to use for example something like this:
default to \*(L"(thread exiting first will) wait for the other threads
until up to 60 seconds\*(R".  Other possibilities:
.PP
.Vb 1
\&    use threads wait => 0;
.Ve
.PP
Do not wait.
.PP
.Vb 1
\&    use threads wait_for => 10;
.Ve
.PP
Wait up to 10 seconds.
.PP
.Vb 1
\&    use threads wait_for => -1;
.Ve
.PP
Wait for ever.
.PP
http://archive.develooper.com/perl5\-porters@perl.org/msg79618.html
.Sh "Better support for nonpreemptive threading systems like \s-1GNU\s0 pth"
.IX Subsection "Better support for nonpreemptive threading systems like GNU pth"
To better support nonpreemptive threading systems, perhaps some of the
blocking functions internally in Perl should do a \fIyield()\fR before a
blocking call.  (Now certain threads tests ({basic,list,thread.t})
simply do a \fIyield()\fR before they \fIsleep()\fR to give nonpreemptive thread
implementations a chance).
.PP
In some cases, like the \s-1GNU\s0 pth, which has replacement functions that
are nonblocking (pth_select instead of select), maybe Perl should be
using them instead when built for threading.
.Sh "Typed lexicals for compiler"
.IX Subsection "Typed lexicals for compiler"
.Sh "Compiler workarounds for Win32"
.IX Subsection "Compiler workarounds for Win32"
.Sh "AUTOLOADing in the compiler"
.IX Subsection "AUTOLOADing in the compiler"
.Sh "Fixing comppadlist when compiling"
.IX Subsection "Fixing comppadlist when compiling"
.Sh "Cleaning up exported namespace"
.IX Subsection "Cleaning up exported namespace"
.Sh "Complete signal handling"
.IX Subsection "Complete signal handling"
Add \f(CW\*(C`PERL_ASYNC_CHECK\*(C'\fR to opcodes which loop; replace \f(CW\*(C`sigsetjmp\*(C'\fR with
\&\f(CW\*(C`sigjmp\*(C'\fR; check \f(CW\*(C`wait\*(C'\fR for signal safety.
.Sh "Out-of-source builds"
.IX Subsection "Out-of-source builds"
This was done for 5.6.0, but needs reworking for 5.7.x
.Sh "\s-1POSIX\s0 realtime support"
.IX Subsection "POSIX realtime support"
\&\s-1POSIX\s0 1003.1 1996 Edition support\*(--realtime stuff: \s-1POSIX\s0 semaphores,
message queues, shared memory, realtime clocks, timers, signals (the
metaconfig units mostly already exist for these)
.Sh "\s-1UNIX98\s0 support"
.IX Subsection "UNIX98 support"
Reader-writer locks, realtime/asynchronous \s-1IO\s0
.Sh "IPv6 Support"
.IX Subsection "IPv6 Support"
There are non-core modules, such as \f(CW\*(C`Socket6\*(C'\fR, but these will need
integrating when IPv6 actually starts to really happen.  See \s-1RFC\s0 2292
and \s-1RFC\s0 2553.
.Sh "Long double conversion"
.IX Subsection "Long double conversion"
Floating point formatting is still causing some weird test failures.
.Sh "Locales"
.IX Subsection "Locales"
Locales and Unicode interact with each other in unpleasant ways.
One possible solution would be to adopt/support \s-1ICU:\s0
.PP
.Vb 1
\&        http://oss.software.ibm.com/icu/index.html
.Ve
.Sh "Arithmetic on non-Arabic numerals"
.IX Subsection "Arithmetic on non-Arabic numerals"
\&\f(CW\*(C`[1234567890]\*(C'\fR aren't the only numerals any more.
.Sh "\s-1POSIX\s0 Unicode character classes"
.IX Subsection "POSIX Unicode character classes"
(\f(CW\*(C`[=a=]\*(C'\fR for equivalence classes, \f(CW\*(C`[.ch.]\*(C'\fR for collation.)
These are dependent on Unicode normalization and collation.
.Sh "Factoring out common suffices/prefices in regexps (trie optimization)"
.IX Subsection "Factoring out common suffices/prefices in regexps (trie optimization)"
Currently, the user has to optimize \f(CW\*(C`foo|far\*(C'\fR and \f(CW\*(C`foo|goo\*(C'\fR into
\&\f(CW\*(C`f(?:oo|ar)\*(C'\fR and \f(CW\*(C`[fg]oo\*(C'\fR by hand; this could be done automatically.
.Sh "Security audit shipped utilities"
.IX Subsection "Security audit shipped utilities"
All the code we ship with Perl needs to be sensible about temporary file
handling, locking, input validation, and so on.
.Sh "Sort out the uid-setting mess"
.IX Subsection "Sort out the uid-setting mess"
Currently there are several problems with the setting of uids ($<, $>
for the real and effective uids).  Firstly, what exactly \fIsetuid()\fR call
gets invoked in which platform is simply a big mess that needs to be
untangled.  Secondly, the effects are apparently not standard across
platforms, (if you first set $< and then $>, or vice versa, being
uid == euid == zero, or just euid == zero, or as a normal user, what are
the results?).  The test suite not (usually) being run as root means
that these things do not get much testing.  Thirdly, there's quite
often a third uid called saved uid, and Perl has no knowledge of that
feature in any way.  (If one has the saved uid of zero, one can get
back any real and effective uids.)  As an example, to change also the
saved uid, one needs to set the real and effective uids \fBtwice\fR\-\- in
most systems, that is: in HP-UX that doesn't seem to work.
.Sh "Custom opcodes"
.IX Subsection "Custom opcodes"
Have a way to introduce user-defined opcodes without the subroutine call
overhead of an \s-1XSUB\s0; the user should be able to create \s-1PP\s0 code. Simon
Cozens has some ideas on this.
.Sh "\s-1DLL\s0 Versioning"
.IX Subsection "DLL Versioning"
Windows needs a way to know what version of an \s-1XS\s0 or \f(CW\*(C`libperl\*(C'\fR \s-1DLL\s0 it's
loading.
.Sh "Introduce @( and @)"
.IX Subsection "Introduce @( and @)"
\&\f(CW$(\fR may return \*(L"foo bar baz\*(R". Unfortunately, since groups can
theoretically have spaces in their names, this could be one, two or
three groups.
.Sh "Floating point handling"
.IX Subsection "Floating point handling"
\&\f(CW\*(C`NaN\*(C'\fR and \f(CW\*(C`inf\*(C'\fR support is particularly troublesome.
(\fIfp_classify()\fR, \fIfp_class()\fR, \fIfp_class_d()\fR, \fIclass()\fR, \fIisinf()\fR,
\&\fIisfinite()\fR, \fIfinite()\fR, \fIisnormal()\fR, \fIunordered()\fR, <ieeefp.h>,
<fp_class.h> (there are metaconfig units for all these) (I think),
\&\fIfp_setmask()\fR, \fIfp_getmask()\fR, \fIfp_setround()\fR, \fIfp_getround()\fR
(no metaconfig units yet for these).  Don't forget \fIfinitel()\fR, \fIfp_classl()\fR,
\&\fIfp_class_l()\fR, (yes, both do, unfortunately, exist), and \fIunorderedl()\fR.)
.PP
As of Perl 5.6.1, there is a Perl macro, \fIPerl_isnan()\fR.
.Sh "\s-1IV/UV\s0 preservation"
.IX Subsection "IV/UV preservation"
Nicholas Clark has done a lot of work on this, but work is continuing.
\&\f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR and \f(CW\*(C`*\*(C'\fR work, but guards need to be in place for \f(CW\*(C`%\*(C'\fR, \f(CW\*(C`/\*(C'\fR,
\&\f(CW\*(C`&\*(C'\fR, \f(CW\*(C`oct\*(C'\fR, \f(CW\*(C`hex\*(C'\fR and \f(CW\*(C`pack\*(C'\fR.
.Sh "Replace pod2html with something using Pod::Parser"
.IX Subsection "Replace pod2html with something using Pod::Parser"
The \s-1CPAN\s0 module \f(CW\*(C`Marek::Pod::Html\*(C'\fR may be a more suitable basis for a
\&\f(CW\*(C`pod2html\*(C'\fR converter; the current one duplicates the functionality
abstracted in \f(CW\*(C`Pod::Parser\*(C'\fR, which makes updating the \s-1POD\s0 language
difficult.
.Sh "Automate module testing on \s-1CPAN\s0"
.IX Subsection "Automate module testing on CPAN"
When a new Perl is being beta tested, porters have to manually grab
their favourite \s-1CPAN\s0 modules and test them \- this should be done
automatically.
.Sh "sendmsg and recvmsg"
.IX Subsection "sendmsg and recvmsg"
We have all the other \s-1BSD\s0 socket functions but these. There are
metaconfig units for these functions which can be added. To avoid these
being new opcodes, a solution similar to the way \f(CW\*(C`sockatmark\*(C'\fR was added
would be preferable. (Autoload the \f(CW\*(C`IO::whatever\*(C'\fR module.)
.Sh "Rewrite perlre documentation"
.IX Subsection "Rewrite perlre documentation"
The new-style patterns need full documentation, and the whole document
needs to be a lot clearer.
.Sh "Convert example code to IO::Handle filehandles"
.IX Subsection "Convert example code to IO::Handle filehandles"
.Sh "Document Win32 choices"
.IX Subsection "Document Win32 choices"
.Sh "Check new modules"
.IX Subsection "Check new modules"
.Sh "Make roffitall find pods and libs itself"
.IX Subsection "Make roffitall find pods and libs itself"
Simon Cozens has done some work on this but it needs a rethink.
.SH "To do at some point"
.IX Header "To do at some point"
These are ideas that have been regularly tossed around, that most
people believe should be done maybe during 5.8.x
.Sh "Remove regular expression recursion"
.IX Subsection "Remove regular expression recursion"
Because the regular expression engine is recursive, badly designed
expressions can lead to lots of recursion filling up the stack. Ilya
claims that it is easy to convert the engine to being iterative, but
this has still not yet been done. There may be a regular expression
engine hit squad meeting at \s-1TPC5\s0.
.Sh "Memory leaks after failed eval"
.IX Subsection "Memory leaks after failed eval"
Perl will leak memory if you \f(CW\*(C`eval "hlagh hlagh hlagh hlagh"\*(C'\fR. This is
partially because it attempts to build up an op tree for that code and
doesn't properly free it. The same goes for non-syntactically-correct
regular expressions. Hugo looked into this, but decided it needed a
mark-and-sweep \s-1GC\s0 implementation. 
.PP
Alan notes that: The basic idea was to extend the parser token stack
(\f(CW\*(C`YYSTYPE\*(C'\fR) to include a type field so we knew what sort of thing each
element of the stack was.  The \fIperly.c\fR code would then have to be
postprocessed to record the type of each entry on the stack as it was
created, and the parser patched so that it could unroll the stack
properly on error.
.PP
This is possible to do, but would be pretty messy to implement, as it
would rely on even more sed hackery in \fIperly.fixer\fR.
.Sh "bitfields in pack"
.IX Subsection "bitfields in pack"
.Sh "Cross compilation"
.IX Subsection "Cross compilation"
Make Perl buildable with a cross\-compiler. This will play havoc with
Configure, which needs to know how the target system will respond to
its tests; maybe \f(CW\*(C`microperl\*(C'\fR will be a good starting point here.
(Indeed, Bart Schuller reports that he compiled up \f(CW\*(C`microperl\*(C'\fR for
the Agenda \s-1PDA\s0 and it works fine.)  A really big spanner in the works
is the bootstrapping build process of Perl: if the filesystem the
target systems sees is not the same what the build host sees, various
input, output, and (Perl) library files need to be copied back and forth.
.PP
As of 5.8.0 Configure mostly works for cross-compilation
(used successfully for iPAQ Linux), miniperl gets built,
but then building DynaLoader (and other extensions) fails
since MakeMaker knows nothing of cross\-compilation.
(See INSTALL/Cross\-compilation for the state of things.)
.Sh "Perl preprocessor / macros"
.IX Subsection "Perl preprocessor / macros"
Source filters help with this, but do not get us all the way. For
instance, it should be possible to implement the \f(CW\*(C`??\*(C'\fR operator somehow;
source filters don't (quite) cut it.
.Sh "Perl lexer in Perl"
.IX Subsection "Perl lexer in Perl"
Damian Conway is planning to work on this, but it hasn't happened yet.
.Sh "Using \s-1POSIX\s0 calls internally"
.IX Subsection "Using POSIX calls internally"
When faced with a \s-1BSD\s0 vs. SysV \-style interface to some library or
system function, perl's roots show in that it typically prefers the \s-1BSD\s0
interface (but falls back to the SysV one).  One example is \fIgetpgrp()\fR.
Other examples include \f(CW\*(C`memcpy\*(C'\fR vs. \f(CW\*(C`bcopy\*(C'\fR.  There are others, mostly in
\&\fIpp_sys.c\fR.
.PP
Mostly, this item is a suggestion for which way to start a journey into
an \f(CW\*(C`#ifdef\*(C'\fR forest.  It is not primarily a suggestion to eliminate any of
the \f(CW\*(C`#ifdef\*(C'\fR forests.
.PP
\&\s-1POSIX\s0 calls are perhaps more likely to be portable to unexpected
architectures. They are also perhaps more likely to be actively
maintained by a current vendor.  They are also perhaps more likely to be
available in thread-safe versions, if appropriate.
.Sh "\-i rename file when changed"
.IX Subsection "-i rename file when changed"
It's only necessary to rename a file when inplace editing when the file
has changed. Detecting a change is perhaps the difficult bit.
.Sh "All \s-1ARGV\s0 input should act like <>"
.IX Subsection "All ARGV input should act like <>"
eg \f(CW\*(C`read(ARGV, ...)\*(C'\fR doesn't currently read across multiple files.
.Sh "Support for rerunning debugger"
.IX Subsection "Support for rerunning debugger"
There should be a way of restarting the debugger on demand.
.Sh "Test Suite for the Debugger"
.IX Subsection "Test Suite for the Debugger"
The debugger is a complex piece of software and fixing something
here may inadvertently break something else over there.  To tame
this chaotic behaviour, a test suite is necessary. 
.Sh "my sub foo { }"
.IX Subsection "my sub foo { }"
The basic principle is sound, but there are problems with the semantics
of self-referential and mutually referential lexical subs: how to
declare the subs?
.Sh "One-pass global destruction"
.IX Subsection "One-pass global destruction"
Sweeping away all the allocated memory in one go is a laudable goal, but
it's difficult and in most cases, it's easier to let the memory get
freed by exiting.
.Sh "Rewrite regexp parser"
.IX Subsection "Rewrite regexp parser"
There has been talk recently of rewriting the regular expression parser
to produce an optree instead of a chain of opcodes; it's unclear whether
or not this would be a win. 
.Sh "Cache recently used regexps"
.IX Subsection "Cache recently used regexps"
This is to speed up 
.PP
.Vb 3
\&    for my $re (@regexps) {
\&        $matched++ if /$re/
\&    }
.Ve
.PP
\&\f(CW\*(C`qr//\*(C'\fR already gives us a way of saving compiled regexps, but it should
be done automatically.
.Sh "Cross-compilation support"
.IX Subsection "Cross-compilation support"
Bart Schuller reports that using \f(CW\*(C`microperl\*(C'\fR and a cross\-compiler, he
got Perl working on the Agenda \s-1PDA\s0. However, one cannot build a full
Perl because Configure needs to get the results for the target platform,
for the host.
.Sh "Bit-shifting bitvectors"
.IX Subsection "Bit-shifting bitvectors"
Given:
.PP
.Vb 1
\&    vec($v, 1000, 1) = 1;
.Ve
.PP
One should be able to do
.PP
.Vb 1
\&    $v <<= 1;
.Ve
.PP
and have the 999'th bit set.
.PP
Currently if you try with shift bitvectors you shift the \s-1NV/UV\s0, instead
of the bits in the \s-1PV\s0.  Not very logical.
.Sh "debugger pragma"
.IX Subsection "debugger pragma"
The debugger is implemented in Perl in \fIperl5db.pl\fR; turning it into a
pragma should be easy, but making it work lexically might be more
difficult. Fiddling with \f(CW$^P\fR would be necessary.
.Sh "use less pragma"
.IX Subsection "use less pragma"
Identify areas where speed/memory tradeoffs can be made and have a hint
to switch between them.
.Sh "switch structures"
.IX Subsection "switch structures"
Although we have \f(CW\*(C`Switch.pm\*(C'\fR in core, Larry points to the dormant
\&\f(CW\*(C`nswitch\*(C'\fR and \f(CW\*(C`cswitch\*(C'\fR ops in \fIpp.c\fR; using these opcodes would be
much faster.
.Sh "Cache eval tree"
.IX Subsection "Cache eval tree"
.Sh "rcatmaybe"
.IX Subsection "rcatmaybe"
.Sh "Shrink opcode tables"
.IX Subsection "Shrink opcode tables"
.ie n .Sh "Optimize away @_"
.el .Sh "Optimize away \f(CW@_\fP"
.IX Subsection "Optimize away @_"
Look at the \*(L"reification\*(R" code in \f(CW\*(C`av.c\*(C'\fR
.Sh "Prototypes versus indirect objects"
.IX Subsection "Prototypes versus indirect objects"
Currently, indirect object syntax bypasses prototype checks.
.Sh "Install \s-1HTML\s0"
.IX Subsection "Install HTML"
\&\s-1HTML\s0 versions of the documentation need to be installed by default; a
call to \f(CW\*(C`installhtml\*(C'\fR from \f(CW\*(C`installperl\*(C'\fR may be all that's necessary.
.Sh "Prototype method calls"
.IX Subsection "Prototype method calls"
.Sh "Return context prototype declarations"
.IX Subsection "Return context prototype declarations"
.Sh "magic_setisa"
.IX Subsection "magic_setisa"
.Sh "Garbage collection"
.IX Subsection "Garbage collection"
There have been persistent mumblings about putting a mark-and-sweep
garbage detector into Perl; Alan Burlison has some ideas about this.
.Sh "\s-1IO\s0 tutorial"
.IX Subsection "IO tutorial"
Mark-Jason Dominus has the beginnings of one of these.
.Sh "Rewrite perldoc"
.IX Subsection "Rewrite perldoc"
There are a few suggestions for what to do with \f(CW\*(C`perldoc\*(C'\fR: maybe a
full-text search, an index function, locating pages on a particular
high-level subject, and so on.
.Sh "Install .3p manpages"
.IX Subsection "Install .3p manpages"
This is a bone of contention; we can create \f(CW\*(C`.3p\*(C'\fR manpages for each
built-in function, but should we install them by default? Tcl does this,
and it clutters up \f(CW\*(C`apropos\*(C'\fR.
.Sh "Unicode tutorial"
.IX Subsection "Unicode tutorial"
Simon Cozens promises to do this before he gets old.
.Sh "Update \s-1POSIX\s0.pm for 1003.1\-2"
.IX Subsection "Update POSIX.pm for 1003.1-2"
.Sh "Retargetable installation"
.IX Subsection "Retargetable installation"
Allow \f(CW@INC\fR to be changed after Perl is built.
.Sh "\s-1POSIX\s0 emulation on non-POSIX systems"
.IX Subsection "POSIX emulation on non-POSIX systems"
Make \f(CW\*(C`POSIX.pm\*(C'\fR behave as POSIXly as possible everywhere, meaning we
have to implement \s-1POSIX\s0 equivalents for some functions if necessary.
.Sh "Rename Win32 headers"
.IX Subsection "Rename Win32 headers"
.Sh "Finish off lvalue functions"
.IX Subsection "Finish off lvalue functions"
They don't work in the debugger, and they don't work for list or hash
slices.
.Sh "Update sprintf documentation"
.IX Subsection "Update sprintf documentation"
Hugo van der Sanden plans to look at this.
.Sh "Use fchown/fchmod internally"
.IX Subsection "Use fchown/fchmod internally"
This has been done in places, but needs a thorough code review.
Also fchdir is available in some platforms.
.Sh "Make v\-strings overloaded objects"
.IX Subsection "Make v-strings overloaded objects"
Instead of having to guess whether a string is a v\-string and thus
needs to be displayed with \f(CW%vd\fR, make v\-strings (readonly) objects
(class \*(L"vstring\*(R"?) with a stringify overload.
.Sh "Allow restricted hash assignment"
.IX Subsection "Allow restricted hash assignment"
Currently you're not allowed to assign to a restricted hash at all,
even with the same keys.
.PP
.Vb 1
\&    %restricted = (foo => 42);  # error
.Ve
.PP
This should be allowed if the new keyset is a subset of the old
keyset.  May require more extra code than we'd like in pp_aassign.
.Sh "Should overload be inheritable?"
.IX Subsection "Should overload be inheritable?"
Should overload be 'contagious' through \f(CW@ISA\fR so that derived classes
would inherit their base classes' overload definitions?  What to do
in case of overload conflicts?
.Sh "Taint rethink"
.IX Subsection "Taint rethink"
Should taint be stopped from affecting control flow, if ($tainted)?
Should tainted symbolic method calls and subref calls be stopped?
(Look at Ruby's \f(CW$SAFE\fR levels for inspiration?)
.Sh "Perform correctly when XSUBs call subroutines that exit via goto(\s-1LABEL\s0) and friends"
.IX Subsection "Perform correctly when XSUBs call subroutines that exit via goto(LABEL) and friends"
If an \s-1XSUB\s0 calls a subroutine that exits using goto(\s-1LABEL\s0),
last(\s-1LABEL\s0) or next(\s-1LABEL\s0), then the interpreter will very probably crash
with a segfault because the execution resumes in the \s-1XSUB\s0 instead of
never returning there.
.SH "Vague ideas"
.IX Header "Vague ideas"
Ideas which have been discussed, and which may or may not happen.
.Sh "\fIref()\fP in list context"
.IX Subsection "ref() in list context"
It's unclear what this should do or how to do it without breaking old
code.
.Sh "Make tr/// return histogram of characters in list context"
.IX Subsection "Make tr/// return histogram of characters in list context"
There is a patch for this, but it may require Unicodification.
.Sh "Compile to real threaded code"
.IX Subsection "Compile to real threaded code"
.Sh "Structured types"
.IX Subsection "Structured types"
.ie n .Sh "Modifiable $1 et al."
.el .Sh "Modifiable \f(CW$1\fP et al."
.IX Subsection "Modifiable $1 et al."
.Vb 2
\&    ($x = "elephant") =~ /e(ph)/;
\&    $1 = "g"; # $x = "elegant"
.Ve
.PP
What happens if there are multiple (nested?) brackets? What if the
string changes between the match and the assignment?
.Sh "Procedural interfaces for IO::*, etc."
.IX Subsection "Procedural interfaces for IO::*, etc."
Some core modules have been accused of being overly\-OO. Adding
procedural interfaces could demystify them.
.Sh "\s-1RPC\s0 modules"
.IX Subsection "RPC modules"
.Sh "Attach/detach debugger from running program"
.IX Subsection "Attach/detach debugger from running program"
With \f(CW\*(C`gdb\*(C'\fR, you can attach the debugger to a running program if you
pass the process \s-1ID\s0. It would be good to do this with the Perl debugger
on a running Perl program, although I'm not sure how it would be done.
.Sh "GUI::Native"
.IX Subsection "GUI::Native"
A non-core module that would use \*(L"native\*(R" \s-1GUI\s0 to create graphical
applications.
.Sh "foreach(reverse ...)"
.IX Subsection "foreach(reverse ...)"
Currently
.PP
.Vb 1
\&    foreach (reverse @_) { ... }
.Ve
.PP
puts \f(CW@_\fR on the stack, reverses it putting the reversed version on the
stack, then iterates forwards. Instead, it could be special-cased to put
\&\f(CW@_\fR on the stack then iterate backwards.
.Sh "Constant function cache"
.IX Subsection "Constant function cache"
.Sh "Approximate regular expression matching"
.IX Subsection "Approximate regular expression matching"
.SH "Ongoing"
.IX Header "Ongoing"
These items \fBalways\fR need doing:
.Sh "Update guts documentation"
.IX Subsection "Update guts documentation"
Simon Cozens tries to do this when possible, and contributions to the
\&\f(CW\*(C`perlapi\*(C'\fR documentation is welcome.
.Sh "Add more tests"
.IX Subsection "Add more tests"
Michael Schwern will donate \f(CW$500\fR to Yet Another Society when all core
modules have tests.
.Sh "Update auxiliary tools"
.IX Subsection "Update auxiliary tools"
The code we ship with Perl should look like good Perl 5.
.Sh "Create debugging macros"
.IX Subsection "Create debugging macros"
Debugging macros (like printsv, dump) can make debugging perl inside a
C debugger much easier.  A good set for gdb comes with mod_perl.
Something similar should be distributed with perl.
.PP
The proper way to do this is to use and extend Devel::DebugInit.
Devel::DebugInit also needs to be extended to support threads.
.PP
See p5p archives for late May/early June 2001 for a recent discussion
on this topic.
.Sh "truncate to the people"
.IX Subsection "truncate to the people"
One can emulate \fIftruncate()\fR using F_FREESP and F_CHSIZ fcntls
(see the \s-1UNIX\s0 \s-1FAQ\s0 for details).  This needs to go somewhere near
pp_sys.\fIc:pp_truncate()\fR.
.PP
One can emulate \fItruncate()\fR easily if one has \fIftruncate()\fR.
This emulation should also go near pp_sys.\fIpp_truncate()\fR.
.Sh "Unicode in Filenames"
.IX Subsection "Unicode in Filenames"
chdir, chmod, chown, chroot, exec, glob, link, lstat, mkdir, open,
opendir, qx, readdir, readlink, rename, rmdir, stat, symlink, sysopen,
system, truncate, unlink, utime, \-X.  All these could potentially accept
Unicode filenames either as input or output (and in the case of system
and qx Unicode in general, as input or output to/from the shell).
Whether a filesystem \- an operating system pair understands Unicode in
filenames varies.
.PP
Known combinations that have some level of understanding include
Microsoft \s-1NTFS\s0, Apple \s-1HFS+\s0 (In Mac \s-1OS\s0 9 and X) and Apple \s-1UFS\s0 (in Mac
\&\s-1OS\s0 X), \s-1NFS\s0 v4 is rumored to be Unicode, and of course Plan 9.  How to
create Unicode filenames, what forms of Unicode are accepted and used
(\s-1UCS\-2\s0, \s-1UTF\-16\s0, \s-1UTF\-8\s0), what (if any) is the normalization form used,
and so on, varies.  Finding the right level of interfacing to Perl
requires some thought.  Remember that an \s-1OS\s0 does not implicate a
filesystem.
.PP
(The Windows \-C command flag \*(L"wide \s-1API\s0 support\*(R" has been at least
temporarily retired in 5.8.1, and the \-C has been repurposed, see
perlrun.)
.ie n .SH "Unicode in %ENV"
.el .SH "Unicode in \f(CW%ENV\fP"
.IX Header "Unicode in %ENV"
Currently the \f(CW%ENV\fR entries are always byte strings.
.SH "Recently done things"
.IX Header "Recently done things"
These are things which have been on the todo lists in previous releases
but have recently been completed.
.Sh "Alternative \s-1RE\s0 syntax module"
.IX Subsection "Alternative RE syntax module"
The \f(CW\*(C`Regexp::English\*(C'\fR module, available from the \s-1CPAN\s0, provides this:
.PP
.Vb 10
\&    my $re = Regexp::English
\&    -> start_of_line
\&    -> literal('Flippers')
\&    -> literal(':')
\&    -> optional
\&        -> whitespace_char
\&    -> end
\&    -> remember
\&        -> multiple
\&            -> digit;
.Ve
.PP
.Vb 1
\&    /$re/;
.Ve
.Sh "Safe signal handling"
.IX Subsection "Safe signal handling"
A new signal model went into 5.7.1 without much fanfare. Operations and
\&\f(CW\*(C`malloc\*(C'\fRs are no longer interrupted by signals, which are handled
between opcodes. This means that \f(CW\*(C`PERL_ASYNC_CHECK\*(C'\fR now actually does
something. However, there are still a few things that need to be done.
.Sh "Tie Modules"
.IX Subsection "Tie Modules"
Modules which implement arrays in terms of strings, substrings or files
can be found on the \s-1CPAN\s0.
.Sh "gettimeofday"
.IX Subsection "gettimeofday"
\&\f(CW\*(C`Time::HiRes\*(C'\fR has been integrated into the core.
.Sh "setitimer and getimiter"
.IX Subsection "setitimer and getimiter"
Adding \f(CW\*(C`Time::HiRes\*(C'\fR got us this too.
.Sh "Testing _\|_DIE_\|_ hook"
.IX Subsection "Testing __DIE__ hook"
Tests have been added.
.Sh "\s-1CPP\s0 equivalent in Perl"
.IX Subsection "CPP equivalent in Perl"
A C Yardley will probably have done this by the time you can read this.
This allows for a generalization of the C constant detection used in
building \f(CW\*(C`Errno.pm\*(C'\fR.
.Sh "Explicit switch statements"
.IX Subsection "Explicit switch statements"
\&\f(CW\*(C`Switch.pm\*(C'\fR has been integrated into the core to give you all manner of
\&\f(CW\*(C`switch...case\*(C'\fR semantics.
.Sh "autocroak"
.IX Subsection "autocroak"
This is \f(CW\*(C`Fatal.pm\*(C'\fR.
.Sh "\s-1UTF/EBCDIC\s0"
.IX Subsection "UTF/EBCDIC"
Nick Ing-Simmons has made UTF-EBCDIC (\s-1UTR13\s0) work with Perl.
.PP
.Vb 1
\&    EBCDIC?        http://www.unicode.org/unicode/reports/tr16/
.Ve
.Sh "\s-1UTF\s0 Regexes"
.IX Subsection "UTF Regexes"
Although there are probably some small bugs to be rooted out, Jarkko
Hietaniemi has made regular expressions polymorphic between bytes and
characters.
.Sh "perlcc to produce executable"
.IX Subsection "perlcc to produce executable"
\&\f(CW\*(C`perlcc\*(C'\fR was recently rewritten, and can now produce standalone
executables.
.Sh "\s-1END\s0 blocks saved in compiled output"
.IX Subsection "END blocks saved in compiled output"
.Sh "Secure temporary file module"
.IX Subsection "Secure temporary file module"
Tim Jenness' \f(CW\*(C`File::Temp\*(C'\fR is now in core.
.Sh "Integrate Time::HiRes"
.IX Subsection "Integrate Time::HiRes"
This module is now part of core.
.Sh "Turn Cwd into \s-1XS\s0"
.IX Subsection "Turn Cwd into XS"
Benjamin Sugars has done this.
.Sh "Mmap for input"
.IX Subsection "Mmap for input"
Nick Ing\-Simmons' \f(CW\*(C`perlio\*(C'\fR supports an \f(CW\*(C`mmap\*(C'\fR \s-1IO\s0 method.
.Sh "Byte to/from \s-1UTF\-8\s0 and \s-1UTF\-8\s0 to/from local conversion"
.IX Subsection "Byte to/from UTF-8 and UTF-8 to/from local conversion"
\&\f(CW\*(C`Encode\*(C'\fR provides this.
.Sh "Add sockatmark support"
.IX Subsection "Add sockatmark support"
Added in 5.7.1
.Sh "Mailing list archives"
.IX Subsection "Mailing list archives"
http://lists.perl.org/ , http://archive.develooper.com/
.Sh "Bug tracking"
.IX Subsection "Bug tracking"
Since 5.8.0 perl uses the \s-1RT\s0 bug tracking system from Jesse Vincent,
implemented by Robert Spier at http://bugs.perl.org/
.Sh "Integrate MacPerl"
.IX Subsection "Integrate MacPerl"
Chris Nandor and Matthias Neeracher have integrated the MacPerl changes
into 5.6.0.
.ie n .Sh "Web ""nerve center"" for Perl"
.el .Sh "Web ``nerve center'' for Perl"
.IX Subsection "Web nerve center for Perl"
http://use.perl.org/ is what you're looking for.
.Sh "Regular expression tutorial"
.IX Subsection "Regular expression tutorial"
\&\f(CW\*(C`perlretut\*(C'\fR, provided by Mark Kvale.
.Sh "Debugging Tutorial"
.IX Subsection "Debugging Tutorial"
\&\f(CW\*(C`perldebtut\*(C'\fR, written by Richard Foley.
.Sh "Integrate new modules"
.IX Subsection "Integrate new modules"
Jarkko has been integrating madly into 5.7.x
.Sh "Integrate profiler"
.IX Subsection "Integrate profiler"
\&\f(CW\*(C`Devel::DProf\*(C'\fR is now a core module.
.Sh "Y2K error detection"
.IX Subsection "Y2K error detection"
There's a configure option to detect unsafe concatenation with \*(L"19\*(R", and
a \s-1CPAN\s0 module. (\f(CW\*(C`D'oh::Year\*(C'\fR)
.Sh "Regular expression debugger"
.IX Subsection "Regular expression debugger"
While not part of core, Mark-Jason Dominus has written \f(CW\*(C`Rx\*(C'\fR and has
also come up with a generalised strategy for regular expression
debugging.
.Sh "\s-1POD\s0 checker"
.IX Subsection "POD checker"
That's, uh, \fIpodchecker\fR
.ie n .Sh """Dynamic"" lexicals"
.el .Sh "``Dynamic'' lexicals"
.IX Subsection "Dynamic lexicals"
.Sh "Cache precompiled modules"
.IX Subsection "Cache precompiled modules"
.SH "Deprecated Wishes"
.IX Header "Deprecated Wishes"
These are items which used to be in the todo file, but have been
deprecated for some reason.
.Sh "Loop control on do{}"
.IX Subsection "Loop control on do{}"
This would break old code; use \f(CW\*(C`do{{ }}\*(C'\fR instead.
.Sh "Lexically scoped typeglobs"
.IX Subsection "Lexically scoped typeglobs"
Not needed now we have lexical \s-1IO\s0 handles.
.Sh "format \s-1BOTTOM\s0"
.IX Subsection "format BOTTOM"
.Sh "report \s-1HANDLE\s0"
.IX Subsection "report HANDLE"
Damian Conway's text formatting modules seem to be the Way To Go.
.Sh "Generalised \fIwant()\fP/\fIcaller()\fP)"
.IX Subsection "Generalised want()/caller())"
Robin Houston's \f(CW\*(C`Want\*(C'\fR module does this.
.Sh "Named prototypes"
.IX Subsection "Named prototypes"
This seems to be delayed until Perl 6.
.Sh "Built-in globbing"
.IX Subsection "Built-in globbing"
The \f(CW\*(C`File::Glob\*(C'\fR module has been used to replace the \f(CW\*(C`glob\*(C'\fR function.
.Sh "Regression tests for suidperl"
.IX Subsection "Regression tests for suidperl"
\&\f(CW\*(C`suidperl\*(C'\fR is deprecated in favour of common sense.
.Sh "Cached hash values"
.IX Subsection "Cached hash values"
We have shared hash keys, which perform the same job.
.Sh "Add compression modules"
.IX Subsection "Add compression modules"
The compression modules are a little heavy; meanwhile, Nick Clark is
working on experimental pragmata to do transparent decompression on
input.
.Sh "Reorganise documentation into tutorials/references"
.IX Subsection "Reorganise documentation into tutorials/references"
Could not get consensus on P5P about this.
.Sh "Remove distinction between functions and operators"
.IX Subsection "Remove distinction between functions and operators"
Caution: highly flammable.
.Sh "Make \s-1XS\s0 easier to use"
.IX Subsection "Make XS easier to use"
Use \f(CW\*(C`Inline\*(C'\fR instead, or \s-1SWIG\s0.
.Sh "Make embedding easier to use"
.IX Subsection "Make embedding easier to use"
Use \f(CW\*(C`Inline::CPR\*(C'\fR.
.Sh "man for perl"
.IX Subsection "man for perl"
See the Perl Power Tools. ( http://language.perl.com/ppt/ )
.ie n .Sh "my $Package::variable"
.el .Sh "my \f(CW$Package::variable\fP"
.IX Subsection "my $Package::variable"
Use \f(CW\*(C`our\*(C'\fR instead.
.ie n .Sh """or"" tests defined, not truth"
.el .Sh "``or'' tests defined, not truth"
.IX Subsection "or tests defined, not truth"
Suggesting this on P5P \fBwill\fR cause a boring and interminable flamewar.
.ie n .Sh """class""\-based lexicals"
.el .Sh "``class''\-based lexicals"
.IX Subsection "class-based lexicals"
Use flyweight objects, secure hashes or, dare I say it, pseudo-hashes instead.
(Or whatever will replace pseudohashes in 5.10.)
.Sh "byteperl"
.IX Subsection "byteperl"
\&\f(CW\*(C`ByteLoader\*(C'\fR covers this.
.Sh "Lazy evaluation / tail recursion removal"
.IX Subsection "Lazy evaluation / tail recursion removal"
\&\f(CW\*(C`List::Util\*(C'\fR gives \fIfirst()\fR (a short-circuiting grep); tail recursion
removal is done manually, with \f(CW\*(C`goto &whoami;\*(C'\fR. (However, \s-1MJD\s0 has
found that \f(CW\*(C`goto &whoami\*(C'\fR introduces a performance penalty, so maybe
there should be a way to do this after all: \f(CW\*(C`sub foo {START: ... goto
START;\*(C'\fR is better.)
.ie n .Sh "Make ""use utf8"" the default"
.el .Sh "Make ``use utf8'' the default"
.IX Subsection "Make use utf8 the default"
Because of backward compatibility this is difficult: scripts could not
contain \fBany legacy eight-bit data\fR (like Latin\-1) anymore, even in
string literals or pod.  Also would introduce a measurable slowdown of
at least few percentages since all regular expression operations would
be done in full \s-1UTF\-8\s0.  But if you want to try this, add
\&\-DUSE_UTF8_SCRIPTS to your compilation flags.
.Sh "Unicode collation and normalization"
.IX Subsection "Unicode collation and normalization"
The Unicode::Collate and Unicode::Normalize modules
by \s-1SADAHIRO\s0 Tomoyuki have been included since 5.8.0.
.PP
.Vb 2
\&    Collation?     http://www.unicode.org/unicode/reports/tr10/
\&    Normalization? http://www.unicode.org/unicode/reports/tr15/
.Ve
.Sh "pack/unpack tutorial"
.IX Subsection "pack/unpack tutorial"
Wolfgang Laun finished what Simon Cozens started.
