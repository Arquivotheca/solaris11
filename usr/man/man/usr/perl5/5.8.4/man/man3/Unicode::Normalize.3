.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::Normalize 3"
.TH Unicode::Normalize 3 "2001-09-21" "perl v5.8.4" "Perl Programmers Reference Guide"
.SH "NAME"
Unicode::Normalize \- Unicode Normalization Forms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Unicode::Normalize;
.Ve
.PP
.Vb 4
\&  $NFD_string  = NFD($string);  # Normalization Form D
\&  $NFC_string  = NFC($string);  # Normalization Form C
\&  $NFKD_string = NFKD($string); # Normalization Form KD
\&  $NFKC_string = NFKC($string); # Normalization Form KC
.Ve
.PP
.Vb 1
\&   or
.Ve
.PP
.Vb 1
\&  use Unicode::Normalize 'normalize';
.Ve
.PP
.Vb 4
\&  $NFD_string  = normalize('D',  $string);  # Normalization Form D
\&  $NFC_string  = normalize('C',  $string);  # Normalization Form C
\&  $NFKD_string = normalize('KD', $string);  # Normalization Form KD
\&  $NFKC_string = normalize('KC', $string);  # Normalization Form KC
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parameters:
.PP
\&\f(CW$string\fR is used as a string under character semantics
(see \fIperlunicode\fR).
.PP
\&\f(CW$codepoint\fR should be an unsigned integer
representing a Unicode code point.
.PP
Note: Between \s-1XS\s0 edition and pure Perl edition,
interpretation of \f(CW$codepoint\fR as a decimal number has incompatibility.
\&\s-1XS\s0 converts \f(CW$codepoint\fR to an unsigned integer, but pure Perl does not.
Do not use a floating point nor a negative sign in \f(CW$codepoint\fR.
.Sh "Normalization Forms"
.IX Subsection "Normalization Forms"
.ie n .IP """$NFD_string = NFD($string)""" 4
.el .IP "\f(CW$NFD_string = NFD($string)\fR" 4
.IX Item "$NFD_string = NFD($string)"
returns the Normalization Form D (formed by canonical decomposition).
.ie n .IP """$NFC_string = NFC($string)""" 4
.el .IP "\f(CW$NFC_string = NFC($string)\fR" 4
.IX Item "$NFC_string = NFC($string)"
returns the Normalization Form C (formed by canonical decomposition
followed by canonical composition).
.ie n .IP """$NFKD_string = NFKD($string)""" 4
.el .IP "\f(CW$NFKD_string = NFKD($string)\fR" 4
.IX Item "$NFKD_string = NFKD($string)"
returns the Normalization Form \s-1KD\s0 (formed by compatibility decomposition).
.ie n .IP """$NFKC_string = NFKC($string)""" 4
.el .IP "\f(CW$NFKC_string = NFKC($string)\fR" 4
.IX Item "$NFKC_string = NFKC($string)"
returns the Normalization Form \s-1KC\s0 (formed by compatibility decomposition
followed by \fBcanonical\fR composition).
.ie n .IP """$FCD_string = FCD($string)""" 4
.el .IP "\f(CW$FCD_string = FCD($string)\fR" 4
.IX Item "$FCD_string = FCD($string)"
If the given string is in \s-1FCD\s0 (\*(L"Fast C or D\*(R" form; cf. \s-1UTN\s0 #5),
returns it without modification; otherwise returns an \s-1FCD\s0 string.
.Sp
Note: \s-1FCD\s0 is not always unique, then plural forms may be equivalent
each other. \f(CW\*(C`FCD()\*(C'\fR will return one of these equivalent forms.
.ie n .IP """$FCC_string = FCC($string)""" 4
.el .IP "\f(CW$FCC_string = FCC($string)\fR" 4
.IX Item "$FCC_string = FCC($string)"
returns the \s-1FCC\s0 form (\*(L"Fast C Contiguous\*(R"; cf. \s-1UTN\s0 #5).
.Sp
Note: \s-1FCC\s0 is unique, as well as four normalization forms (NF*).
.ie n .IP """$normalized_string = normalize($form_name, $string)""" 4
.el .IP "\f(CW$normalized_string = normalize($form_name, $string)\fR" 4
.IX Item "$normalized_string = normalize($form_name, $string)"
As \f(CW$form_name\fR, one of the following names must be given.
.Sp
.Vb 4
\&  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
\&  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
\&  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
\&  'KD' or 'NFKD' for Normalization Form KD (UAX #15)
.Ve
.Sp
.Vb 2
\&  'FCD'          for "Fast C or D" Form  (UTN #5)
\&  'FCC'          for "Fast C Contiguous" (UTN #5)
.Ve
.Sh "Decomposition and Composition"
.IX Subsection "Decomposition and Composition"
.ie n .IP """$decomposed_string = decompose($string)""" 4
.el .IP "\f(CW$decomposed_string = decompose($string)\fR" 4
.IX Item "$decomposed_string = decompose($string)"
.PD 0
.ie n .IP """$decomposed_string = decompose($string, $useCompatMapping)""" 4
.el .IP "\f(CW$decomposed_string = decompose($string, $useCompatMapping)\fR" 4
.IX Item "$decomposed_string = decompose($string, $useCompatMapping)"
.PD
Decomposes the specified string and returns the result.
.Sp
If the second parameter (a boolean) is omitted or false, decomposes it
using the Canonical Decomposition Mapping.
If true, decomposes it using the Compatibility Decomposition Mapping.
.Sp
The string returned is not always in \s-1NFD/NFKD\s0.
Reordering may be required.
.Sp
.Vb 2
\&    $NFD_string  = reorder(decompose($string));       # eq. to NFD()
\&    $NFKD_string = reorder(decompose($string, TRUE)); # eq. to NFKD()
.Ve
.ie n .IP """$reordered_string  = reorder($string)""" 4
.el .IP "\f(CW$reordered_string  = reorder($string)\fR" 4
.IX Item "$reordered_string  = reorder($string)"
Reorders the combining characters and the like in the canonical ordering
and returns the result.
.Sp
E.g., when you have a list of \s-1NFD/NFKD\s0 strings,
you can get the concatenated \s-1NFD/NFKD\s0 string from them, saying
.Sp
.Vb 2
\&    $concat_NFD  = reorder(join '', @NFD_strings);
\&    $concat_NFKD = reorder(join '', @NFKD_strings);
.Ve
.ie n .IP """$composed_string   = compose($string)""" 4
.el .IP "\f(CW$composed_string   = compose($string)\fR" 4
.IX Item "$composed_string   = compose($string)"
Returns the string where composable pairs are composed.
.Sp
E.g., when you have a \s-1NFD/NFKD\s0 string,
you can get its \s-1NFC/NFKC\s0 string, saying
.Sp
.Vb 2
\&    $NFC_string  = compose($NFD_string);
\&    $NFKC_string = compose($NFKD_string);
.Ve
.Sh "Quick Check"
.IX Subsection "Quick Check"
(see Annex 8, \s-1UAX\s0 #15; and \fIDerivedNormalizationProps.txt\fR)
.PP
The following functions check whether the string is in that normalization form.
.PP
The result returned will be:
.PP
.Vb 3
\&    YES     The string is in that normalization form.
\&    NO      The string is not in that normalization form.
\&    MAYBE   Dubious. Maybe yes, maybe no.
.Ve
.ie n .IP """$result = checkNFD($string)""" 4
.el .IP "\f(CW$result = checkNFD($string)\fR" 4
.IX Item "$result = checkNFD($string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR) or \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR).
.ie n .IP """$result = checkNFC($string)""" 4
.el .IP "\f(CW$result = checkNFC($string)\fR" 4
.IX Item "$result = checkNFC($string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR), \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR), or \f(CW\*(C`MAYBE\*(C'\fR (\f(CW\*(C`undef\*(C'\fR).
.ie n .IP """$result = checkNFKD($string)""" 4
.el .IP "\f(CW$result = checkNFKD($string)\fR" 4
.IX Item "$result = checkNFKD($string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR) or \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR).
.ie n .IP """$result = checkNFKC($string)""" 4
.el .IP "\f(CW$result = checkNFKC($string)\fR" 4
.IX Item "$result = checkNFKC($string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR), \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR), or \f(CW\*(C`MAYBE\*(C'\fR (\f(CW\*(C`undef\*(C'\fR).
.ie n .IP """$result = checkFCD($string)""" 4
.el .IP "\f(CW$result = checkFCD($string)\fR" 4
.IX Item "$result = checkFCD($string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR) or \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR).
.ie n .IP """$result = checkFCC($string)""" 4
.el .IP "\f(CW$result = checkFCC($string)\fR" 4
.IX Item "$result = checkFCC($string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR), \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR), or \f(CW\*(C`MAYBE\*(C'\fR (\f(CW\*(C`undef\*(C'\fR).
.Sp
If a string is not in \s-1FCD\s0, it must not be in \s-1FCC\s0.
So \f(CW\*(C`checkFCC($not_FCD_string)\*(C'\fR should return \f(CW\*(C`NO\*(C'\fR.
.ie n .IP """$result = check($form_name, $string)""" 4
.el .IP "\f(CW$result = check($form_name, $string)\fR" 4
.IX Item "$result = check($form_name, $string)"
returns \f(CW\*(C`YES\*(C'\fR (\f(CW1\fR), \f(CW\*(C`NO\*(C'\fR (\f(CW\*(C`empty string\*(C'\fR), or \f(CW\*(C`MAYBE\*(C'\fR (\f(CW\*(C`undef\*(C'\fR).
.Sp
\&\f(CW$form_name\fR is alike to that for \f(CW\*(C`normalize()\*(C'\fR.
.PP
\&\fBNote\fR
.PP
In the cases of \s-1NFD\s0, \s-1NFKD\s0, and \s-1FCD\s0, the answer must be
either \f(CW\*(C`YES\*(C'\fR or \f(CW\*(C`NO\*(C'\fR. The answer \f(CW\*(C`MAYBE\*(C'\fR may be returned
in the cases of \s-1NFC\s0, \s-1NFKC\s0, and \s-1FCC\s0.
.PP
A \f(CW\*(C`MAYBE\*(C'\fR string should contain at least one combining character
or the like. For example, \f(CW\*(C`COMBINING ACUTE ACCENT\*(C'\fR has
the \s-1MAYBE_NFC/MAYBE_NFKC\s0 property.
.PP
Both \f(CW\*(C`checkNFC("A\eN{COMBINING ACUTE ACCENT}")\*(C'\fR
and \f(CW\*(C`checkNFC("B\eN{COMBINING ACUTE ACCENT}")\*(C'\fR will return \f(CW\*(C`MAYBE\*(C'\fR.
\&\f(CW"A\eN{COMBINING ACUTE ACCENT}"\fR is not in \s-1NFC\s0
(its \s-1NFC\s0 is \f(CW"\eN{LATIN CAPITAL LETTER A WITH ACUTE}"\fR),
while \f(CW"B\eN{COMBINING ACUTE ACCENT}"\fR is in \s-1NFC\s0.
.PP
If you want to check exactly, compare the string with its \s-1NFC/NFKC/FCC\s0;
i.e.,
.PP
.Vb 3
\&    $string eq NFC($string)    # thorough than checkNFC($string)
\&    $string eq NFKC($string)   # thorough than checkNFKC($string)
\&    $string eq FCC($string)    # thorough than checkFCC($string)
.Ve
.Sh "Character Data"
.IX Subsection "Character Data"
These functions are interface of character data used internally.
If you want only to get Unicode normalization forms, you don't need
call them yourself.
.ie n .IP """$canonical_decomposed = getCanon($codepoint)""" 4
.el .IP "\f(CW$canonical_decomposed = getCanon($codepoint)\fR" 4
.IX Item "$canonical_decomposed = getCanon($codepoint)"
If the character of the specified codepoint is canonically
decomposable (including Hangul Syllables),
returns the \fBcompletely decomposed\fR string canonically equivalent to it.
.Sp
If it is not decomposable, returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """$compatibility_decomposed = getCompat($codepoint)""" 4
.el .IP "\f(CW$compatibility_decomposed = getCompat($codepoint)\fR" 4
.IX Item "$compatibility_decomposed = getCompat($codepoint)"
If the character of the specified codepoint is compatibility
decomposable (including Hangul Syllables),
returns the \fBcompletely decomposed\fR string compatibility equivalent to it.
.Sp
If it is not decomposable, returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """$codepoint_composite = getComposite($codepoint_here, $codepoint_next)""" 4
.el .IP "\f(CW$codepoint_composite = getComposite($codepoint_here, $codepoint_next)\fR" 4
.IX Item "$codepoint_composite = getComposite($codepoint_here, $codepoint_next)"
If two characters here and next (as codepoints) are composable
(including Hangul Jamo/Syllables and Composition Exclusions),
returns the codepoint of the composite.
.Sp
If they are not composable, returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """$combining_class = getCombinClass($codepoint)""" 4
.el .IP "\f(CW$combining_class = getCombinClass($codepoint)\fR" 4
.IX Item "$combining_class = getCombinClass($codepoint)"
Returns the combining class of the character as an integer.
.ie n .IP """$is_exclusion = isExclusion($codepoint)""" 4
.el .IP "\f(CW$is_exclusion = isExclusion($codepoint)\fR" 4
.IX Item "$is_exclusion = isExclusion($codepoint)"
Returns a boolean whether the character of the specified codepoint
is a composition exclusion.
.ie n .IP """$is_singleton = isSingleton($codepoint)""" 4
.el .IP "\f(CW$is_singleton = isSingleton($codepoint)\fR" 4
.IX Item "$is_singleton = isSingleton($codepoint)"
Returns a boolean whether the character of the specified codepoint is
a singleton.
.ie n .IP """$is_non_starter_decomposition = isNonStDecomp($codepoint)""" 4
.el .IP "\f(CW$is_non_starter_decomposition = isNonStDecomp($codepoint)\fR" 4
.IX Item "$is_non_starter_decomposition = isNonStDecomp($codepoint)"
Returns a boolean whether the canonical decomposition
of the character of the specified codepoint
is a Non-Starter Decomposition.
.ie n .IP """$may_be_composed_with_prev_char = isComp2nd($codepoint)""" 4
.el .IP "\f(CW$may_be_composed_with_prev_char = isComp2nd($codepoint)\fR" 4
.IX Item "$may_be_composed_with_prev_char = isComp2nd($codepoint)"
Returns a boolean whether the character of the specified codepoint
may be composed with the previous one in a certain composition
(including Hangul Compositions, but excluding
Composition Exclusions and Non-Starter Decompositions).
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
\&\f(CW\*(C`NFC\*(C'\fR, \f(CW\*(C`NFD\*(C'\fR, \f(CW\*(C`NFKC\*(C'\fR, \f(CW\*(C`NFKD\*(C'\fR: by default.
.PP
\&\f(CW\*(C`normalize\*(C'\fR and other some functions: on request.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1SADAHIRO\s0 Tomoyuki, <SADAHIRO@cpan.org>
.PP
.Vb 1
\&  http://homepage1.nifty.com/nomenclator/perl/
.Ve
.PP
.Vb 1
\&  Copyright(C) 2001-2003, SADAHIRO Tomoyuki. Japan. All rights reserved.
.Ve
.PP
.Vb 2
\&  This module is free software; you can redistribute it
\&  and/or modify it under the same terms as Perl itself.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "http://www.unicode.org/reports/tr15/" 4
.IX Item "http://www.unicode.org/reports/tr15/"
Unicode Normalization Forms \- \s-1UAX\s0 #15
.IP "http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt" 4
.IX Item "http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt"
Derived Normalization Properties
.IP "http://www.unicode.org/notes/tn5/" 4
.IX Item "http://www.unicode.org/notes/tn5/"
Canonical Equivalence in Applications \- \s-1UTN\s0 #5
