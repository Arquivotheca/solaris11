.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` 
.    ds C' 
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SUN::SOLARIS::KSTAT 1"
.TH SUN::SOLARIS::KSTAT 1 "2004-06-14" "perl v5.8.4" "Perl Programmers Reference Guide"
.SH "NAME"
Sun::Solaris::Kstat \- Perl tied hash interface to the kstat facility
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Sun::Solaris::Kstat;
.Ve
.PP
.Vb 3
\& my $ks = Sun::Solaris::Kstat->new();
\& $ks->update();
\& my $val = $ks->{$module}{$instance}{$name}{$statistic};
.Ve
.PP
This class provides access to the c<kstat(3KSTAT)> facility, which is used by
the kernel to export performance statistics.
.Sh "Constants"
.IX Subsection "Constants"
None.
.Sh "Functions"
.IX Subsection "Functions"
None.
.Sh "Class methods"
.IX Subsection "Class methods"
\&\fB\f(CB\*(C`new()\*(C'\fB\fR
.PP
This method creates a new Kstat object and returns a reference to the top-level
hash. Use it like any normal hash to access the statistics.
.PP
Kernel statistics are categorized using a 3\-part key consisting of the module,
the instance, and the statistic name.  For example, \s-1CPU\s0 information can be
found under \f(CW\*(C`cpu_stat:0:cpu_stat0\*(C'\fR, as in the above example.  The method
\&\f(CW\*(C`Sun::Solaris::Kstat\-\*(C'\fR\fInew()\fR> creates a new 3\-layer tree of Perl hashes with the
same structure; that is, the statistic for \s-1CPU\s0 0 can be accessed as
\&\f(CW\*(C`$ks\-\*(C'\fR{cpu_stat}{0}{cpu_stat0}>.  The fourth and lowest layer is a tied hash
used to hold the individual statistics values for a particular system resource.
.PP
For performance reasons, the creation of a \f(CW\*(C`Sun::Solaris::Kstat\*(C'\fR object is not
accompanied by a following read of all possible statistics.  Instead, the
3\-layer structure described above is created, but reads of a statistic's values
are done only when referenced.  For example, accessing
\&\f(CW\*(C`$ks\-\*(C'\fR{cpu_stat}{0}{cpu_stat0}{syscall}> will read in all the statistics for
\&\s-1CPU\s0 0, including user, system, and wait times, and the other \s-1CPU\s0 statistics, as
well as the number of system call entries.  Once you have accessed a lowest
level statistics value, calling \f(CW\*(C`$ks\-\*(C'\fRupdate> will automatically update all the
individual values of any statistics you have accessed.
.PP
Note that there are two values of the lowest-level hash that can be read
without causing the full set of statistics to be read from the kernel.  These
are \f(CW\*(C`class\*(C'\fR, which is the kstat class of the statistics, and \f(CW\*(C`crtime\*(C'\fR, which
is the time that the kstat was created.  See \f(CW\*(C`kstat(3KSTAT)\*(C'\fR for full details
of these fields.
.Sh "Object methods"
.IX Subsection "Object methods"
\&\fB\f(CB\*(C`update()\*(C'\fB\fR
.PP
This method updates all the statistics that have been accessed so far.  In
scalar context, \f(CW\*(C`update()\*(C'\fR returns 1 if the kstat structure has changed, and 0
otherwise. In list context, \fIupdate()\fR returns references to two arrays: the
first holds the keys of any kstats that have been added, and the second holds
the keys of any kstats that have been deleted. Each key will be returned in the
form \f(CW\*(C`module:instance:name\*(C'\fR.
.Sh "Exports"
.IX Subsection "Exports"
None.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& use Sun::Solaris::Kstat;
.Ve
.PP
.Vb 19
\& my $kstat = Sun::Solaris::Kstat->new();
\& my ($usr1, $sys1, $wio1, $idle1) =
\&    @{$kstat->{cpu_stat}{0}{cpu_stat0}}{qw(user kernel wait idle)};
\& print("usr sys wio idle\en");
\& while (1) {
\&     sleep(5);
\&     if ($kstat->update()) {
\&         print("Configuration changed\en");
\&     }
\&     my ($usr2, $sys2, $wio2, $idle2) =
\&         @{$kstat->{cpu_stat}{0}{cpu_stat0}}{qw(user kernel wait idle)};
\&     printf(" %.2d  %.2d  %.2d  %.2d\en",
\&     ($usr2 - $usr1) / 5, ($sys2 - $sys1) / 5,
\&     ($wio2 - $wio1) / 5, ($idle2 - $idle1) / 5);
\&     $usr1 = $usr2;
\&     $sys1 = $sys2;
\&     $wio1 = $wio2;
\&     $idle1 = $idle2;
\& }
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
See \f(CWattributes(5)\fR for descriptions of the following attributes:
.PP
.Vb 7
\&  ___________________________________________________________
\& |       ATTRIBUTE TYPE        |       ATTRIBUTE VALUE       |
\& |_____________________________|_____________________________|
\& | Availability                | CPAN (http://www.cpan.org)  |
\& |_____________________________|_____________________________|
\& | Interface Stability         | Evolving                    |
\& |_____________________________|_____________________________|
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\f(CWperl(1)\fR, \f(CW\*(C`kstat(1M)\*(C'\fR, \f(CW\*(C`kstat(3KSTAT)\*(C'\fR, \f(CW\*(C`kstat_chain_update(3KSTAT)\*(C'\fR,
\&\f(CW\*(C`kstat_close(3KSTAT)\*(C'\fR, \f(CW\*(C`kstat_open(3KSTAT)\*(C'\fR, \f(CW\*(C`kstat_read(3KSTAT)\*(C'\fR
.SH "NOTES"
.IX Header "NOTES"
As the statistics are stored in a tied hash, taking additional references of
members of the hash, such as
.PP
.Vb 2
\& my $ref = \e$ks->{cpu_stat}{0}{cpu_stat0}{syscall};
\& print("$$ref\en");
.Ve
.PP
Probably won't do what you expect, as the value pointed to by the reference
will not be updated by a subsequent call to \f(CW\*(C`update()\*(C'\fR.
