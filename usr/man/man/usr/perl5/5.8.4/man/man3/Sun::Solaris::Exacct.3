.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` 
.    ds C' 
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SUN::SOLARIS::EXACCT 1"
.TH SUN::SOLARIS::EXACCT 1 "2004-06-14" "perl v5.8.4" "Perl Programmers Reference Guide"
.SH "NAME"
Sun::Solaris::Exacct \- exacct system calls and error handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Sun::Solaris::Exacct qw(:EXACCT_ALL);
\& my $ea_rec = getacct(P_PID, $$);
.Ve
.PP
This module provides access to the \f(CW\*(C`ea_error(3EXACCT)\*(C'\fR function and for all the
extended accounting system calls. Constants from the various \f(CW\*(C`libexacct(3LIB)\*(C'\fR
header files are also provided.
.Sh "Constants"
.IX Subsection "Constants"
The \f(CW\*(C`P_PID\*(C'\fR, \f(CW\*(C`P_TASKID\*(C'\fR, \f(CW\*(C`P_PROJID\*(C'\fR and all the \f(CW\*(C`EW_*\*(C'\fR, \f(CW\*(C`EP_*\*(C'\fR, \f(CW\*(C`EXR_*\*(C'\fR
macros are provided as Perl constants.
.Sh "Functions"
.IX Subsection "Functions"
\&\fB\f(CB\*(C`getacct($idtype, $id)\*(C'\fB\fR
.PP
The \f(CW$idtype\fR parameter must be either \f(CW\*(C`P_TASKID\*(C'\fR or \f(CW\*(C`P_PID\*(C'\fR and \f(CW$id\fR
must be a corresponding task or process \s-1ID\s0. This function returns an object of
type \f(CW\*(C`Sun::Solaris::Exacct::Object\*(C'\fR, representing the unpacked accounting
buffer returned by the underlying \f(CWgetacct(2)\fR system call. In the event of
error, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\&\fB\f(CB\*(C`putacct($idtype, $id, $record)\*(C'\fB\fR
.PP
The \f(CW$idtype\fR parameter must be either \f(CW\*(C`P_TASKID\*(C'\fR or \f(CW\*(C`P_PID\*(C'\fR and \f(CW$id\fR
must be a corresponding task or process \s-1ID\s0. If \f(CW$record\fR is of type
\&\f(CW\*(C`Sun::Solaris::Exacct::Object\*(C'\fR, it is converted to the corresponding packed
libexacct object and passed to the \f(CWputacct(2)\fR system call. If \f(CW$record\fR is
not of type \f(CW\*(C`Sun::Solaris::Exacct::Object\*(C'\fR it is converted to a string using
the normal Perl conversion rules and stored as a raw buffer. For predictable
and endian-independent results, any raw buffers should be constructed using
the Perl \f(CW\*(C`pack()\*(C'\fR function. This function returns \f(CW\*(C`true\*(C'\fR on success and
\&\f(CW\*(C`false\*(C'\fR on failure.
.PP
\&\fB\f(CB\*(C`wracct($idtype, $id, $flags)\*(C'\fB\fR
.PP
The \f(CW$idtype\fR parameter must be either \f(CW\*(C`P_TASKID\*(C'\fR or \f(CW\*(C`P_PID\*(C'\fR and \f(CW$id\fR must
be a corresponding task or process \s-1ID\s0. The \f(CW$flags\fR parameter must be either
\&\f(CW\*(C`EW_INTERVAL\*(C'\fR or \f(CW\*(C`EW_PARTIAL\*(C'\fR. The parameters are passed directly to the
underlying \f(CWwracct(2)\fR system call. This function returns \f(CW\*(C`true\*(C'\fR on success
and \f(CW\*(C`false\*(C'\fR on failure.
.PP
\&\fB\f(CB\*(C`ea_error()\*(C'\fB\fR
.PP
This function provides access to the \f(CW\*(C`ea_error(3EXACCT)\*(C'\fR function. It returns
a double-typed scalar that in a numeric context will be one of the \f(CW\*(C`EXR_*\*(C'\fR
constants. In a string context it will be a descriptive error message. This is
the exacct equivalent to the \f(CW$!\fR (\f(CW\*(C`errno\*(C'\fR) Perl variable.
.PP
\&\fB\f(CB\*(C`ea_error_str()\*(C'\fB\fR
.PP
This function returns a double-typed scalar that in a numeric context will be
one of the \f(CW\*(C`EXR_*\*(C'\fR constants as returned by \f(CW\*(C`ea_error\*(C'\fR. In a string context
it describes the value returned by \f(CW\*(C`ea_error\*(C'\fR. If \f(CW\*(C`ea_error\*(C'\fR returns
\&\f(CW\*(C`EXR_SYSCALL_FAIL\*(C'\fR, the string value returned is the value returned by
\&\f(CW\*(C`strerror(3C)\*(C'\fR. This function is provided as a convenience so that repeated
blocks of code like the following can be avoided:
.PP
.Vb 5
\& if (ea_error() == EXR_SYSCALL_FAIL) {
\&         print("error: $!\en");
\& } else {
\&         print("error: ", ea_error(), "\en");
\& }
.Ve
.PP
\&\fB\f(CB\*(C`ea_register_catalog($cat_pfx, $catalog_id, $export, @idlist)\*(C'\fB\fR
.PP
This convenience function is a wrapper around the
\&\f(CW\*(C`Sun::Solaris::Exacct::Catalog\->register()\*(C'\fR method.
.PP
\&\fB\f(CB\*(C`ea_new_catalog($integer)\*(C'\fB\fR
.PP
\&\fB\f(CB\*(C`ea_new_catalog($cat_obj)\*(C'\fB\fR
.PP
\&\fB\f(CB\*(C`ea_new_catalog($type, $catalog, $id)\*(C'\fB\fR
.PP
These convenience functions are wrappers around the
\&\f(CW\*(C`Sun::Solaris::Exacct::Catalog\->new()\*(C'\fR method. See
\&\f(CWSun::Solaris::Exacct::Catalog(3)\fR.
.PP
\&\fB\f(CB\*(C`ea_new_file($name, $oflags, creator => $creator,
    aflags => $aflags, mode => $mode)\*(C'\fB\fR
.PP
This convenience function is a wrapper around the
\&\f(CW\*(C`Sun::Solaris::Exacct::File\->new()\*(C'\fR method. See
\&\f(CWSun::Solaris::Exacct::File(3)\fR.
.PP
\&\fB\f(CB\*(C`ea_new_item($catalog, $value)\*(C'\fB\fR
.PP
This convenience function is a wrapper around the
\&\f(CW\*(C`Sun::Solaris::Exacct::Object::Item\->new()\*(C'\fR method. See
\&\f(CWSun::Solaris::Exacct::Object::Item(3)\fR.
.PP
\&\fB\f(CB\*(C`ea_new_group($catalog, @objects)\*(C'\fB\fR
.PP
This convenience function is a wrapper around the
\&\f(CW\*(C`Sun::Solaris::Exacct::Object::Group\->new()\*(C'\fR method. See
\&\f(CWExacct::Object::Group(3)\fR.
.PP
\&\fB\f(CB\*(C`ea_dump_object($object, $filehandle)\*(C'\fB\fR
.PP
This convenience function is a wrapper around the
\&\f(CW\*(C`Sun::Solaris::Exacct::Object\->dump()\*(C'\fR method.  See
\&\f(CWSun::Solaris::Exacct::Object(3)\fR.
.Sh "Class methods"
.IX Subsection "Class methods"
None.
.Sh "Object methods"
.IX Subsection "Object methods"
None.
.Sh "Exports"
.IX Subsection "Exports"
By default nothing is exported from this module. The following tags can be
used to selectively import constants and functions defined in this module:
.PP
.Vb 1
\& :SYSCALLS           getacct(), putacct(), and wracct()
.Ve
.PP
.Vb 1
\& :LIBCALLS           ea_error() and ea_error_str()
.Ve
.PP
.Vb 1
\& :CONSTANTS          P_PID, P_TASKID, P_PROJID, EW_*, EP_*, and EXR_*
.Ve
.PP
.Vb 2
\& :SHORTHAND          ea_register_catalog(), ea_new_catalog(), ea_new_file(),
\&                     ea_new_item(), and ea_new_group()
.Ve
.PP
.Vb 1
\& :ALL                :SYSCALLS, :LIBCALLS, :CONSTANTS, and :SHORTHAND
.Ve
.PP
.Vb 3
\& :EXACCT_CONSTANTS   :CONSTANTS, plus the :CONSTANTS tags for
\&                     Sun::Solaris::Catalog, Sun::Solaris::File,
\&                     and Sun::Solaris::Object
.Ve
.PP
.Vb 2
\& :EXACCT_ALL         :ALL, plus the :ALL tags for Sun::Solaris::Catalog,
\&                     Sun::Solaris::File, and Sun::Solaris::Object
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
See \f(CWattributes(5)\fR for descriptions of the following attributes:
.PP
.Vb 7
\&  ___________________________________________________________
\& |       ATTRIBUTE TYPE        |       ATTRIBUTE VALUE       |
\& |_____________________________|_____________________________|
\& | Availability                | CPAN (http://www.cpan.org)  |
\& |_____________________________|_____________________________|
\& | Interface Stability         | Evolving                    |
\& |_____________________________|_____________________________|
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\f(CWgetacct(2)\fR, \f(CWputacct(2)\fR, \f(CWwracct(2)\fR, \f(CW\*(C`ea_error(3EXACCT)\*(C'\fR,
\&\f(CWSun::Solaris::Exacct::Catalog(3)\fR, \f(CWSun::Solaris::Exacct::File(3)\fR,
\&\f(CWSun::Solaris::Exacct::Object(3)\fR, \f(CWSun::Solaris::Exacct::Object::Group(3)\fR,
\&\f(CWSun::Solaris::Exacct::Object::Item(3)\fR, \f(CW\*(C`libexacct(3LIB)\*(C'\fR, \f(CWattributes(5)\fR
.SH "NOTES"
.IX Header "NOTES"
The modules described in the \f(CW\*(C`Sun::Solaris::Exacct\*(C'\fR manual pages make
extensive use of the Perl \*(L"double\-typed scalar\*(R" facility. This facility allows
a scalar value to behave either as an integer or as a string, depending upon
context. It is the same behavior as exhibited by the \f(CW$!\fR Perl variable
(\f(CW\*(C`errno\*(C'\fR). It is useful because it avoids the need to map from an integer
value to the corresponding string to display a value. Some examples are
provided below:
.PP
.Vb 2
\& # Assume $obj is a Sun::Solaris::Exacct::Item
\& my $type = $obj->type();
.Ve
.PP
.Vb 2
\& # Print "2 EO_ITEM"
\& printf("%d %s\en", $type, $type);
.Ve
.PP
.Vb 2
\& # Behave as an integer, $i == 2
\& my $i = 0 + $type;
.Ve
.PP
.Vb 2
\& # Behave as a string, $s = "abc EO_ITEM xyx"
\& my $s = "abc $type xyz";
.Ve
.PP
Wherever a function or method is documented as returning a double-typed
scalar, the returned value exhibits this type of behavior.
